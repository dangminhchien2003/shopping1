{
  "_entries": [
    {
      "name": "dayjs",
      "path": "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\dayjs\\dayjs.min.js",
      "lastModified": 1769402985824,
      "type": "module",
      "originalName": "dayjs.min",
      "code": "sap.ui.define(['./_commonjsHelpers'], (function (_commonjsHelpers) { 'use strict';\n\n\tfunction _mergeNamespaces(n, m) {\n\t\tm.forEach(function (e) {\n\t\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn Object.freeze(n);\n\t}\n\n\tvar dayjs_min$2 = {exports: {}};\n\n\tvar dayjs_min$1 = dayjs_min$2.exports;\n\n\tvar hasRequiredDayjs_min;\n\n\tfunction requireDayjs_min () {\n\t\tif (hasRequiredDayjs_min) return dayjs_min$2.exports;\n\t\thasRequiredDayjs_min = 1;\n\t\t(function (module, exports$1) {\n\t\t\t!function(t,e){module.exports=e();}(dayjs_min$1,(function(){var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",c=\"month\",f=\"quarter\",h=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return \"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=\"$isDayjsObject\",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else {var a=e.name;D[a]=e,i=a;}return !r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,true),this.parse(t),this.$x=this.$x||t.x||{},this[p]=true;}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return b},m.isValid=function(){return !(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,false)},m.$set=function(t,e){var n,o=b.p(t),f=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=f+\"Date\",n[d]=f+\"Date\",n[c]=f+\"Month\",n[h]=f+\"FullYear\",n[u]=f+\"Hours\",n[s]=f+\"Minutes\",n[i]=f+\"Seconds\",n[r]=f+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,\"0\")},$=f||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case \"YY\":return String(e.$y).slice(-2);case \"YYYY\":return b.s(e.$y,4,\"0\");case \"M\":return a+1;case \"MM\":return b.s(a+1,2,\"0\");case \"MMM\":return h(n.monthsShort,a,c,3);case \"MMMM\":return h(c,a);case \"D\":return e.$D;case \"DD\":return b.s(e.$D,2,\"0\");case \"d\":return String(e.$W);case \"dd\":return h(n.weekdaysMin,e.$W,o,2);case \"ddd\":return h(n.weekdaysShort,e.$W,o,3);case \"dddd\":return o[e.$W];case \"H\":return String(s);case \"HH\":return b.s(s,2,\"0\");case \"h\":return d(1);case \"hh\":return d(2);case \"a\":return $(s,u,true);case \"A\":return $(s,u,false);case \"m\":return String(u);case \"mm\":return b.s(u,2,\"0\");case \"s\":return String(e.$s);case \"ss\":return b.s(e.$s,2,\"0\");case \"SSS\":return b.s(e.$ms,3,\"0\");case \"Z\":return i}return null}(t)||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g;}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,true);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",c],[\"$y\",h],[\"$D\",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=true),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));\n\t\t} (dayjs_min$2));\n\t\treturn dayjs_min$2.exports;\n\t}\n\n\tvar dayjs_minExports = requireDayjs_min();\n\tvar defExp = /*@__PURE__*/_commonjsHelpers.getDefaultExportFromCjs(dayjs_minExports);\n\n\tvar namedExports = /*#__PURE__*/_mergeNamespaces({\n\t\t__proto__: null,\n\t\tdefault: defExp\n\t}, [dayjs_minExports]);\n\n\tconst defaultExports = Object.isFrozen(defExp) ? Object.assign({}, defExp?.default || defExp || { __emptyModule: true }) : defExp;\n\tObject.keys(namedExports || {}).filter((key) => !defaultExports[key]).forEach((key) => defaultExports[key] = namedExports[key]);\n\tObject.defineProperty(defaultExports, \"__\" + \"esModule\", { value: true });\n\tvar dayjs_min = Object.isFrozen(defExp) ? Object.freeze(defaultExports) : defaultExports;\n\n\treturn dayjs_min;\n\n}));\n",
      "relatedPaths": [
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\dayjs\\dayjs.min.js"
      ],
      "imports": [
        "_commonjsHelpers.js"
      ],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    },
    {
      "name": "dayjs/plugin/isSameOrAfter",
      "path": "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\dayjs\\plugin\\isSameOrAfter.js",
      "lastModified": 1769402988132,
      "type": "module",
      "originalName": "isSameOrAfter",
      "code": "sap.ui.define(['../../_commonjsHelpers'], (function (_commonjsHelpers) { 'use strict';\n\n\tfunction _mergeNamespaces(n, m) {\n\t\tm.forEach(function (e) {\n\t\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn Object.freeze(n);\n\t}\n\n\tvar isSameOrAfter$2 = {exports: {}};\n\n\tvar isSameOrAfter$1 = isSameOrAfter$2.exports;\n\n\tvar hasRequiredIsSameOrAfter;\n\n\tfunction requireIsSameOrAfter () {\n\t\tif (hasRequiredIsSameOrAfter) return isSameOrAfter$2.exports;\n\t\thasRequiredIsSameOrAfter = 1;\n\t\t(function (module, exports$1) {\n\t\t\t!function(e,t){module.exports=t();}(isSameOrAfter$1,(function(){return function(e,t){t.prototype.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)};}}));\n\t\t} (isSameOrAfter$2));\n\t\treturn isSameOrAfter$2.exports;\n\t}\n\n\tvar isSameOrAfterExports = requireIsSameOrAfter();\n\tvar defExp = /*@__PURE__*/_commonjsHelpers.getDefaultExportFromCjs(isSameOrAfterExports);\n\n\tvar namedExports = /*#__PURE__*/_mergeNamespaces({\n\t\t__proto__: null,\n\t\tdefault: defExp\n\t}, [isSameOrAfterExports]);\n\n\tconst defaultExports = Object.isFrozen(defExp) ? Object.assign({}, defExp?.default || defExp || { __emptyModule: true }) : defExp;\n\tObject.keys(namedExports || {}).filter((key) => !defaultExports[key]).forEach((key) => defaultExports[key] = namedExports[key]);\n\tObject.defineProperty(defaultExports, \"__\" + \"esModule\", { value: true });\n\tvar isSameOrAfter = Object.isFrozen(defExp) ? Object.freeze(defaultExports) : defaultExports;\n\n\treturn isSameOrAfter;\n\n}));\n",
      "relatedPaths": [
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\dayjs\\plugin\\isSameOrAfter.js"
      ],
      "imports": [
        "_commonjsHelpers.js"
      ],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    },
    {
      "name": "dayjs/plugin/utc",
      "path": "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\dayjs\\plugin\\utc.js",
      "lastModified": 1769402988524,
      "type": "module",
      "originalName": "utc",
      "code": "sap.ui.define(['../../_commonjsHelpers'], (function (_commonjsHelpers) { 'use strict';\n\n\tfunction _mergeNamespaces(n, m) {\n\t\tm.forEach(function (e) {\n\t\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn Object.freeze(n);\n\t}\n\n\tvar utc$2 = {exports: {}};\n\n\tvar utc$1 = utc$2.exports;\n\n\tvar hasRequiredUtc;\n\n\tfunction requireUtc () {\n\t\tif (hasRequiredUtc) return utc$2.exports;\n\t\thasRequiredUtc = 1;\n\t\t(function (module, exports$1) {\n\t\t\t!function(t,i){module.exports=i();}(utc$1,(function(){var t=\"minute\",i=/[+-]\\d\\d(?::?\\d\\d)?/g,e=/([+-]|\\d\\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:true,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:true});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:false})};var r=u.parse;u.parse=function(t){t.utc&&(this.$u=true),this.$utils().u(t.$offset)||(this.$offset=t.$offset),r.call(this,t);};var o=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds();}else o.call(this);};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if(\"string\"==typeof s&&(s=function(t){ void 0===t&&(t=\"\");var s=t.match(i);if(!s)return null;var f=(\"\"+s[0]).match(e)||[\"-\",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:\"+\"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s;if(0===u)return this.utc(f);var r=this.clone();if(f)return r.$offset=u,r.$u=false,r;var o=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();return (r=this.local().add(u+o,t)).$offset=u,r.$x.$localOffset=o,r};var h=u.format;u.format=function(t){var i=t||(this.$u?\"YYYY-MM-DDTHH:mm:ss[Z]\":\"\");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return !!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return \"s\"===t&&this.$offset?n(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)};}}));\n\t\t} (utc$2));\n\t\treturn utc$2.exports;\n\t}\n\n\tvar utcExports = requireUtc();\n\tvar defExp = /*@__PURE__*/_commonjsHelpers.getDefaultExportFromCjs(utcExports);\n\n\tvar namedExports = /*#__PURE__*/_mergeNamespaces({\n\t\t__proto__: null,\n\t\tdefault: defExp\n\t}, [utcExports]);\n\n\tconst defaultExports = Object.isFrozen(defExp) ? Object.assign({}, defExp?.default || defExp || { __emptyModule: true }) : defExp;\n\tObject.keys(namedExports || {}).filter((key) => !defaultExports[key]).forEach((key) => defaultExports[key] = namedExports[key]);\n\tObject.defineProperty(defaultExports, \"__\" + \"esModule\", { value: true });\n\tvar utc = Object.isFrozen(defExp) ? Object.freeze(defaultExports) : defaultExports;\n\n\treturn utc;\n\n}));\n",
      "relatedPaths": [
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\dayjs\\plugin\\utc.js"
      ],
      "imports": [
        "_commonjsHelpers.js"
      ],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    },
    {
      "name": "lodash.isstring",
      "path": "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\lodash.isstring\\index.js",
      "lastModified": 1769402979191,
      "type": "module",
      "originalName": "index",
      "code": "sap.ui.define(['./_commonjsHelpers'], (function (_commonjsHelpers) { 'use strict';\n\n  function _mergeNamespaces(n, m) {\n    m.forEach(function (e) {\n      e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n        if (k !== 'default' && !(k in n)) {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    });\n    return Object.freeze(n);\n  }\n\n  /**\n   * lodash 4.0.1 (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   * Available under MIT license <https://lodash.com/license>\n   */\n\n  var lodash_isstring;\n  var hasRequiredLodash_isstring;\n\n  function requireLodash_isstring () {\n  \tif (hasRequiredLodash_isstring) return lodash_isstring;\n  \thasRequiredLodash_isstring = 1;\n  \t/** `Object#toString` result references. */\n  \tvar stringTag = '[object String]';\n\n  \t/** Used for built-in method references. */\n  \tvar objectProto = Object.prototype;\n\n  \t/**\n  \t * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n  \t * of values.\n  \t */\n  \tvar objectToString = objectProto.toString;\n\n  \t/**\n  \t * Checks if `value` is classified as an `Array` object.\n  \t *\n  \t * @static\n  \t * @memberOf _\n  \t * @type Function\n  \t * @category Lang\n  \t * @param {*} value The value to check.\n  \t * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n  \t * @example\n  \t *\n  \t * _.isArray([1, 2, 3]);\n  \t * // => true\n  \t *\n  \t * _.isArray(document.body.children);\n  \t * // => false\n  \t *\n  \t * _.isArray('abc');\n  \t * // => false\n  \t *\n  \t * _.isArray(_.noop);\n  \t * // => false\n  \t */\n  \tvar isArray = Array.isArray;\n\n  \t/**\n  \t * Checks if `value` is object-like. A value is object-like if it's not `null`\n  \t * and has a `typeof` result of \"object\".\n  \t *\n  \t * @static\n  \t * @memberOf _\n  \t * @category Lang\n  \t * @param {*} value The value to check.\n  \t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n  \t * @example\n  \t *\n  \t * _.isObjectLike({});\n  \t * // => true\n  \t *\n  \t * _.isObjectLike([1, 2, 3]);\n  \t * // => true\n  \t *\n  \t * _.isObjectLike(_.noop);\n  \t * // => false\n  \t *\n  \t * _.isObjectLike(null);\n  \t * // => false\n  \t */\n  \tfunction isObjectLike(value) {\n  \t  return !!value && typeof value == 'object';\n  \t}\n\n  \t/**\n  \t * Checks if `value` is classified as a `String` primitive or object.\n  \t *\n  \t * @static\n  \t * @memberOf _\n  \t * @category Lang\n  \t * @param {*} value The value to check.\n  \t * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n  \t * @example\n  \t *\n  \t * _.isString('abc');\n  \t * // => true\n  \t *\n  \t * _.isString(1);\n  \t * // => false\n  \t */\n  \tfunction isString(value) {\n  \t  return typeof value == 'string' ||\n  \t    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n  \t}\n\n  \tlodash_isstring = isString;\n  \treturn lodash_isstring;\n  }\n\n  var lodash_isstringExports = requireLodash_isstring();\n  var defExp = /*@__PURE__*/_commonjsHelpers.getDefaultExportFromCjs(lodash_isstringExports);\n\n  var namedExports = /*#__PURE__*/_mergeNamespaces({\n    __proto__: null,\n    default: defExp\n  }, [lodash_isstringExports]);\n\n  const defaultExports = Object.isFrozen(defExp) ? Object.assign({}, defExp?.default || defExp || { __emptyModule: true }) : defExp;\n  Object.keys(namedExports || {}).filter((key) => !defaultExports[key]).forEach((key) => defaultExports[key] = namedExports[key]);\n  Object.defineProperty(defaultExports, \"__\" + \"esModule\", { value: true });\n  var index = Object.isFrozen(defExp) ? Object.freeze(defaultExports) : defaultExports;\n\n  return index;\n\n}));\n",
      "relatedPaths": [
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\lodash.isstring\\index.js"
      ],
      "imports": [
        "_commonjsHelpers.js"
      ],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    },
    {
      "name": "validator",
      "path": "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\index.js",
      "lastModified": 1769402981775,
      "type": "module",
      "originalName": "index",
      "code": "sap.ui.define(['./_commonjsHelpers'], (function (_commonjsHelpers) { 'use strict';\n\n  function _mergeNamespaces(n, m) {\n    m.forEach(function (e) {\n      e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n        if (k !== 'default' && !(k in n)) {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    });\n    return Object.freeze(n);\n  }\n\n  var validator = {exports: {}};\n\n  var toDate = {exports: {}};\n\n  var assertString = {exports: {}};\n\n  var hasRequiredAssertString;\n\n  function requireAssertString () {\n  \tif (hasRequiredAssertString) return assertString.exports;\n  \thasRequiredAssertString = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = assertString;\n  \t\tfunction assertString(input) {\n  \t\t  if (input === undefined || input === null) throw new TypeError(\"Expected a string but received a \".concat(input));\n  \t\t  if (input.constructor.name !== 'String') throw new TypeError(\"Expected a string but received a \".concat(input.constructor.name));\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (assertString, assertString.exports));\n  \treturn assertString.exports;\n  }\n\n  var hasRequiredToDate;\n\n  function requireToDate () {\n  \tif (hasRequiredToDate) return toDate.exports;\n  \thasRequiredToDate = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = toDate;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction toDate(date) {\n  \t\t  (0, _assertString.default)(date);\n  \t\t  date = Date.parse(date);\n  \t\t  return !isNaN(date) ? new Date(date) : null;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (toDate, toDate.exports));\n  \treturn toDate.exports;\n  }\n\n  var toFloat = {exports: {}};\n\n  var isFloat = {};\n\n  var nullUndefinedCheck = {exports: {}};\n\n  var hasRequiredNullUndefinedCheck;\n\n  function requireNullUndefinedCheck () {\n  \tif (hasRequiredNullUndefinedCheck) return nullUndefinedCheck.exports;\n  \thasRequiredNullUndefinedCheck = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isNullOrUndefined;\n  \t\tfunction isNullOrUndefined(value) {\n  \t\t  return value === null || value === undefined;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (nullUndefinedCheck, nullUndefinedCheck.exports));\n  \treturn nullUndefinedCheck.exports;\n  }\n\n  var alpha = {};\n\n  var hasRequiredAlpha;\n\n  function requireAlpha () {\n  \tif (hasRequiredAlpha) return alpha;\n  \thasRequiredAlpha = 1;\n\n  \tObject.defineProperty(alpha, \"__esModule\", {\n  \t  value: true\n  \t});\n  \talpha.farsiLocales = alpha.englishLocales = alpha.dotDecimal = alpha.decimal = alpha.commaDecimal = alpha.bengaliLocales = alpha.arabicLocales = alpha.alphanumeric = alpha.alpha = void 0;\n  \tvar alpha$1 = alpha.alpha = {\n  \t  'en-US': /^[A-Z]+$/i,\n  \t  'az-AZ': /^[A-VXYZÇƏĞİıÖŞÜ]+$/i,\n  \t  'bg-BG': /^[А-Я]+$/i,\n  \t  'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,\n  \t  'da-DK': /^[A-ZÆØÅ]+$/i,\n  \t  'de-DE': /^[A-ZÄÖÜß]+$/i,\n  \t  'el-GR': /^[Α-ώ]+$/i,\n  \t  'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,\n  \t  'fa-IR': /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i,\n  \t  'fi-FI': /^[A-ZÅÄÖ]+$/i,\n  \t  'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,\n  \t  'it-IT': /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,\n  \t  'ja-JP': /^[ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,\n  \t  'nb-NO': /^[A-ZÆØÅ]+$/i,\n  \t  'nl-NL': /^[A-ZÁÉËÏÓÖÜÚ]+$/i,\n  \t  'nn-NO': /^[A-ZÆØÅ]+$/i,\n  \t  'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,\n  \t  'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,\n  \t  'pt-PT': /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,\n  \t  'ru-RU': /^[А-ЯЁ]+$/i,\n  \t  'kk-KZ': /^[А-ЯЁ\\u04D8\\u04B0\\u0406\\u04A2\\u0492\\u04AE\\u049A\\u04E8\\u04BA]+$/i,\n  \t  'sl-SI': /^[A-ZČĆĐŠŽ]+$/i,\n  \t  'sk-SK': /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,\n  \t  'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,\n  \t  'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,\n  \t  'sv-SE': /^[A-ZÅÄÖ]+$/i,\n  \t  'th-TH': /^[ก-๐\\s]+$/i,\n  \t  'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,\n  \t  'uk-UA': /^[А-ЩЬЮЯЄIЇҐі]+$/i,\n  \t  'vi-VN': /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,\n  \t  'ko-KR': /^[ㄱ-ㅎㅏ-ㅣ가-힣]*$/,\n  \t  'ku-IQ': /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,\n  \t  ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,\n  \t  he: /^[א-ת]+$/,\n  \t  fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i,\n  \t  bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,\n  \t  eo: /^[ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,\n  \t  'hi-IN': /^[\\u0900-\\u0961]+[\\u0972-\\u097F]*$/i,\n  \t  'si-LK': /^[\\u0D80-\\u0DFF]+$/,\n  \t  'ta-IN': /^[\\u0B80-\\u0BFF]+$/i,\n  \t  'te-IN': /^[\\u0C00-\\u0C7F]+$/i,\n  \t  'kn-IN': /^[\\u0C80-\\u0CFF]+$/i,\n  \t  'ml-IN': /^[\\u0D00-\\u0D7F]+$/i,\n  \t  'gu-IN': /^[\\u0A80-\\u0AFF]+$/i,\n  \t  'pa-IN': /^[\\u0A00-\\u0A7F]+$/i,\n  \t  'or-IN': /^[\\u0B00-\\u0B7F]+$/i\n  \t};\n  \tvar alphanumeric = alpha.alphanumeric = {\n  \t  'en-US': /^[0-9A-Z]+$/i,\n  \t  'az-AZ': /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i,\n  \t  'bg-BG': /^[0-9А-Я]+$/i,\n  \t  'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,\n  \t  'da-DK': /^[0-9A-ZÆØÅ]+$/i,\n  \t  'de-DE': /^[0-9A-ZÄÖÜß]+$/i,\n  \t  'el-GR': /^[0-9Α-ω]+$/i,\n  \t  'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,\n  \t  'fi-FI': /^[0-9A-ZÅÄÖ]+$/i,\n  \t  'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,\n  \t  'it-IT': /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,\n  \t  'ja-JP': /^[0-9０-９ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,\n  \t  'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,\n  \t  'nb-NO': /^[0-9A-ZÆØÅ]+$/i,\n  \t  'nl-NL': /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,\n  \t  'nn-NO': /^[0-9A-ZÆØÅ]+$/i,\n  \t  'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,\n  \t  'pt-PT': /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,\n  \t  'ru-RU': /^[0-9А-ЯЁ]+$/i,\n  \t  'kk-KZ': /^[0-9А-ЯЁ\\u04D8\\u04B0\\u0406\\u04A2\\u0492\\u04AE\\u049A\\u04E8\\u04BA]+$/i,\n  \t  'sl-SI': /^[0-9A-ZČĆĐŠŽ]+$/i,\n  \t  'sk-SK': /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,\n  \t  'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,\n  \t  'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,\n  \t  'sv-SE': /^[0-9A-ZÅÄÖ]+$/i,\n  \t  'th-TH': /^[ก-๙\\s]+$/i,\n  \t  'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,\n  \t  'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,\n  \t  'ko-KR': /^[0-9ㄱ-ㅎㅏ-ㅣ가-힣]*$/,\n  \t  'ku-IQ': /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,\n  \t  'vi-VN': /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,\n  \t  ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,\n  \t  he: /^[0-9א-ת]+$/,\n  \t  fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i,\n  \t  bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣ০১২৩৪৫৬৭৮৯ৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,\n  \t  eo: /^[0-9ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,\n  \t  'hi-IN': /^[\\u0900-\\u0963]+[\\u0966-\\u097F]*$/i,\n  \t  'si-LK': /^[0-9\\u0D80-\\u0DFF]+$/,\n  \t  'ta-IN': /^[0-9\\u0B80-\\u0BFF.]+$/i,\n  \t  'te-IN': /^[0-9\\u0C00-\\u0C7F.]+$/i,\n  \t  'kn-IN': /^[0-9\\u0C80-\\u0CFF.]+$/i,\n  \t  'ml-IN': /^[0-9\\u0D00-\\u0D7F.]+$/i,\n  \t  'gu-IN': /^[0-9\\u0A80-\\u0AFF.]+$/i,\n  \t  'pa-IN': /^[0-9\\u0A00-\\u0A7F.]+$/i,\n  \t  'or-IN': /^[0-9\\u0B00-\\u0B7F.]+$/i\n  \t};\n  \tvar decimal = alpha.decimal = {\n  \t  'en-US': '.',\n  \t  ar: '٫'\n  \t};\n  \tvar englishLocales = alpha.englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];\n  \tfor (var locale, i = 0; i < englishLocales.length; i++) {\n  \t  locale = \"en-\".concat(englishLocales[i]);\n  \t  alpha$1[locale] = alpha$1['en-US'];\n  \t  alphanumeric[locale] = alphanumeric['en-US'];\n  \t  decimal[locale] = decimal['en-US'];\n  \t}\n\n  \t// Source: http://www.localeplanet.com/java/\n  \tvar arabicLocales = alpha.arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];\n  \tfor (var _locale, _i = 0; _i < arabicLocales.length; _i++) {\n  \t  _locale = \"ar-\".concat(arabicLocales[_i]);\n  \t  alpha$1[_locale] = alpha$1.ar;\n  \t  alphanumeric[_locale] = alphanumeric.ar;\n  \t  decimal[_locale] = decimal.ar;\n  \t}\n  \tvar farsiLocales = alpha.farsiLocales = ['IR', 'AF'];\n  \tfor (var _locale2, _i2 = 0; _i2 < farsiLocales.length; _i2++) {\n  \t  _locale2 = \"fa-\".concat(farsiLocales[_i2]);\n  \t  alphanumeric[_locale2] = alphanumeric.fa;\n  \t  decimal[_locale2] = decimal.ar;\n  \t}\n  \tvar bengaliLocales = alpha.bengaliLocales = ['BD', 'IN'];\n  \tfor (var _locale3, _i3 = 0; _i3 < bengaliLocales.length; _i3++) {\n  \t  _locale3 = \"bn-\".concat(bengaliLocales[_i3]);\n  \t  alpha$1[_locale3] = alpha$1.bn;\n  \t  alphanumeric[_locale3] = alphanumeric.bn;\n  \t  decimal[_locale3] = decimal['en-US'];\n  \t}\n\n  \t// Source: https://en.wikipedia.org/wiki/Decimal_mark\n  \tvar dotDecimal = alpha.dotDecimal = ['ar-EG', 'ar-LB', 'ar-LY'];\n  \tvar commaDecimal = alpha.commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-ZM', 'eo', 'es-ES', 'fr-CA', 'fr-FR', 'gu-IN', 'hi-IN', 'hu-HU', 'id-ID', 'it-IT', 'kk-KZ', 'kn-IN', 'ku-IQ', 'ml-IN', 'nb-NO', 'nl-NL', 'nn-NO', 'or-IN', 'pa-IN', 'pl-PL', 'pt-PT', 'ru-RU', 'si-LK', 'sl-SI', 'sr-RS', 'sr-RS@latin', 'sv-SE', 'ta-IN', 'te-IN', 'tr-TR', 'uk-UA', 'vi-VN'];\n  \tfor (var _i4 = 0; _i4 < dotDecimal.length; _i4++) {\n  \t  decimal[dotDecimal[_i4]] = decimal['en-US'];\n  \t}\n  \tfor (var _i5 = 0; _i5 < commaDecimal.length; _i5++) {\n  \t  decimal[commaDecimal[_i5]] = ',';\n  \t}\n  \talpha$1['fr-CA'] = alpha$1['fr-FR'];\n  \talphanumeric['fr-CA'] = alphanumeric['fr-FR'];\n  \talpha$1['pt-BR'] = alpha$1['pt-PT'];\n  \talphanumeric['pt-BR'] = alphanumeric['pt-PT'];\n  \tdecimal['pt-BR'] = decimal['pt-PT'];\n\n  \t// see #862\n  \talpha$1['pl-Pl'] = alpha$1['pl-PL'];\n  \talphanumeric['pl-Pl'] = alphanumeric['pl-PL'];\n  \tdecimal['pl-Pl'] = decimal['pl-PL'];\n\n  \t// see #1455\n  \talpha$1['fa-AF'] = alpha$1.fa;\n  \treturn alpha;\n  }\n\n  var hasRequiredIsFloat;\n\n  function requireIsFloat () {\n  \tif (hasRequiredIsFloat) return isFloat;\n  \thasRequiredIsFloat = 1;\n\n  \tObject.defineProperty(isFloat, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisFloat.default = isFloat$1;\n  \tisFloat.locales = void 0;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tvar _nullUndefinedCheck = _interopRequireDefault(requireNullUndefinedCheck());\n  \tvar _alpha = requireAlpha();\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \tfunction isFloat$1(str, options) {\n  \t  (0, _assertString.default)(str);\n  \t  options = options || {};\n  \t  var float = new RegExp(\"^(?:[-+])?(?:[0-9]+)?(?:\\\\\".concat(options.locale ? _alpha.decimal[options.locale] : '.', \"[0-9]*)?(?:[eE][\\\\+\\\\-]?(?:[0-9]+))?$\"));\n  \t  if (str === '' || str === '.' || str === ',' || str === '-' || str === '+') {\n  \t    return false;\n  \t  }\n  \t  var value = parseFloat(str.replace(',', '.'));\n  \t  return float.test(str) && (!options.hasOwnProperty('min') || (0, _nullUndefinedCheck.default)(options.min) || value >= options.min) && (!options.hasOwnProperty('max') || (0, _nullUndefinedCheck.default)(options.max) || value <= options.max) && (!options.hasOwnProperty('lt') || (0, _nullUndefinedCheck.default)(options.lt) || value < options.lt) && (!options.hasOwnProperty('gt') || (0, _nullUndefinedCheck.default)(options.gt) || value > options.gt);\n  \t}\n  \tisFloat.locales = Object.keys(_alpha.decimal);\n  \treturn isFloat;\n  }\n\n  var hasRequiredToFloat;\n\n  function requireToFloat () {\n  \tif (hasRequiredToFloat) return toFloat.exports;\n  \thasRequiredToFloat = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = toFloat;\n  \t\tvar _isFloat = _interopRequireDefault(requireIsFloat());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction toFloat(str) {\n  \t\t  if (!(0, _isFloat.default)(str)) return NaN;\n  \t\t  return parseFloat(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (toFloat, toFloat.exports));\n  \treturn toFloat.exports;\n  }\n\n  var toInt = {exports: {}};\n\n  var hasRequiredToInt;\n\n  function requireToInt () {\n  \tif (hasRequiredToInt) return toInt.exports;\n  \thasRequiredToInt = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = toInt;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction toInt(str, radix) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return parseInt(str, radix || 10);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (toInt, toInt.exports));\n  \treturn toInt.exports;\n  }\n\n  var toBoolean = {exports: {}};\n\n  var hasRequiredToBoolean;\n\n  function requireToBoolean () {\n  \tif (hasRequiredToBoolean) return toBoolean.exports;\n  \thasRequiredToBoolean = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = toBoolean;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction toBoolean(str, strict) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (strict) {\n  \t\t    return str === '1' || /^true$/i.test(str);\n  \t\t  }\n  \t\t  return str !== '0' && !/^false$/i.test(str) && str !== '';\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (toBoolean, toBoolean.exports));\n  \treturn toBoolean.exports;\n  }\n\n  var equals = {exports: {}};\n\n  var hasRequiredEquals;\n\n  function requireEquals () {\n  \tif (hasRequiredEquals) return equals.exports;\n  \thasRequiredEquals = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = equals;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction equals(str, comparison) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return str === comparison;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (equals, equals.exports));\n  \treturn equals.exports;\n  }\n\n  var contains = {exports: {}};\n\n  var toString$1 = {exports: {}};\n\n  var hasRequiredToString;\n\n  function requireToString () {\n  \tif (hasRequiredToString) return toString$1.exports;\n  \thasRequiredToString = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = toString;\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \t\tfunction toString(input) {\n  \t\t  if (_typeof(input) === 'object' && input !== null) {\n  \t\t    if (typeof input.toString === 'function') {\n  \t\t      input = input.toString();\n  \t\t    } else {\n  \t\t      input = '[object Object]';\n  \t\t    }\n  \t\t  } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {\n  \t\t    input = '';\n  \t\t  }\n  \t\t  return String(input);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (toString$1, toString$1.exports));\n  \treturn toString$1.exports;\n  }\n\n  var merge = {exports: {}};\n\n  var hasRequiredMerge;\n\n  function requireMerge () {\n  \tif (hasRequiredMerge) return merge.exports;\n  \thasRequiredMerge = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = merge;\n  \t\tfunction merge() {\n  \t\t  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  \t\t  var defaults = arguments.length > 1 ? arguments[1] : undefined;\n  \t\t  for (var key in defaults) {\n  \t\t    if (typeof obj[key] === 'undefined') {\n  \t\t      obj[key] = defaults[key];\n  \t\t    }\n  \t\t  }\n  \t\t  return obj;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (merge, merge.exports));\n  \treturn merge.exports;\n  }\n\n  var hasRequiredContains;\n\n  function requireContains () {\n  \tif (hasRequiredContains) return contains.exports;\n  \thasRequiredContains = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = contains;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _toString = _interopRequireDefault(requireToString());\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar defaultContainsOptions = {\n  \t\t  ignoreCase: false,\n  \t\t  minOccurrences: 1\n  \t\t};\n  \t\tfunction contains(str, elem, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = (0, _merge.default)(options, defaultContainsOptions);\n  \t\t  if (options.ignoreCase) {\n  \t\t    return str.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options.minOccurrences;\n  \t\t  }\n  \t\t  return str.split((0, _toString.default)(elem)).length > options.minOccurrences;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (contains, contains.exports));\n  \treturn contains.exports;\n  }\n\n  var matches = {exports: {}};\n\n  var hasRequiredMatches;\n\n  function requireMatches () {\n  \tif (hasRequiredMatches) return matches.exports;\n  \thasRequiredMatches = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = matches;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction matches(str, pattern, modifiers) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {\n  \t\t    pattern = new RegExp(pattern, modifiers);\n  \t\t  }\n  \t\t  return !!str.match(pattern);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (matches, matches.exports));\n  \treturn matches.exports;\n  }\n\n  var isEmail = {exports: {}};\n\n  var checkHost = {exports: {}};\n\n  var hasRequiredCheckHost;\n\n  function requireCheckHost () {\n  \tif (hasRequiredCheckHost) return checkHost.exports;\n  \thasRequiredCheckHost = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = checkHost;\n  \t\tfunction isRegExp(obj) {\n  \t\t  return Object.prototype.toString.call(obj) === '[object RegExp]';\n  \t\t}\n  \t\tfunction checkHost(host, matches) {\n  \t\t  for (var i = 0; i < matches.length; i++) {\n  \t\t    var match = matches[i];\n  \t\t    if (host === match || isRegExp(match) && match.test(host)) {\n  \t\t      return true;\n  \t\t    }\n  \t\t  }\n  \t\t  return false;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (checkHost, checkHost.exports));\n  \treturn checkHost.exports;\n  }\n\n  var isByteLength = {exports: {}};\n\n  var hasRequiredIsByteLength;\n\n  function requireIsByteLength () {\n  \tif (hasRequiredIsByteLength) return isByteLength.exports;\n  \thasRequiredIsByteLength = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isByteLength;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \t\t/* eslint-disable prefer-rest-params */\n  \t\tfunction isByteLength(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var min;\n  \t\t  var max;\n  \t\t  if (_typeof(options) === 'object') {\n  \t\t    min = options.min || 0;\n  \t\t    max = options.max;\n  \t\t  } else {\n  \t\t    // backwards compatibility: isByteLength(str, min [, max])\n  \t\t    min = arguments[1];\n  \t\t    max = arguments[2];\n  \t\t  }\n  \t\t  var len = encodeURI(str).split(/%..|./).length - 1;\n  \t\t  return len >= min && (typeof max === 'undefined' || len <= max);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isByteLength, isByteLength.exports));\n  \treturn isByteLength.exports;\n  }\n\n  var isFQDN = {exports: {}};\n\n  var hasRequiredIsFQDN;\n\n  function requireIsFQDN () {\n  \tif (hasRequiredIsFQDN) return isFQDN.exports;\n  \thasRequiredIsFQDN = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isFQDN;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar default_fqdn_options = {\n  \t\t  require_tld: true,\n  \t\t  allow_underscores: false,\n  \t\t  allow_trailing_dot: false,\n  \t\t  allow_numeric_tld: false,\n  \t\t  allow_wildcard: false,\n  \t\t  ignore_max_length: false\n  \t\t};\n  \t\tfunction isFQDN(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = (0, _merge.default)(options, default_fqdn_options);\n\n  \t\t  /* Remove the optional trailing dot before checking validity */\n  \t\t  if (options.allow_trailing_dot && str[str.length - 1] === '.') {\n  \t\t    str = str.substring(0, str.length - 1);\n  \t\t  }\n\n  \t\t  /* Remove the optional wildcard before checking validity */\n  \t\t  if (options.allow_wildcard === true && str.indexOf('*.') === 0) {\n  \t\t    str = str.substring(2);\n  \t\t  }\n  \t\t  var parts = str.split('.');\n  \t\t  var tld = parts[parts.length - 1];\n  \t\t  if (options.require_tld) {\n  \t\t    // disallow fqdns without tld\n  \t\t    if (parts.length < 2) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (!options.allow_numeric_tld && !/^([a-z\\u00A1-\\u00A8\\u00AA-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {\n  \t\t      return false;\n  \t\t    }\n\n  \t\t    // disallow spaces\n  \t\t    if (/\\s/.test(tld)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n\n  \t\t  // reject numeric TLDs\n  \t\t  if (!options.allow_numeric_tld && /^\\d+$/.test(tld)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return parts.every(function (part) {\n  \t\t    if (part.length > 63 && !options.ignore_max_length) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (!/^[a-z_\\u00a1-\\uffff0-9-]+$/i.test(part)) {\n  \t\t      return false;\n  \t\t    }\n\n  \t\t    // disallow full-width chars\n  \t\t    if (/[\\uff01-\\uff5e]/.test(part)) {\n  \t\t      return false;\n  \t\t    }\n\n  \t\t    // disallow parts starting or ending with hyphen\n  \t\t    if (/^-|-$/.test(part)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (!options.allow_underscores && /_/.test(part)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    return true;\n  \t\t  });\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isFQDN, isFQDN.exports));\n  \treturn isFQDN.exports;\n  }\n\n  var isIP = {exports: {}};\n\n  var hasRequiredIsIP;\n\n  function requireIsIP () {\n  \tif (hasRequiredIsIP) return isIP.exports;\n  \thasRequiredIsIP = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isIP;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \t\t/**\n  \t\t11.3.  Examples\n\n  \t\t   The following addresses\n\n  \t\t             fe80::1234 (on the 1st link of the node)\n  \t\t             ff02::5678 (on the 5th link of the node)\n  \t\t             ff08::9abc (on the 10th organization of the node)\n\n  \t\t   would be represented as follows:\n\n  \t\t             fe80::1234%1\n  \t\t             ff02::5678%5\n  \t\t             ff08::9abc%10\n\n  \t\t   (Here we assume a natural translation from a zone index to the\n  \t\t   <zone_id> part, where the Nth zone of any scope is translated into\n  \t\t   \"N\".)\n\n  \t\t   If we use interface names as <zone_id>, those addresses could also be\n  \t\t   represented as follows:\n\n  \t\t            fe80::1234%ne0\n  \t\t            ff02::5678%pvc1.3\n  \t\t            ff08::9abc%interface10\n\n  \t\t   where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\n  \t\t   to the 5th link, and \"interface10\" belongs to the 10th organization.\n  \t\t * * */\n  \t\tvar IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\n  \t\tvar IPv4AddressFormat = \"(\".concat(IPv4SegmentFormat, \"[.]){3}\").concat(IPv4SegmentFormat);\n  \t\tvar IPv4AddressRegExp = new RegExp(\"^\".concat(IPv4AddressFormat, \"$\"));\n  \t\tvar IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';\n  \t\tvar IPv6AddressRegExp = new RegExp('^(' + \"(?:\".concat(IPv6SegmentFormat, \":){7}(?:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){6}(?:\").concat(IPv4AddressFormat, \"|:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){5}(?::\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,2}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){4}(?:(:\").concat(IPv6SegmentFormat, \"){0,1}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,3}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){3}(?:(:\").concat(IPv6SegmentFormat, \"){0,2}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,4}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){2}(?:(:\").concat(IPv6SegmentFormat, \"){0,3}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,5}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){1}(?:(:\").concat(IPv6SegmentFormat, \"){0,4}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,6}|:)|\") + \"(?::((?::\".concat(IPv6SegmentFormat, \"){0,5}:\").concat(IPv4AddressFormat, \"|(?::\").concat(IPv6SegmentFormat, \"){1,7}|:))\") + ')(%[0-9a-zA-Z.]{1,})?$');\n  \t\tfunction isIP(ipAddress) {\n  \t\t  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  \t\t  (0, _assertString.default)(ipAddress);\n\n  \t\t  // accessing 'arguments' for backwards compatibility: isIP(ipAddress [, version])\n  \t\t  // eslint-disable-next-line prefer-rest-params\n  \t\t  var version = (_typeof(options) === 'object' ? options.version : arguments[1]) || '';\n  \t\t  if (!version) {\n  \t\t    return isIP(ipAddress, {\n  \t\t      version: 4\n  \t\t    }) || isIP(ipAddress, {\n  \t\t      version: 6\n  \t\t    });\n  \t\t  }\n  \t\t  if (version.toString() === '4') {\n  \t\t    return IPv4AddressRegExp.test(ipAddress);\n  \t\t  }\n  \t\t  if (version.toString() === '6') {\n  \t\t    return IPv6AddressRegExp.test(ipAddress);\n  \t\t  }\n  \t\t  return false;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isIP, isIP.exports));\n  \treturn isIP.exports;\n  }\n\n  var hasRequiredIsEmail;\n\n  function requireIsEmail () {\n  \tif (hasRequiredIsEmail) return isEmail.exports;\n  \thasRequiredIsEmail = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isEmail;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _checkHost = _interopRequireDefault(requireCheckHost());\n  \t\tvar _isByteLength = _interopRequireDefault(requireIsByteLength());\n  \t\tvar _isFQDN = _interopRequireDefault(requireIsFQDN());\n  \t\tvar _isIP = _interopRequireDefault(requireIsIP());\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar default_email_options = {\n  \t\t  allow_display_name: false,\n  \t\t  allow_underscores: false,\n  \t\t  require_display_name: false,\n  \t\t  allow_utf8_local_part: true,\n  \t\t  require_tld: true,\n  \t\t  blacklisted_chars: '',\n  \t\t  ignore_max_length: false,\n  \t\t  host_blacklist: [],\n  \t\t  host_whitelist: []\n  \t\t};\n\n  \t\t/* eslint-disable max-len */\n  \t\t/* eslint-disable no-control-regex */\n  \t\tvar splitNameAddress = /^([^\\x00-\\x1F\\x7F-\\x9F\\cX]+)</i;\n  \t\tvar emailUserPart = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]+$/i;\n  \t\tvar gmailUserPart = /^[a-z\\d]+$/;\n  \t\tvar quotedEmailUser = /^([\\s\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f\\x21\\x23-\\x5b\\x5d-\\x7e]|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]))*$/i;\n  \t\tvar emailUserUtf8Part = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\u00A1-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+$/i;\n  \t\tvar quotedEmailUserUtf8 = /^([\\s\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f\\x21\\x23-\\x5b\\x5d-\\x7e\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))*$/i;\n  \t\tvar defaultMaxEmailLength = 254;\n  \t\t/* eslint-enable max-len */\n  \t\t/* eslint-enable no-control-regex */\n\n  \t\t/**\n  \t\t * Validate display name according to the RFC2822: https://tools.ietf.org/html/rfc2822#appendix-A.1.2\n  \t\t * @param {String} display_name\n  \t\t */\n  \t\tfunction validateDisplayName(display_name) {\n  \t\t  var display_name_without_quotes = display_name.replace(/^\"(.+)\"$/, '$1');\n  \t\t  // display name with only spaces is not valid\n  \t\t  if (!display_name_without_quotes.trim()) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // check whether display name contains illegal character\n  \t\t  var contains_illegal = /[\\.\";<>]/.test(display_name_without_quotes);\n  \t\t  if (contains_illegal) {\n  \t\t    // if contains illegal characters,\n  \t\t    // must to be enclosed in double-quotes, otherwise it's not a valid display name\n  \t\t    if (display_name_without_quotes === display_name) {\n  \t\t      return false;\n  \t\t    }\n\n  \t\t    // the quotes in display name must start with character symbol \\\n  \t\t    var all_start_with_back_slash = display_name_without_quotes.split('\"').length === display_name_without_quotes.split('\\\\\"').length;\n  \t\t    if (!all_start_with_back_slash) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n  \t\tfunction isEmail(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = (0, _merge.default)(options, default_email_options);\n  \t\t  if (options.require_display_name || options.allow_display_name) {\n  \t\t    var display_email = str.match(splitNameAddress);\n  \t\t    if (display_email) {\n  \t\t      var display_name = display_email[1];\n\n  \t\t      // Remove display name and angle brackets to get email address\n  \t\t      // Can be done in the regex but will introduce a ReDOS (See  #1597 for more info)\n  \t\t      str = str.replace(display_name, '').replace(/(^<|>$)/g, '');\n\n  \t\t      // sometimes need to trim the last space to get the display name\n  \t\t      // because there may be a space between display name and email address\n  \t\t      // eg. myname <address@gmail.com>\n  \t\t      // the display name is `myname` instead of `myname `, so need to trim the last space\n  \t\t      if (display_name.endsWith(' ')) {\n  \t\t        display_name = display_name.slice(0, -1);\n  \t\t      }\n  \t\t      if (!validateDisplayName(display_name)) {\n  \t\t        return false;\n  \t\t      }\n  \t\t    } else if (options.require_display_name) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var parts = str.split('@');\n  \t\t  var domain = parts.pop();\n  \t\t  var lower_domain = domain.toLowerCase();\n  \t\t  if (options.host_blacklist.length > 0 && (0, _checkHost.default)(lower_domain, options.host_blacklist)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  if (options.host_whitelist.length > 0 && !(0, _checkHost.default)(lower_domain, options.host_whitelist)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var user = parts.join('@');\n  \t\t  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {\n  \t\t    /*\n  \t\t    Previously we removed dots for gmail addresses before validating.\n  \t\t    This was removed because it allows `multiple..dots@gmail.com`\n  \t\t    to be reported as valid, but it is not.\n  \t\t    Gmail only normalizes single dots, removing them from here is pointless,\n  \t\t    should be done in normalizeEmail\n  \t\t    */\n  \t\t    user = user.toLowerCase();\n\n  \t\t    // Removing sub-address from username before gmail validation\n  \t\t    var username = user.split('+')[0];\n\n  \t\t    // Dots are not included in gmail length restriction\n  \t\t    if (!(0, _isByteLength.default)(username.replace(/\\./g, ''), {\n  \t\t      min: 6,\n  \t\t      max: 30\n  \t\t    })) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    var _user_parts = username.split('.');\n  \t\t    for (var i = 0; i < _user_parts.length; i++) {\n  \t\t      if (!gmailUserPart.test(_user_parts[i])) {\n  \t\t        return false;\n  \t\t      }\n  \t\t    }\n  \t\t  }\n  \t\t  if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {\n  \t\t    max: 64\n  \t\t  }) || !(0, _isByteLength.default)(domain, {\n  \t\t    max: 254\n  \t\t  }))) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  if (!(0, _isFQDN.default)(domain, {\n  \t\t    require_tld: options.require_tld,\n  \t\t    ignore_max_length: options.ignore_max_length,\n  \t\t    allow_underscores: options.allow_underscores\n  \t\t  })) {\n  \t\t    if (!options.allow_ip_domain) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (!(0, _isIP.default)(domain)) {\n  \t\t      if (!domain.startsWith('[') || !domain.endsWith(']')) {\n  \t\t        return false;\n  \t\t      }\n  \t\t      var noBracketdomain = domain.slice(1, -1);\n  \t\t      if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {\n  \t\t        return false;\n  \t\t      }\n  \t\t    }\n  \t\t  }\n  \t\t  if (options.blacklisted_chars) {\n  \t\t    if (user.search(new RegExp(\"[\".concat(options.blacklisted_chars, \"]+\"), 'g')) !== -1) return false;\n  \t\t  }\n  \t\t  if (user[0] === '\"' && user[user.length - 1] === '\"') {\n  \t\t    user = user.slice(1, user.length - 1);\n  \t\t    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);\n  \t\t  }\n  \t\t  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;\n  \t\t  var user_parts = user.split('.');\n  \t\t  for (var _i = 0; _i < user_parts.length; _i++) {\n  \t\t    if (!pattern.test(user_parts[_i])) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isEmail, isEmail.exports));\n  \treturn isEmail.exports;\n  }\n\n  var isURL = {exports: {}};\n\n  var includesString = {exports: {}};\n\n  var hasRequiredIncludesString;\n\n  function requireIncludesString () {\n  \tif (hasRequiredIncludesString) return includesString.exports;\n  \thasRequiredIncludesString = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = void 0;\n  \t\tvar includes = function includes(str, val) {\n  \t\t  return str.indexOf(val) !== -1;\n  \t\t};\n  \t\texports$1.default = includes;\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (includesString, includesString.exports));\n  \treturn includesString.exports;\n  }\n\n  var hasRequiredIsURL;\n\n  function requireIsURL () {\n  \tif (hasRequiredIsURL) return isURL.exports;\n  \thasRequiredIsURL = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isURL;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _checkHost = _interopRequireDefault(requireCheckHost());\n  \t\tvar _includesString = _interopRequireDefault(requireIncludesString());\n  \t\tvar _isFQDN = _interopRequireDefault(requireIsFQDN());\n  \t\tvar _isIP = _interopRequireDefault(requireIsIP());\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\n  \t\tfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n  \t\tfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\n  \t\tfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n  \t\tfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\n  \t\tfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n  \t\t/*\n  \t\toptions for isURL method\n\n  \t\tprotocols - valid protocols can be modified with this option.\n  \t\trequire_tld - If set to false isURL will not check if the URL's host includes a top-level domain.\n  \t\trequire_protocol - if set to true isURL will return false if protocol is not present in the URL.\n  \t\trequire_host - if set to false isURL will not check if host is present in the URL.\n  \t\trequire_port - if set to true isURL will check if port is present in the URL.\n  \t\trequire_valid_protocol - isURL will check if the URL's protocol is present in the protocols option.\n  \t\tallow_underscores - if set to true, the validator will allow underscores in the URL.\n  \t\thost_whitelist - if set to an array of strings or regexp, and the domain matches none of the strings\n  \t\t                 defined in it, the validation fails.\n  \t\thost_blacklist - if set to an array of strings or regexp, and the domain matches any of the strings\n  \t\t                 defined in it, the validation fails.\n  \t\tallow_trailing_dot - if set to true, the validator will allow the domain to end with\n  \t\t                     a `.` character.\n  \t\tallow_protocol_relative_urls - if set to true protocol relative URLs will be allowed.\n  \t\tallow_fragments - if set to false isURL will return false if fragments are present.\n  \t\tallow_query_components - if set to false isURL will return false if query components are present.\n  \t\tdisallow_auth - if set to true, the validator will fail if the URL contains an authentication\n  \t\t                component, e.g. `http://username:password@example.com`\n  \t\tvalidate_length - if set to false isURL will skip string length validation. `max_allowed_length`\n  \t\t                  will be ignored if this is set as `false`.\n  \t\tmax_allowed_length - if set, isURL will not allow URLs longer than the specified value (default is\n  \t\t                     2084 that IE maximum URL length).\n\n  \t\t*/\n\n  \t\tvar default_url_options = {\n  \t\t  protocols: ['http', 'https', 'ftp'],\n  \t\t  require_tld: true,\n  \t\t  require_protocol: false,\n  \t\t  require_host: true,\n  \t\t  require_port: false,\n  \t\t  require_valid_protocol: true,\n  \t\t  allow_underscores: false,\n  \t\t  allow_trailing_dot: false,\n  \t\t  allow_protocol_relative_urls: false,\n  \t\t  allow_fragments: true,\n  \t\t  allow_query_components: true,\n  \t\t  validate_length: true,\n  \t\t  max_allowed_length: 2084\n  \t\t};\n  \t\tvar wrapped_ipv6 = /^\\[([^\\]]+)\\](?::([0-9]+))?$/;\n  \t\tfunction isURL(url, options) {\n  \t\t  (0, _assertString.default)(url);\n  \t\t  if (!url || /[\\s<>]/.test(url)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  if (url.indexOf('mailto:') === 0) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  options = (0, _merge.default)(options, default_url_options);\n  \t\t  if (options.validate_length && url.length > options.max_allowed_length) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  if (!options.allow_fragments && (0, _includesString.default)(url, '#')) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  if (!options.allow_query_components && ((0, _includesString.default)(url, '?') || (0, _includesString.default)(url, '&'))) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var protocol, auth, host, hostname, port, port_str, split, ipv6;\n  \t\t  split = url.split('#');\n  \t\t  url = split.shift();\n  \t\t  split = url.split('?');\n  \t\t  url = split.shift();\n\n  \t\t  // Replaced the 'split(\"://\")' logic with a regex to match the protocol.\n  \t\t  // This correctly identifies schemes like `javascript:` which don't use `//`.\n  \t\t  // However, we need to be careful not to confuse authentication credentials (user:password@host)\n  \t\t  // with protocols. A colon before an @ symbol might be part of auth, not a protocol separator.\n  \t\t  var protocol_match = url.match(/^([a-z][a-z0-9+\\-.]*):/i);\n  \t\t  var had_explicit_protocol = false;\n  \t\t  var cleanUpProtocol = function cleanUpProtocol(potential_protocol) {\n  \t\t    had_explicit_protocol = true;\n  \t\t    protocol = potential_protocol.toLowerCase();\n  \t\t    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {\n  \t\t      // The identified protocol is not in the allowed list.\n  \t\t      return false;\n  \t\t    }\n\n  \t\t    // Remove the protocol from the URL string.\n  \t\t    return url.substring(protocol_match[0].length);\n  \t\t  };\n  \t\t  if (protocol_match) {\n  \t\t    var potential_protocol = protocol_match[1];\n  \t\t    var after_colon = url.substring(protocol_match[0].length);\n\n  \t\t    // Check if what follows looks like authentication credentials (user:password@host)\n  \t\t    // rather than a protocol. This happens when:\n  \t\t    // 1. There's no `//` after the colon (protocols like `http://` have this)\n  \t\t    // 2. There's an `@` symbol before any `/`\n  \t\t    // 3. The part before `@` contains only valid auth characters (alphanumeric, -, _, ., %, :)\n  \t\t    var starts_with_slashes = after_colon.slice(0, 2) === '//';\n  \t\t    if (!starts_with_slashes) {\n  \t\t      var first_slash_position = after_colon.indexOf('/');\n  \t\t      var before_slash = first_slash_position === -1 ? after_colon : after_colon.substring(0, first_slash_position);\n  \t\t      var at_position = before_slash.indexOf('@');\n  \t\t      if (at_position !== -1) {\n  \t\t        var before_at = before_slash.substring(0, at_position);\n  \t\t        var valid_auth_regex = /^[a-zA-Z0-9\\-_.%:]*$/;\n  \t\t        var is_valid_auth = valid_auth_regex.test(before_at);\n\n  \t\t        // Check if this contains URL-encoded content that could be malicious\n  \t\t        // For example: javascript:%61%6c%65%72%74%28%31%29@example.com\n  \t\t        // The encoded part decodes to: alert(1)\n  \t\t        var has_encoded_content = /%[0-9a-fA-F]{2}/.test(before_at);\n  \t\t        if (is_valid_auth && !has_encoded_content) {\n  \t\t          // This looks like authentication (e.g., user:password@host), not a protocol\n  \t\t          if (options.require_protocol) {\n  \t\t            return false;\n  \t\t          }\n\n  \t\t          // Don't consume the colon; let the auth parsing handle it later\n  \t\t        } else {\n  \t\t          // This looks like a malicious protocol (e.g., javascript:alert();@host)\n  \t\t          // or URL-encoded protocol handler (e.g., javascript:%61%6c%65%72%74%28%31%29@host)\n  \t\t          url = cleanUpProtocol(potential_protocol);\n  \t\t          if (url === false) {\n  \t\t            return false;\n  \t\t          }\n  \t\t        }\n  \t\t      } else {\n  \t\t        // No @ symbol found. Check if this could be a port number instead of a protocol.\n  \t\t        // If what's after the colon is numeric (or starts with a digit and contains only\n  \t\t        // valid port characters until a path separator), it's likely hostname:port, not a protocol.\n  \t\t        var looks_like_port = /^[0-9]/.test(after_colon);\n  \t\t        if (looks_like_port) {\n  \t\t          // This looks like hostname:port, not a protocol\n  \t\t          if (options.require_protocol) {\n  \t\t            return false;\n  \t\t          }\n  \t\t          // Don't consume anything; let it be parsed as hostname:port\n  \t\t        } else {\n  \t\t          // This is definitely a protocol\n  \t\t          url = cleanUpProtocol(potential_protocol);\n  \t\t          if (url === false) {\n  \t\t            return false;\n  \t\t          }\n  \t\t        }\n  \t\t      }\n  \t\t    } else {\n  \t\t      // Starts with '//', this is definitely a protocol like http://\n  \t\t      url = cleanUpProtocol(potential_protocol);\n  \t\t      if (url === false) {\n  \t\t        return false;\n  \t\t      }\n  \t\t    }\n  \t\t  } else if (options.require_protocol) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Handle leading '//' only as protocol-relative when there was NO explicit protocol.\n  \t\t  // If there was an explicit protocol, '//' is the normal separator\n  \t\t  // and should be stripped unconditionally.\n  \t\t  if (url.slice(0, 2) === '//') {\n  \t\t    if (!had_explicit_protocol && !options.allow_protocol_relative_urls) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    url = url.slice(2);\n  \t\t  }\n  \t\t  if (url === '') {\n  \t\t    return false;\n  \t\t  }\n  \t\t  split = url.split('/');\n  \t\t  url = split.shift();\n  \t\t  if (url === '' && !options.require_host) {\n  \t\t    return true;\n  \t\t  }\n  \t\t  split = url.split('@');\n  \t\t  if (split.length > 1) {\n  \t\t    if (options.disallow_auth) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (split[0] === '') {\n  \t\t      return false;\n  \t\t    }\n  \t\t    auth = split.shift();\n  \t\t    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    var _auth$split = auth.split(':'),\n  \t\t      _auth$split2 = _slicedToArray(_auth$split, 2),\n  \t\t      user = _auth$split2[0],\n  \t\t      password = _auth$split2[1];\n  \t\t    if (user === '' && password === '') {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  hostname = split.join('@');\n  \t\t  port_str = null;\n  \t\t  ipv6 = null;\n  \t\t  var ipv6_match = hostname.match(wrapped_ipv6);\n  \t\t  if (ipv6_match) {\n  \t\t    host = '';\n  \t\t    ipv6 = ipv6_match[1];\n  \t\t    port_str = ipv6_match[2] || null;\n  \t\t  } else {\n  \t\t    split = hostname.split(':');\n  \t\t    host = split.shift();\n  \t\t    if (split.length) {\n  \t\t      port_str = split.join(':');\n  \t\t    }\n  \t\t  }\n  \t\t  if (port_str !== null && port_str.length > 0) {\n  \t\t    port = parseInt(port_str, 10);\n  \t\t    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  } else if (options.require_port) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  if (options.host_whitelist) {\n  \t\t    return (0, _checkHost.default)(host, options.host_whitelist);\n  \t\t  }\n  \t\t  if (host === '' && !options.require_host) {\n  \t\t    return true;\n  \t\t  }\n  \t\t  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  host = host || ipv6;\n  \t\t  if (options.host_blacklist && (0, _checkHost.default)(host, options.host_blacklist)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isURL, isURL.exports));\n  \treturn isURL.exports;\n  }\n\n  var isMACAddress = {exports: {}};\n\n  var hasRequiredIsMACAddress;\n\n  function requireIsMACAddress () {\n  \tif (hasRequiredIsMACAddress) return isMACAddress.exports;\n  \thasRequiredIsMACAddress = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isMACAddress;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\\s]))([0-9a-fA-F]{2}\\1){4}([0-9a-fA-F]{2})$/;\n  \t\tvar macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;\n  \t\tvar macAddress48WithDots = /^([0-9a-fA-F]{4}\\.){2}([0-9a-fA-F]{4})$/;\n  \t\tvar macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\\s]))([0-9a-fA-F]{2}\\1){6}([0-9a-fA-F]{2})$/;\n  \t\tvar macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;\n  \t\tvar macAddress64WithDots = /^([0-9a-fA-F]{4}\\.){3}([0-9a-fA-F]{4})$/;\n  \t\tfunction isMACAddress(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (options !== null && options !== void 0 && options.eui) {\n  \t\t    options.eui = String(options.eui);\n  \t\t  }\n  \t\t  /**\n  \t\t   * @deprecated `no_colons` TODO: remove it in the next major\n  \t\t  */\n  \t\t  if (options !== null && options !== void 0 && options.no_colons || options !== null && options !== void 0 && options.no_separators) {\n  \t\t    if (options.eui === '48') {\n  \t\t      return macAddress48NoSeparators.test(str);\n  \t\t    }\n  \t\t    if (options.eui === '64') {\n  \t\t      return macAddress64NoSeparators.test(str);\n  \t\t    }\n  \t\t    return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);\n  \t\t  }\n  \t\t  if ((options === null || options === void 0 ? void 0 : options.eui) === '48') {\n  \t\t    return macAddress48.test(str) || macAddress48WithDots.test(str);\n  \t\t  }\n  \t\t  if ((options === null || options === void 0 ? void 0 : options.eui) === '64') {\n  \t\t    return macAddress64.test(str) || macAddress64WithDots.test(str);\n  \t\t  }\n  \t\t  return isMACAddress(str, {\n  \t\t    eui: '48'\n  \t\t  }) || isMACAddress(str, {\n  \t\t    eui: '64'\n  \t\t  });\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isMACAddress, isMACAddress.exports));\n  \treturn isMACAddress.exports;\n  }\n\n  var isIPRange = {exports: {}};\n\n  var hasRequiredIsIPRange;\n\n  function requireIsIPRange () {\n  \tif (hasRequiredIsIPRange) return isIPRange.exports;\n  \thasRequiredIsIPRange = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isIPRange;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _isIP = _interopRequireDefault(requireIsIP());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar subnetMaybe = /^\\d{1,3}$/;\n  \t\tvar v4Subnet = 32;\n  \t\tvar v6Subnet = 128;\n  \t\tfunction isIPRange(str) {\n  \t\t  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var parts = str.split('/');\n\n  \t\t  // parts[0] -> ip, parts[1] -> subnet\n  \t\t  if (parts.length !== 2) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  if (!subnetMaybe.test(parts[1])) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Disallow preceding 0 i.e. 01, 02, ...\n  \t\t  if (parts[1].length > 1 && parts[1].startsWith('0')) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var isValidIP = (0, _isIP.default)(parts[0], version);\n  \t\t  if (!isValidIP) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Define valid subnet according to IP's version\n  \t\t  var expectedSubnet = null;\n  \t\t  switch (String(version)) {\n  \t\t    case '4':\n  \t\t      expectedSubnet = v4Subnet;\n  \t\t      break;\n  \t\t    case '6':\n  \t\t      expectedSubnet = v6Subnet;\n  \t\t      break;\n  \t\t    default:\n  \t\t      expectedSubnet = (0, _isIP.default)(parts[0], '6') ? v6Subnet : v4Subnet;\n  \t\t  }\n  \t\t  return parts[1] <= expectedSubnet && parts[1] >= 0;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isIPRange, isIPRange.exports));\n  \treturn isIPRange.exports;\n  }\n\n  var isDate = {exports: {}};\n\n  var hasRequiredIsDate;\n\n  function requireIsDate () {\n  \tif (hasRequiredIsDate) return isDate.exports;\n  \thasRequiredIsDate = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isDate;\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\n  \t\tfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n  \t\tfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\n  \t\tfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n  \t\tfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: true } : { done: false, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = true, u = false; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = true, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\n  \t\tfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\n  \t\tfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n  \t\tvar default_date_options = {\n  \t\t  format: 'YYYY/MM/DD',\n  \t\t  delimiters: ['/', '-'],\n  \t\t  strictMode: false\n  \t\t};\n  \t\tfunction isValidFormat(format) {\n  \t\t  return /(^(y{4}|y{2})[.\\/-](m{1,2})[.\\/-](d{1,2})$)|(^(m{1,2})[.\\/-](d{1,2})[.\\/-]((y{4}|y{2})$))|(^(d{1,2})[.\\/-](m{1,2})[.\\/-]((y{4}|y{2})$))/gi.test(format);\n  \t\t}\n  \t\tfunction zip(date, format) {\n  \t\t  var zippedArr = [],\n  \t\t    len = Math.max(date.length, format.length);\n  \t\t  for (var i = 0; i < len; i++) {\n  \t\t    zippedArr.push([date[i], format[i]]);\n  \t\t  }\n  \t\t  return zippedArr;\n  \t\t}\n  \t\tfunction isDate(input, options) {\n  \t\t  if (typeof options === 'string') {\n  \t\t    // Allow backward compatibility for old format isDate(input [, format])\n  \t\t    options = (0, _merge.default)({\n  \t\t      format: options\n  \t\t    }, default_date_options);\n  \t\t  } else {\n  \t\t    options = (0, _merge.default)(options, default_date_options);\n  \t\t  }\n  \t\t  if (typeof input === 'string' && isValidFormat(options.format)) {\n  \t\t    if (options.strictMode && input.length !== options.format.length) return false;\n  \t\t    var formatDelimiter = options.delimiters.find(function (delimiter) {\n  \t\t      return options.format.indexOf(delimiter) !== -1;\n  \t\t    });\n  \t\t    var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function (delimiter) {\n  \t\t      return input.indexOf(delimiter) !== -1;\n  \t\t    });\n  \t\t    var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));\n  \t\t    var dateObj = {};\n  \t\t    var _iterator = _createForOfIteratorHelper(dateAndFormat),\n  \t\t      _step;\n  \t\t    try {\n  \t\t      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n  \t\t        var _step$value = _slicedToArray(_step.value, 2),\n  \t\t          dateWord = _step$value[0],\n  \t\t          formatWord = _step$value[1];\n  \t\t        if (!dateWord || !formatWord || dateWord.length !== formatWord.length) {\n  \t\t          return false;\n  \t\t        }\n  \t\t        dateObj[formatWord.charAt(0)] = dateWord;\n  \t\t      }\n  \t\t    } catch (err) {\n  \t\t      _iterator.e(err);\n  \t\t    } finally {\n  \t\t      _iterator.f();\n  \t\t    }\n  \t\t    var fullYear = dateObj.y;\n\n  \t\t    // Check if the year starts with a hyphen\n  \t\t    if (fullYear.startsWith('-')) {\n  \t\t      return false; // Hyphen before year is not allowed\n  \t\t    }\n  \t\t    if (dateObj.y.length === 2) {\n  \t\t      var parsedYear = parseInt(dateObj.y, 10);\n  \t\t      if (isNaN(parsedYear)) {\n  \t\t        return false;\n  \t\t      }\n  \t\t      var currentYearLastTwoDigits = new Date().getFullYear() % 100;\n  \t\t      if (parsedYear < currentYearLastTwoDigits) {\n  \t\t        fullYear = \"20\".concat(dateObj.y);\n  \t\t      } else {\n  \t\t        fullYear = \"19\".concat(dateObj.y);\n  \t\t      }\n  \t\t    }\n  \t\t    var month = dateObj.m;\n  \t\t    if (dateObj.m.length === 1) {\n  \t\t      month = \"0\".concat(dateObj.m);\n  \t\t    }\n  \t\t    var day = dateObj.d;\n  \t\t    if (dateObj.d.length === 1) {\n  \t\t      day = \"0\".concat(dateObj.d);\n  \t\t    }\n  \t\t    return new Date(\"\".concat(fullYear, \"-\").concat(month, \"-\").concat(day, \"T00:00:00.000Z\")).getUTCDate() === +dateObj.d;\n  \t\t  }\n  \t\t  if (!options.strictMode) {\n  \t\t    return Object.prototype.toString.call(input) === '[object Date]' && isFinite(input);\n  \t\t  }\n  \t\t  return false;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isDate, isDate.exports));\n  \treturn isDate.exports;\n  }\n\n  var isTime = {exports: {}};\n\n  var hasRequiredIsTime;\n\n  function requireIsTime () {\n  \tif (hasRequiredIsTime) return isTime.exports;\n  \thasRequiredIsTime = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isTime;\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar default_time_options = {\n  \t\t  hourFormat: 'hour24',\n  \t\t  mode: 'default'\n  \t\t};\n  \t\tvar formats = {\n  \t\t  hour24: {\n  \t\t    default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,\n  \t\t    withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/,\n  \t\t    withOptionalSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9]))?$/\n  \t\t  },\n  \t\t  hour12: {\n  \t\t    default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,\n  \t\t    withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/,\n  \t\t    withOptionalSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9])(?::([0-5][0-9]))? (A|P)M$/\n  \t\t  }\n  \t\t};\n  \t\tfunction isTime(input, options) {\n  \t\t  options = (0, _merge.default)(options, default_time_options);\n  \t\t  if (typeof input !== 'string') return false;\n  \t\t  return formats[options.hourFormat][options.mode].test(input);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isTime, isTime.exports));\n  \treturn isTime.exports;\n  }\n\n  var isBoolean = {exports: {}};\n\n  var includesArray = {exports: {}};\n\n  var hasRequiredIncludesArray;\n\n  function requireIncludesArray () {\n  \tif (hasRequiredIncludesArray) return includesArray.exports;\n  \thasRequiredIncludesArray = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = void 0;\n  \t\tvar includes = function includes(arr, val) {\n  \t\t  return arr.some(function (arrVal) {\n  \t\t    return val === arrVal;\n  \t\t  });\n  \t\t};\n  \t\texports$1.default = includes;\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (includesArray, includesArray.exports));\n  \treturn includesArray.exports;\n  }\n\n  var hasRequiredIsBoolean;\n\n  function requireIsBoolean () {\n  \tif (hasRequiredIsBoolean) return isBoolean.exports;\n  \thasRequiredIsBoolean = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isBoolean;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _includesArray = _interopRequireDefault(requireIncludesArray());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar defaultOptions = {\n  \t\t  loose: false\n  \t\t};\n  \t\tvar strictBooleans = ['true', 'false', '1', '0'];\n  \t\tvar looseBooleans = [].concat(strictBooleans, ['yes', 'no']);\n  \t\tfunction isBoolean(str) {\n  \t\t  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (options.loose) {\n  \t\t    return (0, _includesArray.default)(looseBooleans, str.toLowerCase());\n  \t\t  }\n  \t\t  return (0, _includesArray.default)(strictBooleans, str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isBoolean, isBoolean.exports));\n  \treturn isBoolean.exports;\n  }\n\n  var isLocale = {exports: {}};\n\n  var hasRequiredIsLocale;\n\n  function requireIsLocale () {\n  \tif (hasRequiredIsLocale) return isLocale.exports;\n  \thasRequiredIsLocale = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isLocale;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t/*\n  \t\t  = 3ALPHA              ; selected ISO 639 codes\n  \t\t    *2(\"-\" 3ALPHA)      ; permanently reserved\n  \t\t */\n  \t\tvar extlang = '([A-Za-z]{3}(-[A-Za-z]{3}){0,2})';\n\n  \t\t/*\n  \t\t  = 2*3ALPHA            ; shortest ISO 639 code\n  \t\t    [\"-\" extlang]       ; sometimes followed by\n  \t\t                        ; extended language subtags\n  \t\t  / 4ALPHA              ; or reserved for future use\n  \t\t  / 5*8ALPHA            ; or registered language subtag\n  \t\t */\n  \t\tvar language = \"(([a-zA-Z]{2,3}(-\".concat(extlang, \")?)|([a-zA-Z]{5,8}))\");\n\n  \t\t/*\n  \t\t  = 4ALPHA              ; ISO 15924 code\n  \t\t */\n  \t\tvar script = '([A-Za-z]{4})';\n\n  \t\t/*\n  \t\t  = 2ALPHA              ; ISO 3166-1 code\n  \t\t  / 3DIGIT              ; UN M.49 code\n  \t\t */\n  \t\tvar region = '([A-Za-z]{2}|\\\\d{3})';\n\n  \t\t/*\n  \t\t  = 5*8alphanum         ; registered variants\n  \t\t  / (DIGIT 3alphanum)\n  \t\t */\n  \t\tvar variant = '([A-Za-z0-9]{5,8}|(\\\\d[A-Z-a-z0-9]{3}))';\n\n  \t\t/*\n  \t\t  = DIGIT               ; 0 - 9\n  \t\t  / %x41-57             ; A - W\n  \t\t  / %x59-5A             ; Y - Z\n  \t\t  / %x61-77             ; a - w\n  \t\t  / %x79-7A             ; y - z\n  \t\t */\n  \t\tvar singleton = '(\\\\d|[A-W]|[Y-Z]|[a-w]|[y-z])';\n\n  \t\t/*\n  \t\t  = singleton 1*(\"-\" (2*8alphanum))\n  \t\t                        ; Single alphanumerics\n  \t\t                        ; \"x\" reserved for private use\n  \t\t */\n  \t\tvar extension = \"(\".concat(singleton, \"(-[A-Za-z0-9]{2,8})+)\");\n\n  \t\t/*\n  \t\t  = \"x\" 1*(\"-\" (1*8alphanum))\n  \t\t */\n  \t\tvar privateuse = '(x(-[A-Za-z0-9]{1,8})+)';\n\n  \t\t// irregular tags do not match the 'langtag' production and would not\n  \t\t// otherwise be considered 'well-formed'. These tags are all valid, but\n  \t\t// most are deprecated in favor of more modern subtags or subtag combination\n\n  \t\tvar irregular = '((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|' + '(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|' + '(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))';\n\n  \t\t// regular tags match the 'langtag' production, but their subtags are not\n  \t\t// extended language or variant subtags: their meaning is defined by\n  \t\t// their registration and all of these are deprecated in favor of a more\n  \t\t// modern subtag or sequence of subtags\n\n  \t\tvar regular = '((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|' + '(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))';\n\n  \t\t/*\n  \t\t  = irregular           ; non-redundant tags registered\n  \t\t  / regular             ; during the RFC 3066 era\n\n  \t\t */\n  \t\tvar grandfathered = \"(\".concat(irregular, \"|\").concat(regular, \")\");\n\n  \t\t/*\n  \t\t  RFC 5646 defines delimitation of subtags via a hyphen:\n\n  \t\t      \"Subtag\" refers to a specific section of a tag, delimited by a\n  \t\t      hyphen, such as the subtags 'zh', 'Hant', and 'CN' in the tag \"zh-\n  \t\t      Hant-CN\".  Examples of subtags in this document are enclosed in\n  \t\t      single quotes ('Hant')\n\n  \t\t  However, we need to add \"_\" to maintain the existing behaviour.\n  \t\t */\n  \t\tvar delimiter = '(-|_)';\n\n  \t\t/*\n  \t\t  = language\n  \t\t    [\"-\" script]\n  \t\t    [\"-\" region]\n  \t\t    *(\"-\" variant)\n  \t\t    *(\"-\" extension)\n  \t\t    [\"-\" privateuse]\n  \t\t */\n  \t\tvar langtag = \"\".concat(language, \"(\").concat(delimiter).concat(script, \")?(\").concat(delimiter).concat(region, \")?(\").concat(delimiter).concat(variant, \")*(\").concat(delimiter).concat(extension, \")*(\").concat(delimiter).concat(privateuse, \")?\");\n\n  \t\t/*\n  \t\t  Regex implementation based on BCP RFC 5646\n  \t\t  Tags for Identifying Languages\n  \t\t  https://www.rfc-editor.org/rfc/rfc5646.html\n  \t\t */\n  \t\tvar languageTagRegex = new RegExp(\"(^\".concat(privateuse, \"$)|(^\").concat(grandfathered, \"$)|(^\").concat(langtag, \"$)\"));\n  \t\tfunction isLocale(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return languageTagRegex.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isLocale, isLocale.exports));\n  \treturn isLocale.exports;\n  }\n\n  var isAbaRouting = {exports: {}};\n\n  var hasRequiredIsAbaRouting;\n\n  function requireIsAbaRouting () {\n  \tif (hasRequiredIsAbaRouting) return isAbaRouting.exports;\n  \thasRequiredIsAbaRouting = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isAbaRouting;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t// http://www.brainjar.com/js/validation/\n  \t\t// https://www.aba.com/news-research/research-analysis/routing-number-policy-procedures\n  \t\t// series reserved for future use are excluded\n  \t\tvar isRoutingReg = /^(?!(1[3-9])|(20)|(3[3-9])|(4[0-9])|(5[0-9])|(60)|(7[3-9])|(8[1-9])|(9[0-2])|(9[3-9]))[0-9]{9}$/;\n  \t\tfunction isAbaRouting(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (!isRoutingReg.test(str)) return false;\n  \t\t  var checkSumVal = 0;\n  \t\t  for (var i = 0; i < str.length; i++) {\n  \t\t    if (i % 3 === 0) checkSumVal += str[i] * 3;else if (i % 3 === 1) checkSumVal += str[i] * 7;else checkSumVal += str[i] * 1;\n  \t\t  }\n  \t\t  return checkSumVal % 10 === 0;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isAbaRouting, isAbaRouting.exports));\n  \treturn isAbaRouting.exports;\n  }\n\n  var isAlpha = {};\n\n  var hasRequiredIsAlpha;\n\n  function requireIsAlpha () {\n  \tif (hasRequiredIsAlpha) return isAlpha;\n  \thasRequiredIsAlpha = 1;\n\n  \tObject.defineProperty(isAlpha, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisAlpha.default = isAlpha$1;\n  \tisAlpha.locales = void 0;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tvar _alpha = requireAlpha();\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \tfunction isAlpha$1(_str) {\n  \t  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';\n  \t  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  \t  (0, _assertString.default)(_str);\n  \t  var str = _str;\n  \t  var ignore = options.ignore;\n  \t  if (ignore) {\n  \t    if (ignore instanceof RegExp) {\n  \t      str = str.replace(ignore, '');\n  \t    } else if (typeof ignore === 'string') {\n  \t      str = str.replace(new RegExp(\"[\".concat(ignore.replace(/[-[\\]{}()*+?.,\\\\^$|#\\\\s]/g, '\\\\$&'), \"]\"), 'g'), ''); // escape regex for ignore\n  \t    } else {\n  \t      throw new Error('ignore should be instance of a String or RegExp');\n  \t    }\n  \t  }\n  \t  if (locale in _alpha.alpha) {\n  \t    return _alpha.alpha[locale].test(str);\n  \t  }\n  \t  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n  \t}\n  \tisAlpha.locales = Object.keys(_alpha.alpha);\n  \treturn isAlpha;\n  }\n\n  var isAlphanumeric = {};\n\n  var hasRequiredIsAlphanumeric;\n\n  function requireIsAlphanumeric () {\n  \tif (hasRequiredIsAlphanumeric) return isAlphanumeric;\n  \thasRequiredIsAlphanumeric = 1;\n\n  \tObject.defineProperty(isAlphanumeric, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisAlphanumeric.default = isAlphanumeric$1;\n  \tisAlphanumeric.locales = void 0;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tvar _alpha = requireAlpha();\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \tfunction isAlphanumeric$1(_str) {\n  \t  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';\n  \t  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  \t  (0, _assertString.default)(_str);\n  \t  var str = _str;\n  \t  var ignore = options.ignore;\n  \t  if (ignore) {\n  \t    if (ignore instanceof RegExp) {\n  \t      str = str.replace(ignore, '');\n  \t    } else if (typeof ignore === 'string') {\n  \t      str = str.replace(new RegExp(\"[\".concat(ignore.replace(/[-[\\]{}()*+?.,\\\\^$|#\\\\s]/g, '\\\\$&'), \"]\"), 'g'), ''); // escape regex for ignore\n  \t    } else {\n  \t      throw new Error('ignore should be instance of a String or RegExp');\n  \t    }\n  \t  }\n  \t  if (locale in _alpha.alphanumeric) {\n  \t    return _alpha.alphanumeric[locale].test(str);\n  \t  }\n  \t  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n  \t}\n  \tisAlphanumeric.locales = Object.keys(_alpha.alphanumeric);\n  \treturn isAlphanumeric;\n  }\n\n  var isNumeric = {exports: {}};\n\n  var hasRequiredIsNumeric;\n\n  function requireIsNumeric () {\n  \tif (hasRequiredIsNumeric) return isNumeric.exports;\n  \thasRequiredIsNumeric = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isNumeric;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _alpha = requireAlpha();\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar numericNoSymbols = /^[0-9]+$/;\n  \t\tfunction isNumeric(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (options && options.no_symbols) {\n  \t\t    return numericNoSymbols.test(str);\n  \t\t  }\n  \t\t  return new RegExp(\"^[+-]?([0-9]*[\".concat((options || {}).locale ? _alpha.decimal[options.locale] : '.', \"])?[0-9]+$\")).test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isNumeric, isNumeric.exports));\n  \treturn isNumeric.exports;\n  }\n\n  var isPassportNumber = {};\n\n  var hasRequiredIsPassportNumber;\n\n  function requireIsPassportNumber () {\n  \tif (hasRequiredIsPassportNumber) return isPassportNumber;\n  \thasRequiredIsPassportNumber = 1;\n\n  \tObject.defineProperty(isPassportNumber, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisPassportNumber.default = isPassportNumber$1;\n  \tisPassportNumber.locales = void 0;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t/**\n  \t * Reference:\n  \t * https://en.wikipedia.org/ -- Wikipedia\n  \t * https://docs.microsoft.com/en-us/microsoft-365/compliance/eu-passport-number -- EU Passport Number\n  \t * https://countrycode.org/ -- Country Codes\n  \t */\n  \tvar passportRegexByCountryCode = {\n  \t  AM: /^[A-Z]{2}\\d{7}$/,\n  \t  // ARMENIA\n  \t  AR: /^[A-Z]{3}\\d{6}$/,\n  \t  // ARGENTINA\n  \t  AT: /^[A-Z]\\d{7}$/,\n  \t  // AUSTRIA\n  \t  AU: /^[A-Z]\\d{7}$/,\n  \t  // AUSTRALIA\n  \t  AZ: /^[A-Z]{1}\\d{8}$/,\n  \t  // AZERBAIJAN\n  \t  BE: /^[A-Z]{2}\\d{6}$/,\n  \t  // BELGIUM\n  \t  BG: /^\\d{9}$/,\n  \t  // BULGARIA\n  \t  BR: /^[A-Z]{2}\\d{6}$/,\n  \t  // BRAZIL\n  \t  BY: /^[A-Z]{2}\\d{7}$/,\n  \t  // BELARUS\n  \t  CA: /^[A-Z]{2}\\d{6}$|^[A-Z]\\d{6}[A-Z]{2}$/,\n  \t  // CANADA\n  \t  CH: /^[A-Z]\\d{7}$/,\n  \t  // SWITZERLAND\n  \t  CN: /^G\\d{8}$|^E(?![IO])[A-Z0-9]\\d{7}$/,\n  \t  // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits\n  \t  CY: /^[A-Z](\\d{6}|\\d{8})$/,\n  \t  // CYPRUS\n  \t  CZ: /^\\d{8}$/,\n  \t  // CZECH REPUBLIC\n  \t  DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,\n  \t  // GERMANY\n  \t  DK: /^\\d{9}$/,\n  \t  // DENMARK\n  \t  DZ: /^\\d{9}$/,\n  \t  // ALGERIA\n  \t  EE: /^([A-Z]\\d{7}|[A-Z]{2}\\d{7})$/,\n  \t  // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits\n  \t  ES: /^[A-Z0-9]{2}([A-Z0-9]?)\\d{6}$/,\n  \t  // SPAIN\n  \t  FI: /^[A-Z]{2}\\d{7}$/,\n  \t  // FINLAND\n  \t  FR: /^\\d{2}[A-Z]{2}\\d{5}$/,\n  \t  // FRANCE\n  \t  GB: /^\\d{9}$/,\n  \t  // UNITED KINGDOM\n  \t  GR: /^[A-Z]{2}\\d{7}$/,\n  \t  // GREECE\n  \t  HR: /^\\d{9}$/,\n  \t  // CROATIA\n  \t  HU: /^[A-Z]{2}(\\d{6}|\\d{7})$/,\n  \t  // HUNGARY\n  \t  IE: /^[A-Z0-9]{2}\\d{7}$/,\n  \t  // IRELAND\n  \t  IN: /^[A-Z]{1}-?\\d{7}$/,\n  \t  // INDIA\n  \t  ID: /^[A-C]\\d{7}$/,\n  \t  // INDONESIA\n  \t  IR: /^[A-Z]\\d{8}$/,\n  \t  // IRAN\n  \t  IS: /^(A)\\d{7}$/,\n  \t  // ICELAND\n  \t  IT: /^[A-Z0-9]{2}\\d{7}$/,\n  \t  // ITALY\n  \t  JM: /^[Aa]\\d{7}$/,\n  \t  // JAMAICA\n  \t  JP: /^[A-Z]{2}\\d{7}$/,\n  \t  // JAPAN\n  \t  KR: /^[MS]\\d{8}$/,\n  \t  // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]\n  \t  KZ: /^[a-zA-Z]\\d{7}$/,\n  \t  // KAZAKHSTAN\n  \t  LI: /^[a-zA-Z]\\d{5}$/,\n  \t  // LIECHTENSTEIN\n  \t  LT: /^[A-Z0-9]{8}$/,\n  \t  // LITHUANIA\n  \t  LU: /^[A-Z0-9]{8}$/,\n  \t  // LUXEMBURG\n  \t  LV: /^[A-Z0-9]{2}\\d{7}$/,\n  \t  // LATVIA\n  \t  LY: /^[A-Z0-9]{8}$/,\n  \t  // LIBYA\n  \t  MT: /^\\d{7}$/,\n  \t  // MALTA\n  \t  MZ: /^([A-Z]{2}\\d{7})|(\\d{2}[A-Z]{2}\\d{5})$/,\n  \t  // MOZAMBIQUE\n  \t  MY: /^[AHK]\\d{8}$/,\n  \t  // MALAYSIA\n  \t  MX: /^\\d{10,11}$/,\n  \t  // MEXICO\n  \t  NL: /^[A-Z]{2}[A-Z0-9]{6}\\d$/,\n  \t  // NETHERLANDS\n  \t  NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\\d{6}$/,\n  \t  // NEW ZEALAND\n  \t  PH: /^([A-Z](\\d{6}|\\d{7}[A-Z]))|([A-Z]{2}(\\d{6}|\\d{7}))$/,\n  \t  // PHILIPPINES\n  \t  PK: /^[A-Z]{2}\\d{7}$/,\n  \t  // PAKISTAN\n  \t  PL: /^[A-Z]{2}\\d{7}$/,\n  \t  // POLAND\n  \t  PT: /^[A-Z]\\d{6}$/,\n  \t  // PORTUGAL\n  \t  RO: /^\\d{8,9}$/,\n  \t  // ROMANIA\n  \t  RU: /^\\d{9}$/,\n  \t  // RUSSIAN FEDERATION\n  \t  SE: /^\\d{8}$/,\n  \t  // SWEDEN\n  \t  SL: /^(P)[A-Z]\\d{7}$/,\n  \t  // SLOVENIA\n  \t  SK: /^[0-9A-Z]\\d{7}$/,\n  \t  // SLOVAKIA\n  \t  TH: /^[A-Z]{1,2}\\d{6,7}$/,\n  \t  // THAILAND\n  \t  TR: /^[A-Z]\\d{8}$/,\n  \t  // TURKEY\n  \t  UA: /^[A-Z]{2}\\d{6}$/,\n  \t  // UKRAINE\n  \t  US: /^\\d{9}$|^[A-Z]\\d{8}$/,\n  \t  // UNITED STATES\n  \t  ZA: /^[TAMD]\\d{8}$/ // SOUTH AFRICA\n  \t};\n  \tisPassportNumber.locales = Object.keys(passportRegexByCountryCode);\n\n  \t/**\n  \t * Check if str is a valid passport number\n  \t * relative to provided ISO Country Code.\n  \t *\n  \t * @param {string} str\n  \t * @param {string} countryCode\n  \t * @return {boolean}\n  \t */\n  \tfunction isPassportNumber$1(str, countryCode) {\n  \t  (0, _assertString.default)(str);\n  \t  /** Remove All Whitespaces, Convert to UPPERCASE */\n  \t  var normalizedStr = str.replace(/\\s/g, '').toUpperCase();\n  \t  return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);\n  \t}\n  \treturn isPassportNumber;\n  }\n\n  var isPort = {exports: {}};\n\n  var isInt = {exports: {}};\n\n  var hasRequiredIsInt;\n\n  function requireIsInt () {\n  \tif (hasRequiredIsInt) return isInt.exports;\n  \thasRequiredIsInt = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isInt;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _nullUndefinedCheck = _interopRequireDefault(requireNullUndefinedCheck());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;\n  \t\tvar intLeadingZeroes = /^[-+]?[0-9]+$/;\n  \t\tfunction isInt(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = options || {};\n\n  \t\t  // Get the regex to use for testing, based on whether\n  \t\t  // leading zeroes are allowed or not.\n  \t\t  var regex = options.allow_leading_zeroes === false ? int : intLeadingZeroes;\n\n  \t\t  // Check min/max/lt/gt\n  \t\t  var minCheckPassed = !options.hasOwnProperty('min') || (0, _nullUndefinedCheck.default)(options.min) || str >= options.min;\n  \t\t  var maxCheckPassed = !options.hasOwnProperty('max') || (0, _nullUndefinedCheck.default)(options.max) || str <= options.max;\n  \t\t  var ltCheckPassed = !options.hasOwnProperty('lt') || (0, _nullUndefinedCheck.default)(options.lt) || str < options.lt;\n  \t\t  var gtCheckPassed = !options.hasOwnProperty('gt') || (0, _nullUndefinedCheck.default)(options.gt) || str > options.gt;\n  \t\t  return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isInt, isInt.exports));\n  \treturn isInt.exports;\n  }\n\n  var hasRequiredIsPort;\n\n  function requireIsPort () {\n  \tif (hasRequiredIsPort) return isPort.exports;\n  \thasRequiredIsPort = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isPort;\n  \t\tvar _isInt = _interopRequireDefault(requireIsInt());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction isPort(str) {\n  \t\t  return (0, _isInt.default)(str, {\n  \t\t    allow_leading_zeroes: false,\n  \t\t    min: 0,\n  \t\t    max: 65535\n  \t\t  });\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isPort, isPort.exports));\n  \treturn isPort.exports;\n  }\n\n  var isLowercase = {exports: {}};\n\n  var hasRequiredIsLowercase;\n\n  function requireIsLowercase () {\n  \tif (hasRequiredIsLowercase) return isLowercase.exports;\n  \thasRequiredIsLowercase = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isLowercase;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction isLowercase(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return str === str.toLowerCase();\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isLowercase, isLowercase.exports));\n  \treturn isLowercase.exports;\n  }\n\n  var isUppercase = {exports: {}};\n\n  var hasRequiredIsUppercase;\n\n  function requireIsUppercase () {\n  \tif (hasRequiredIsUppercase) return isUppercase.exports;\n  \thasRequiredIsUppercase = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isUppercase;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction isUppercase(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return str === str.toUpperCase();\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isUppercase, isUppercase.exports));\n  \treturn isUppercase.exports;\n  }\n\n  var isIMEI = {exports: {}};\n\n  var hasRequiredIsIMEI;\n\n  function requireIsIMEI () {\n  \tif (hasRequiredIsIMEI) return isIMEI.exports;\n  \thasRequiredIsIMEI = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isIMEI;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar imeiRegexWithoutHyphens = /^[0-9]{15}$/;\n  \t\tvar imeiRegexWithHyphens = /^\\d{2}-\\d{6}-\\d{6}-\\d{1}$/;\n  \t\tfunction isIMEI(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = options || {};\n\n  \t\t  // default regex for checking imei is the one without hyphens\n\n  \t\t  var imeiRegex = imeiRegexWithoutHyphens;\n  \t\t  if (options.allow_hyphens) {\n  \t\t    imeiRegex = imeiRegexWithHyphens;\n  \t\t  }\n  \t\t  if (!imeiRegex.test(str)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  str = str.replace(/-/g, '');\n  \t\t  var sum = 0,\n  \t\t    mul = 2,\n  \t\t    l = 14;\n  \t\t  for (var i = 0; i < l; i++) {\n  \t\t    var digit = str.substring(l - i - 1, l - i);\n  \t\t    var tp = parseInt(digit, 10) * mul;\n  \t\t    if (tp >= 10) {\n  \t\t      sum += tp % 10 + 1;\n  \t\t    } else {\n  \t\t      sum += tp;\n  \t\t    }\n  \t\t    if (mul === 1) {\n  \t\t      mul += 1;\n  \t\t    } else {\n  \t\t      mul -= 1;\n  \t\t    }\n  \t\t  }\n  \t\t  var chk = (10 - sum % 10) % 10;\n  \t\t  if (chk !== parseInt(str.substring(14, 15), 10)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isIMEI, isIMEI.exports));\n  \treturn isIMEI.exports;\n  }\n\n  var isAscii = {exports: {}};\n\n  var hasRequiredIsAscii;\n\n  function requireIsAscii () {\n  \tif (hasRequiredIsAscii) return isAscii.exports;\n  \thasRequiredIsAscii = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isAscii;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t/* eslint-disable no-control-regex */\n  \t\tvar ascii = /^[\\x00-\\x7F]+$/;\n  \t\t/* eslint-enable no-control-regex */\n\n  \t\tfunction isAscii(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return ascii.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isAscii, isAscii.exports));\n  \treturn isAscii.exports;\n  }\n\n  var isFullWidth = {};\n\n  var hasRequiredIsFullWidth;\n\n  function requireIsFullWidth () {\n  \tif (hasRequiredIsFullWidth) return isFullWidth;\n  \thasRequiredIsFullWidth = 1;\n\n  \tObject.defineProperty(isFullWidth, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisFullWidth.default = isFullWidth$1;\n  \tisFullWidth.fullWidth = void 0;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \tvar fullWidth = isFullWidth.fullWidth = /[^\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]/;\n  \tfunction isFullWidth$1(str) {\n  \t  (0, _assertString.default)(str);\n  \t  return fullWidth.test(str);\n  \t}\n  \treturn isFullWidth;\n  }\n\n  var isHalfWidth = {};\n\n  var hasRequiredIsHalfWidth;\n\n  function requireIsHalfWidth () {\n  \tif (hasRequiredIsHalfWidth) return isHalfWidth;\n  \thasRequiredIsHalfWidth = 1;\n\n  \tObject.defineProperty(isHalfWidth, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisHalfWidth.default = isHalfWidth$1;\n  \tisHalfWidth.halfWidth = void 0;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \tvar halfWidth = isHalfWidth.halfWidth = /[\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]/;\n  \tfunction isHalfWidth$1(str) {\n  \t  (0, _assertString.default)(str);\n  \t  return halfWidth.test(str);\n  \t}\n  \treturn isHalfWidth;\n  }\n\n  var isVariableWidth = {exports: {}};\n\n  var hasRequiredIsVariableWidth;\n\n  function requireIsVariableWidth () {\n  \tif (hasRequiredIsVariableWidth) return isVariableWidth.exports;\n  \thasRequiredIsVariableWidth = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isVariableWidth;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _isFullWidth = requireIsFullWidth();\n  \t\tvar _isHalfWidth = requireIsHalfWidth();\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction isVariableWidth(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isVariableWidth, isVariableWidth.exports));\n  \treturn isVariableWidth.exports;\n  }\n\n  var isMultibyte = {exports: {}};\n\n  var hasRequiredIsMultibyte;\n\n  function requireIsMultibyte () {\n  \tif (hasRequiredIsMultibyte) return isMultibyte.exports;\n  \thasRequiredIsMultibyte = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isMultibyte;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t/* eslint-disable no-control-regex */\n  \t\tvar multibyte = /[^\\x00-\\x7F]/;\n  \t\t/* eslint-enable no-control-regex */\n\n  \t\tfunction isMultibyte(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return multibyte.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isMultibyte, isMultibyte.exports));\n  \treturn isMultibyte.exports;\n  }\n\n  var isSemVer = {exports: {}};\n\n  var multilineRegex = {exports: {}};\n\n  var hasRequiredMultilineRegex;\n\n  function requireMultilineRegex () {\n  \tif (hasRequiredMultilineRegex) return multilineRegex.exports;\n  \thasRequiredMultilineRegex = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = multilineRegexp;\n  \t\t/**\n  \t\t * Build RegExp object from an array\n  \t\t * of multiple/multi-line regexp parts\n  \t\t *\n  \t\t * @param {string[]} parts\n  \t\t * @param {string} flags\n  \t\t * @return {object} - RegExp object\n  \t\t */\n  \t\tfunction multilineRegexp(parts, flags) {\n  \t\t  var regexpAsStringLiteral = parts.join('');\n  \t\t  return new RegExp(regexpAsStringLiteral, flags);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (multilineRegex, multilineRegex.exports));\n  \treturn multilineRegex.exports;\n  }\n\n  var hasRequiredIsSemVer;\n\n  function requireIsSemVer () {\n  \tif (hasRequiredIsSemVer) return isSemVer.exports;\n  \thasRequiredIsSemVer = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isSemVer;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _multilineRegex = _interopRequireDefault(requireMultilineRegex());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t/**\n  \t\t * Regular Expression to match\n  \t\t * semantic versioning (SemVer)\n  \t\t * built from multi-line, multi-parts regexp\n  \t\t * Reference: https://semver.org/\n  \t\t */\n  \t\tvar semanticVersioningRegex = (0, _multilineRegex.default)(['^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)', '(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-z-][0-9a-z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-z-][0-9a-z-]*))*))', '?(?:\\\\+([0-9a-z-]+(?:\\\\.[0-9a-z-]+)*))?$'], 'i');\n  \t\tfunction isSemVer(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return semanticVersioningRegex.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isSemVer, isSemVer.exports));\n  \treturn isSemVer.exports;\n  }\n\n  var isSurrogatePair = {exports: {}};\n\n  var hasRequiredIsSurrogatePair;\n\n  function requireIsSurrogatePair () {\n  \tif (hasRequiredIsSurrogatePair) return isSurrogatePair.exports;\n  \thasRequiredIsSurrogatePair = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isSurrogatePair;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\n  \t\tfunction isSurrogatePair(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return surrogatePair.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isSurrogatePair, isSurrogatePair.exports));\n  \treturn isSurrogatePair.exports;\n  }\n\n  var isDecimal = {exports: {}};\n\n  var hasRequiredIsDecimal;\n\n  function requireIsDecimal () {\n  \tif (hasRequiredIsDecimal) return isDecimal.exports;\n  \thasRequiredIsDecimal = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isDecimal;\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _includesArray = _interopRequireDefault(requireIncludesArray());\n  \t\tvar _alpha = requireAlpha();\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction decimalRegExp(options) {\n  \t\t  var regExp = new RegExp(\"^[-+]?([0-9]+)?(\\\\\".concat(_alpha.decimal[options.locale], \"[0-9]{\").concat(options.decimal_digits, \"})\").concat(options.force_decimal ? '' : '?', \"$\"));\n  \t\t  return regExp;\n  \t\t}\n  \t\tvar default_decimal_options = {\n  \t\t  force_decimal: false,\n  \t\t  decimal_digits: '1,',\n  \t\t  locale: 'en-US'\n  \t\t};\n  \t\tvar blacklist = ['', '-', '+'];\n  \t\tfunction isDecimal(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = (0, _merge.default)(options, default_decimal_options);\n  \t\t  if (options.locale in _alpha.decimal) {\n  \t\t    return !(0, _includesArray.default)(blacklist, str.replace(/ /g, '')) && decimalRegExp(options).test(str);\n  \t\t  }\n  \t\t  throw new Error(\"Invalid locale '\".concat(options.locale, \"'\"));\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isDecimal, isDecimal.exports));\n  \treturn isDecimal.exports;\n  }\n\n  var isHexadecimal = {exports: {}};\n\n  var hasRequiredIsHexadecimal;\n\n  function requireIsHexadecimal () {\n  \tif (hasRequiredIsHexadecimal) return isHexadecimal.exports;\n  \thasRequiredIsHexadecimal = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isHexadecimal;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;\n  \t\tfunction isHexadecimal(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return hexadecimal.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isHexadecimal, isHexadecimal.exports));\n  \treturn isHexadecimal.exports;\n  }\n\n  var isOctal = {exports: {}};\n\n  var hasRequiredIsOctal;\n\n  function requireIsOctal () {\n  \tif (hasRequiredIsOctal) return isOctal.exports;\n  \thasRequiredIsOctal = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isOctal;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar octal = /^(0o)?[0-7]+$/i;\n  \t\tfunction isOctal(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return octal.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isOctal, isOctal.exports));\n  \treturn isOctal.exports;\n  }\n\n  var isDivisibleBy = {exports: {}};\n\n  var hasRequiredIsDivisibleBy;\n\n  function requireIsDivisibleBy () {\n  \tif (hasRequiredIsDivisibleBy) return isDivisibleBy.exports;\n  \thasRequiredIsDivisibleBy = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isDivisibleBy;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _toFloat = _interopRequireDefault(requireToFloat());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction isDivisibleBy(str, num) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isDivisibleBy, isDivisibleBy.exports));\n  \treturn isDivisibleBy.exports;\n  }\n\n  var isHexColor = {exports: {}};\n\n  var hasRequiredIsHexColor;\n\n  function requireIsHexColor () {\n  \tif (hasRequiredIsHexColor) return isHexColor.exports;\n  \thasRequiredIsHexColor = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isHexColor;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;\n  \t\tvar hexcolor_with_prefix = /^#([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;\n  \t\tvar default_is_hexcolor_options = {\n  \t\t  require_hashtag: false\n  \t\t};\n  \t\tfunction isHexColor(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = (0, _merge.default)(options, default_is_hexcolor_options);\n  \t\t  var hexcolor_regex = options.require_hashtag ? hexcolor_with_prefix : hexcolor;\n  \t\t  return hexcolor_regex.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isHexColor, isHexColor.exports));\n  \treturn isHexColor.exports;\n  }\n\n  var isRgbColor = {exports: {}};\n\n  var hasRequiredIsRgbColor;\n\n  function requireIsRgbColor () {\n  \tif (hasRequiredIsRgbColor) return isRgbColor.exports;\n  \thasRequiredIsRgbColor = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isRgbColor;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); } /* eslint-disable prefer-rest-params */\n  \t\tvar rgbColor = /^rgb\\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\)$/;\n  \t\tvar rgbaColor = /^rgba\\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\\.\\d\\d?|1(\\.0)?|0(\\.0)?)\\)$/;\n  \t\tvar rgbColorPercent = /^rgb\\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\\)$/;\n  \t\tvar rgbaColorPercent = /^rgba\\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\\.\\d\\d?|1(\\.0)?|0(\\.0)?)\\)$/;\n  \t\tvar startsWithRgb = /^rgba?/;\n  \t\tfunction isRgbColor(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  // default options to true for percent and false for spaces\n  \t\t  var allowSpaces = false;\n  \t\t  var includePercentValues = true;\n  \t\t  if (_typeof(options) !== 'object') {\n  \t\t    if (arguments.length >= 2) {\n  \t\t      includePercentValues = arguments[1];\n  \t\t    }\n  \t\t  } else {\n  \t\t    allowSpaces = options.allowSpaces !== undefined ? options.allowSpaces : allowSpaces;\n  \t\t    includePercentValues = options.includePercentValues !== undefined ? options.includePercentValues : includePercentValues;\n  \t\t  }\n  \t\t  if (allowSpaces) {\n  \t\t    // make sure it starts with continous rgba? without spaces before stripping\n  \t\t    if (!startsWithRgb.test(str)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    // strip all whitespace\n  \t\t    str = str.replace(/\\s/g, '');\n  \t\t  }\n  \t\t  if (!includePercentValues) {\n  \t\t    return rgbColor.test(str) || rgbaColor.test(str);\n  \t\t  }\n  \t\t  return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isRgbColor, isRgbColor.exports));\n  \treturn isRgbColor.exports;\n  }\n\n  var isHSL = {exports: {}};\n\n  var hasRequiredIsHSL;\n\n  function requireIsHSL () {\n  \tif (hasRequiredIsHSL) return isHSL.exports;\n  \thasRequiredIsHSL = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isHSL;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar hslComma = /^hsla?\\(((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%){2}(,((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%?))?\\)$/i;\n  \t\tvar hslSpace = /^hsla?\\(((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?))(deg|grad|rad|turn)?(\\s(\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%){2}\\s?(\\/\\s((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%?)\\s?)?\\)$/i;\n  \t\tfunction isHSL(str) {\n  \t\t  (0, _assertString.default)(str);\n\n  \t\t  // Strip duplicate spaces before calling the validation regex (See  #1598 for more info)\n  \t\t  var strippedStr = str.replace(/\\s+/g, ' ').replace(/\\s?(hsla?\\(|\\)|,)\\s?/ig, '$1');\n  \t\t  if (strippedStr.indexOf(',') !== -1) {\n  \t\t    return hslComma.test(strippedStr);\n  \t\t  }\n  \t\t  return hslSpace.test(strippedStr);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isHSL, isHSL.exports));\n  \treturn isHSL.exports;\n  }\n\n  var isISRC = {exports: {}};\n\n  var hasRequiredIsISRC;\n\n  function requireIsISRC () {\n  \tif (hasRequiredIsISRC) return isISRC.exports;\n  \thasRequiredIsISRC = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isISRC;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t// see http://isrc.ifpi.org/en/isrc-standard/code-syntax\n  \t\tvar isrc = /^[A-Z]{2}[0-9A-Z]{3}\\d{2}\\d{5}$/;\n  \t\tfunction isISRC(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return isrc.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isISRC, isISRC.exports));\n  \treturn isISRC.exports;\n  }\n\n  var isIBAN = {};\n\n  var hasRequiredIsIBAN;\n\n  function requireIsIBAN () {\n  \tif (hasRequiredIsIBAN) return isIBAN;\n  \thasRequiredIsIBAN = 1;\n\n  \tObject.defineProperty(isIBAN, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisIBAN.default = isIBAN$1;\n  \tisIBAN.locales = void 0;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tvar _includesArray = _interopRequireDefault(requireIncludesArray());\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t/**\n  \t * List of country codes with\n  \t * corresponding IBAN regular expression\n  \t * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n  \t */\n  \tvar ibanRegexThroughCountryCode = {\n  \t  AD: /^(AD[0-9]{2})\\d{8}[A-Z0-9]{12}$/,\n  \t  AE: /^(AE[0-9]{2})\\d{3}\\d{16}$/,\n  \t  AL: /^(AL[0-9]{2})\\d{8}[A-Z0-9]{16}$/,\n  \t  AT: /^(AT[0-9]{2})\\d{16}$/,\n  \t  AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  \t  BA: /^(BA[0-9]{2})\\d{16}$/,\n  \t  BE: /^(BE[0-9]{2})\\d{12}$/,\n  \t  BG: /^(BG[0-9]{2})[A-Z]{4}\\d{6}[A-Z0-9]{8}$/,\n  \t  BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,\n  \t  BR: /^(BR[0-9]{2})\\d{23}[A-Z]{1}[A-Z0-9]{1}$/,\n  \t  BY: /^(BY[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  \t  CH: /^(CH[0-9]{2})\\d{5}[A-Z0-9]{12}$/,\n  \t  CR: /^(CR[0-9]{2})\\d{18}$/,\n  \t  CY: /^(CY[0-9]{2})\\d{8}[A-Z0-9]{16}$/,\n  \t  CZ: /^(CZ[0-9]{2})\\d{20}$/,\n  \t  DE: /^(DE[0-9]{2})\\d{18}$/,\n  \t  DK: /^(DK[0-9]{2})\\d{14}$/,\n  \t  DO: /^(DO[0-9]{2})[A-Z]{4}\\d{20}$/,\n  \t  DZ: /^(DZ\\d{24})$/,\n  \t  EE: /^(EE[0-9]{2})\\d{16}$/,\n  \t  EG: /^(EG[0-9]{2})\\d{25}$/,\n  \t  ES: /^(ES[0-9]{2})\\d{20}$/,\n  \t  FI: /^(FI[0-9]{2})\\d{14}$/,\n  \t  FO: /^(FO[0-9]{2})\\d{14}$/,\n  \t  FR: /^(FR[0-9]{2})\\d{10}[A-Z0-9]{11}\\d{2}$/,\n  \t  GB: /^(GB[0-9]{2})[A-Z]{4}\\d{14}$/,\n  \t  GE: /^(GE[0-9]{2})[A-Z0-9]{2}\\d{16}$/,\n  \t  GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,\n  \t  GL: /^(GL[0-9]{2})\\d{14}$/,\n  \t  GR: /^(GR[0-9]{2})\\d{7}[A-Z0-9]{16}$/,\n  \t  GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,\n  \t  HR: /^(HR[0-9]{2})\\d{17}$/,\n  \t  HU: /^(HU[0-9]{2})\\d{24}$/,\n  \t  IE: /^(IE[0-9]{2})[A-Z]{4}\\d{14}$/,\n  \t  IL: /^(IL[0-9]{2})\\d{19}$/,\n  \t  IQ: /^(IQ[0-9]{2})[A-Z]{4}\\d{15}$/,\n  \t  IR: /^(IR[0-9]{2})\\d{22}$/,\n  \t  IS: /^(IS[0-9]{2})\\d{22}$/,\n  \t  IT: /^(IT[0-9]{2})[A-Z]{1}\\d{10}[A-Z0-9]{12}$/,\n  \t  JO: /^(JO[0-9]{2})[A-Z]{4}\\d{22}$/,\n  \t  KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,\n  \t  KZ: /^(KZ[0-9]{2})\\d{3}[A-Z0-9]{13}$/,\n  \t  LB: /^(LB[0-9]{2})\\d{4}[A-Z0-9]{20}$/,\n  \t  LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,\n  \t  LI: /^(LI[0-9]{2})\\d{5}[A-Z0-9]{12}$/,\n  \t  LT: /^(LT[0-9]{2})\\d{16}$/,\n  \t  LU: /^(LU[0-9]{2})\\d{3}[A-Z0-9]{13}$/,\n  \t  LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,\n  \t  MA: /^(MA[0-9]{26})$/,\n  \t  MC: /^(MC[0-9]{2})\\d{10}[A-Z0-9]{11}\\d{2}$/,\n  \t  MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,\n  \t  ME: /^(ME[0-9]{2})\\d{18}$/,\n  \t  MK: /^(MK[0-9]{2})\\d{3}[A-Z0-9]{10}\\d{2}$/,\n  \t  MR: /^(MR[0-9]{2})\\d{23}$/,\n  \t  MT: /^(MT[0-9]{2})[A-Z]{4}\\d{5}[A-Z0-9]{18}$/,\n  \t  MU: /^(MU[0-9]{2})[A-Z]{4}\\d{19}[A-Z]{3}$/,\n  \t  MZ: /^(MZ[0-9]{2})\\d{21}$/,\n  \t  NL: /^(NL[0-9]{2})[A-Z]{4}\\d{10}$/,\n  \t  NO: /^(NO[0-9]{2})\\d{11}$/,\n  \t  PK: /^(PK[0-9]{2})[A-Z0-9]{4}\\d{16}$/,\n  \t  PL: /^(PL[0-9]{2})\\d{24}$/,\n  \t  PS: /^(PS[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,\n  \t  PT: /^(PT[0-9]{2})\\d{21}$/,\n  \t  QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,\n  \t  RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,\n  \t  RS: /^(RS[0-9]{2})\\d{18}$/,\n  \t  SA: /^(SA[0-9]{2})\\d{2}[A-Z0-9]{18}$/,\n  \t  SC: /^(SC[0-9]{2})[A-Z]{4}\\d{20}[A-Z]{3}$/,\n  \t  SE: /^(SE[0-9]{2})\\d{20}$/,\n  \t  SI: /^(SI[0-9]{2})\\d{15}$/,\n  \t  SK: /^(SK[0-9]{2})\\d{20}$/,\n  \t  SM: /^(SM[0-9]{2})[A-Z]{1}\\d{10}[A-Z0-9]{12}$/,\n  \t  SV: /^(SV[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  \t  TL: /^(TL[0-9]{2})\\d{19}$/,\n  \t  TN: /^(TN[0-9]{2})\\d{20}$/,\n  \t  TR: /^(TR[0-9]{2})\\d{5}[A-Z0-9]{17}$/,\n  \t  UA: /^(UA[0-9]{2})\\d{6}[A-Z0-9]{19}$/,\n  \t  VA: /^(VA[0-9]{2})\\d{18}$/,\n  \t  VG: /^(VG[0-9]{2})[A-Z]{4}\\d{16}$/,\n  \t  XK: /^(XK[0-9]{2})\\d{16}$/\n  \t};\n\n  \t/**\n  \t * Check if the country codes passed are valid using the\n  \t * ibanRegexThroughCountryCode as a reference\n  \t *\n  \t * @param {array} countryCodeArray\n  \t * @return {boolean}\n  \t */\n\n  \tfunction hasOnlyValidCountryCodes(countryCodeArray) {\n  \t  var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function (countryCode) {\n  \t    return !(countryCode in ibanRegexThroughCountryCode);\n  \t  });\n  \t  if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {\n  \t    return false;\n  \t  }\n  \t  return true;\n  \t}\n\n  \t/**\n  \t * Check whether string has correct universal IBAN format\n  \t * The IBAN consists of up to 34 alphanumeric characters, as follows:\n  \t * Country Code using ISO 3166-1 alpha-2, two letters\n  \t * check digits, two digits and\n  \t * Basic Bank Account Number (BBAN), up to 30 alphanumeric characters.\n  \t * NOTE: Permitted IBAN characters are: digits [0-9] and the 26 latin alphabetic [A-Z]\n  \t *\n  \t * @param {string} str - string under validation\n  \t * @param {object} options - object to pass the countries to be either whitelisted or blacklisted\n  \t * @return {boolean}\n  \t */\n  \tfunction hasValidIbanFormat(str, options) {\n  \t  // Strip white spaces and hyphens\n  \t  var strippedStr = str.replace(/[\\s\\-]+/gi, '').toUpperCase();\n  \t  var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();\n  \t  var isoCountryCodeInIbanRegexCodeObject = isoCountryCode in ibanRegexThroughCountryCode;\n  \t  if (options.whitelist) {\n  \t    if (!hasOnlyValidCountryCodes(options.whitelist)) {\n  \t      return false;\n  \t    }\n  \t    var isoCountryCodeInWhiteList = (0, _includesArray.default)(options.whitelist, isoCountryCode);\n  \t    if (!isoCountryCodeInWhiteList) {\n  \t      return false;\n  \t    }\n  \t  }\n  \t  if (options.blacklist) {\n  \t    var isoCountryCodeInBlackList = (0, _includesArray.default)(options.blacklist, isoCountryCode);\n  \t    if (isoCountryCodeInBlackList) {\n  \t      return false;\n  \t    }\n  \t  }\n  \t  return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);\n  \t}\n\n  \t/**\n  \t   * Check whether string has valid IBAN Checksum\n  \t   * by performing basic mod-97 operation and\n  \t   * the remainder should equal 1\n  \t   * -- Start by rearranging the IBAN by moving the four initial characters to the end of the string\n  \t   * -- Replace each letter in the string with two digits, A -> 10, B = 11, Z = 35\n  \t   * -- Interpret the string as a decimal integer and\n  \t   * -- compute the remainder on division by 97 (mod 97)\n  \t   * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n  \t   *\n  \t   * @param {string} str\n  \t   * @return {boolean}\n  \t   */\n  \tfunction hasValidIbanChecksum(str) {\n  \t  var strippedStr = str.replace(/[^A-Z0-9]+/gi, '').toUpperCase(); // Keep only digits and A-Z latin alphabetic\n  \t  var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);\n  \t  var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function (char) {\n  \t    return char.charCodeAt(0) - 55;\n  \t  });\n  \t  var remainder = alphaCapsReplacedWithDigits.match(/\\d{1,7}/g).reduce(function (acc, value) {\n  \t    return Number(acc + value) % 97;\n  \t  }, '');\n  \t  return remainder === 1;\n  \t}\n  \tfunction isIBAN$1(str) {\n  \t  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  \t  (0, _assertString.default)(str);\n  \t  return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);\n  \t}\n  \tisIBAN.locales = Object.keys(ibanRegexThroughCountryCode);\n  \treturn isIBAN;\n  }\n\n  var isBIC = {exports: {}};\n\n  var isISO31661Alpha2 = {};\n\n  var hasRequiredIsISO31661Alpha2;\n\n  function requireIsISO31661Alpha2 () {\n  \tif (hasRequiredIsISO31661Alpha2) return isISO31661Alpha2;\n  \thasRequiredIsISO31661Alpha2 = 1;\n\n  \tObject.defineProperty(isISO31661Alpha2, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisISO31661Alpha2.CountryCodes = void 0;\n  \tisISO31661Alpha2.default = isISO31661Alpha2$1;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\n  \tvar validISO31661Alpha2CountriesCodes = new Set(['AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ', 'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ', 'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ', 'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ', 'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET', 'FI', 'FJ', 'FK', 'FM', 'FO', 'FR', 'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY', 'HK', 'HM', 'HN', 'HR', 'HT', 'HU', 'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT', 'JE', 'JM', 'JO', 'JP', 'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ', 'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY', 'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ', 'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ', 'OM', 'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY', 'QA', 'RE', 'RO', 'RS', 'RU', 'RW', 'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ', 'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ', 'UA', 'UG', 'UM', 'US', 'UY', 'UZ', 'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU', 'WF', 'WS', 'YE', 'YT', 'ZA', 'ZM', 'ZW']);\n  \tfunction isISO31661Alpha2$1(str) {\n  \t  (0, _assertString.default)(str);\n  \t  return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());\n  \t}\n  \tisISO31661Alpha2.CountryCodes = validISO31661Alpha2CountriesCodes;\n  \treturn isISO31661Alpha2;\n  }\n\n  var hasRequiredIsBIC;\n\n  function requireIsBIC () {\n  \tif (hasRequiredIsBIC) return isBIC.exports;\n  \thasRequiredIsBIC = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isBIC;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _isISO31661Alpha = requireIsISO31661Alpha2();\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t// https://en.wikipedia.org/wiki/ISO_9362\n  \t\tvar isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;\n  \t\tfunction isBIC(str) {\n  \t\t  (0, _assertString.default)(str);\n\n  \t\t  // toUpperCase() should be removed when a new major version goes out that changes\n  \t\t  // the regex to [A-Z] (per the spec).\n  \t\t  var countryCode = str.slice(4, 6).toUpperCase();\n  \t\t  if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== 'XK') {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return isBICReg.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isBIC, isBIC.exports));\n  \treturn isBIC.exports;\n  }\n\n  var isMD5 = {exports: {}};\n\n  var hasRequiredIsMD5;\n\n  function requireIsMD5 () {\n  \tif (hasRequiredIsMD5) return isMD5.exports;\n  \thasRequiredIsMD5 = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isMD5;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar md5 = /^[a-f0-9]{32}$/;\n  \t\tfunction isMD5(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return md5.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isMD5, isMD5.exports));\n  \treturn isMD5.exports;\n  }\n\n  var isHash = {exports: {}};\n\n  var hasRequiredIsHash;\n\n  function requireIsHash () {\n  \tif (hasRequiredIsHash) return isHash.exports;\n  \thasRequiredIsHash = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isHash;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar lengths = {\n  \t\t  md5: 32,\n  \t\t  md4: 32,\n  \t\t  sha1: 40,\n  \t\t  sha256: 64,\n  \t\t  sha384: 96,\n  \t\t  sha512: 128,\n  \t\t  ripemd128: 32,\n  \t\t  ripemd160: 40,\n  \t\t  tiger128: 32,\n  \t\t  tiger160: 40,\n  \t\t  tiger192: 48,\n  \t\t  crc32: 8,\n  \t\t  crc32b: 8\n  \t\t};\n  \t\tfunction isHash(str, algorithm) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var hash = new RegExp(\"^[a-fA-F0-9]{\".concat(lengths[algorithm], \"}$\"));\n  \t\t  return hash.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isHash, isHash.exports));\n  \treturn isHash.exports;\n  }\n\n  var isJWT = {exports: {}};\n\n  var isBase64 = {exports: {}};\n\n  var hasRequiredIsBase64;\n\n  function requireIsBase64 () {\n  \tif (hasRequiredIsBase64) return isBase64.exports;\n  \thasRequiredIsBase64 = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isBase64;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar base64WithPadding = /^[A-Za-z0-9+/]+={0,2}$/;\n  \t\tvar base64WithoutPadding = /^[A-Za-z0-9+/]+$/;\n  \t\tvar base64UrlWithPadding = /^[A-Za-z0-9_-]+={0,2}$/;\n  \t\tvar base64UrlWithoutPadding = /^[A-Za-z0-9_-]+$/;\n  \t\tfunction isBase64(str, options) {\n  \t\t  var _options;\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = (0, _merge.default)(options, {\n  \t\t    urlSafe: false,\n  \t\t    padding: !((_options = options) !== null && _options !== void 0 && _options.urlSafe)\n  \t\t  });\n  \t\t  if (str === '') return true;\n  \t\t  if (options.padding && str.length % 4 !== 0) return false;\n  \t\t  var regex;\n  \t\t  if (options.urlSafe) {\n  \t\t    regex = options.padding ? base64UrlWithPadding : base64UrlWithoutPadding;\n  \t\t  } else {\n  \t\t    regex = options.padding ? base64WithPadding : base64WithoutPadding;\n  \t\t  }\n  \t\t  return (!options.padding || str.length % 4 === 0) && regex.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isBase64, isBase64.exports));\n  \treturn isBase64.exports;\n  }\n\n  var hasRequiredIsJWT;\n\n  function requireIsJWT () {\n  \tif (hasRequiredIsJWT) return isJWT.exports;\n  \thasRequiredIsJWT = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isJWT;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _isBase = _interopRequireDefault(requireIsBase64());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction isJWT(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var dotSplit = str.split('.');\n  \t\t  var len = dotSplit.length;\n  \t\t  if (len !== 3) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return dotSplit.reduce(function (acc, currElem) {\n  \t\t    return acc && (0, _isBase.default)(currElem, {\n  \t\t      urlSafe: true\n  \t\t    });\n  \t\t  }, true);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isJWT, isJWT.exports));\n  \treturn isJWT.exports;\n  }\n\n  var isJSON = {exports: {}};\n\n  var hasRequiredIsJSON;\n\n  function requireIsJSON () {\n  \tif (hasRequiredIsJSON) return isJSON.exports;\n  \thasRequiredIsJSON = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isJSON;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _includesArray = _interopRequireDefault(requireIncludesArray());\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \t\tvar default_json_options = {\n  \t\t  allow_primitives: false\n  \t\t};\n  \t\tfunction isJSON(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  try {\n  \t\t    options = (0, _merge.default)(options, default_json_options);\n  \t\t    var primitives = [];\n  \t\t    if (options.allow_primitives) {\n  \t\t      primitives = [null, false, true];\n  \t\t    }\n  \t\t    var obj = JSON.parse(str);\n  \t\t    return (0, _includesArray.default)(primitives, obj) || !!obj && _typeof(obj) === 'object';\n  \t\t  } catch (e) {/* ignore */}\n  \t\t  return false;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isJSON, isJSON.exports));\n  \treturn isJSON.exports;\n  }\n\n  var isEmpty = {exports: {}};\n\n  var hasRequiredIsEmpty;\n\n  function requireIsEmpty () {\n  \tif (hasRequiredIsEmpty) return isEmpty.exports;\n  \thasRequiredIsEmpty = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isEmpty;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar default_is_empty_options = {\n  \t\t  ignore_whitespace: false\n  \t\t};\n  \t\tfunction isEmpty(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = (0, _merge.default)(options, default_is_empty_options);\n  \t\t  return (options.ignore_whitespace ? str.trim().length : str.length) === 0;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isEmpty, isEmpty.exports));\n  \treturn isEmpty.exports;\n  }\n\n  var isLength = {exports: {}};\n\n  var hasRequiredIsLength;\n\n  function requireIsLength () {\n  \tif (hasRequiredIsLength) return isLength.exports;\n  \thasRequiredIsLength = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isLength;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \t\t/* eslint-disable prefer-rest-params */\n  \t\tfunction isLength(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var min;\n  \t\t  var max;\n  \t\t  if (_typeof(options) === 'object') {\n  \t\t    min = options.min || 0;\n  \t\t    max = options.max;\n  \t\t  } else {\n  \t\t    // backwards compatibility: isLength(str, min [, max])\n  \t\t    min = arguments[1] || 0;\n  \t\t    max = arguments[2];\n  \t\t  }\n  \t\t  var presentationSequences = str.match(/[^\\uFE0F\\uFE0E][\\uFE0F\\uFE0E]/g) || [];\n  \t\t  var surrogatePairs = str.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g) || [];\n  \t\t  var len = str.length - presentationSequences.length - surrogatePairs.length;\n  \t\t  var isInsideRange = len >= min && (typeof max === 'undefined' || len <= max);\n  \t\t  if (isInsideRange && Array.isArray(options === null || options === void 0 ? void 0 : options.discreteLengths)) {\n  \t\t    return options.discreteLengths.some(function (discreteLen) {\n  \t\t      return discreteLen === len;\n  \t\t    });\n  \t\t  }\n  \t\t  return isInsideRange;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isLength, isLength.exports));\n  \treturn isLength.exports;\n  }\n\n  var isULID = {exports: {}};\n\n  var hasRequiredIsULID;\n\n  function requireIsULID () {\n  \tif (hasRequiredIsULID) return isULID.exports;\n  \thasRequiredIsULID = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isULID;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction isULID(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isULID, isULID.exports));\n  \treturn isULID.exports;\n  }\n\n  var isUUID = {exports: {}};\n\n  var hasRequiredIsUUID;\n\n  function requireIsUUID () {\n  \tif (hasRequiredIsUUID) return isUUID.exports;\n  \thasRequiredIsUUID = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isUUID;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar uuid = {\n  \t\t  1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n  \t\t  2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n  \t\t  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n  \t\t  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n  \t\t  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n  \t\t  6: /^[0-9A-F]{8}-[0-9A-F]{4}-6[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n  \t\t  7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n  \t\t  8: /^[0-9A-F]{8}-[0-9A-F]{4}-8[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n  \t\t  nil: /^00000000-0000-0000-0000-000000000000$/i,\n  \t\t  max: /^ffffffff-ffff-ffff-ffff-ffffffffffff$/i,\n  \t\t  loose: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,\n  \t\t  // From https://github.com/uuidjs/uuid/blob/main/src/regex.js\n  \t\t  all: /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i\n  \t\t};\n  \t\tfunction isUUID(str, version) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (version === undefined || version === null) {\n  \t\t    version = 'all';\n  \t\t  }\n  \t\t  return version in uuid ? uuid[version].test(str) : false;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isUUID, isUUID.exports));\n  \treturn isUUID.exports;\n  }\n\n  var isMongoId = {exports: {}};\n\n  var hasRequiredIsMongoId;\n\n  function requireIsMongoId () {\n  \tif (hasRequiredIsMongoId) return isMongoId.exports;\n  \thasRequiredIsMongoId = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isMongoId;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _isHexadecimal = _interopRequireDefault(requireIsHexadecimal());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction isMongoId(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return (0, _isHexadecimal.default)(str) && str.length === 24;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isMongoId, isMongoId.exports));\n  \treturn isMongoId.exports;\n  }\n\n  var isAfter = {exports: {}};\n\n  var hasRequiredIsAfter;\n\n  function requireIsAfter () {\n  \tif (hasRequiredIsAfter) return isAfter.exports;\n  \thasRequiredIsAfter = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isAfter;\n  \t\tvar _toDate = _interopRequireDefault(requireToDate());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \t\tfunction isAfter(date, options) {\n  \t\t  // For backwards compatibility:\n  \t\t  // isAfter(str [, date]), i.e. `options` could be used as argument for the legacy `date`\n  \t\t  var comparisonDate = (_typeof(options) === 'object' ? options.comparisonDate : options) || Date().toString();\n  \t\t  var comparison = (0, _toDate.default)(comparisonDate);\n  \t\t  var original = (0, _toDate.default)(date);\n  \t\t  return !!(original && comparison && original > comparison);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isAfter, isAfter.exports));\n  \treturn isAfter.exports;\n  }\n\n  var isBefore = {exports: {}};\n\n  var hasRequiredIsBefore;\n\n  function requireIsBefore () {\n  \tif (hasRequiredIsBefore) return isBefore.exports;\n  \thasRequiredIsBefore = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isBefore;\n  \t\tvar _toDate = _interopRequireDefault(requireToDate());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \t\tfunction isBefore(date, options) {\n  \t\t  // For backwards compatibility:\n  \t\t  // isBefore(str [, date]), i.e. `options` could be used as argument for the legacy `date`\n  \t\t  var comparisonDate = (_typeof(options) === 'object' ? options.comparisonDate : options) || Date().toString();\n  \t\t  var comparison = (0, _toDate.default)(comparisonDate);\n  \t\t  var original = (0, _toDate.default)(date);\n  \t\t  return !!(original && comparison && original < comparison);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isBefore, isBefore.exports));\n  \treturn isBefore.exports;\n  }\n\n  var isIn = {exports: {}};\n\n  var hasRequiredIsIn;\n\n  function requireIsIn () {\n  \tif (hasRequiredIsIn) return isIn.exports;\n  \thasRequiredIsIn = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isIn;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _toString = _interopRequireDefault(requireToString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \t\tfunction isIn(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var i;\n  \t\t  if (Object.prototype.toString.call(options) === '[object Array]') {\n  \t\t    var array = [];\n  \t\t    for (i in options) {\n  \t\t      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n  \t\t      // istanbul ignore else\n  \t\t      if ({}.hasOwnProperty.call(options, i)) {\n  \t\t        array[i] = (0, _toString.default)(options[i]);\n  \t\t      }\n  \t\t    }\n  \t\t    return array.indexOf(str) >= 0;\n  \t\t  } else if (_typeof(options) === 'object') {\n  \t\t    return options.hasOwnProperty(str);\n  \t\t  } else if (options && typeof options.indexOf === 'function') {\n  \t\t    return options.indexOf(str) >= 0;\n  \t\t  }\n  \t\t  return false;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isIn, isIn.exports));\n  \treturn isIn.exports;\n  }\n\n  var isLuhnNumber = {exports: {}};\n\n  var hasRequiredIsLuhnNumber;\n\n  function requireIsLuhnNumber () {\n  \tif (hasRequiredIsLuhnNumber) return isLuhnNumber.exports;\n  \thasRequiredIsLuhnNumber = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isLuhnNumber;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction isLuhnNumber(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var sanitized = str.replace(/[- ]+/g, '');\n  \t\t  var sum = 0;\n  \t\t  var digit;\n  \t\t  var tmpNum;\n  \t\t  var shouldDouble;\n  \t\t  for (var i = sanitized.length - 1; i >= 0; i--) {\n  \t\t    digit = sanitized.substring(i, i + 1);\n  \t\t    tmpNum = parseInt(digit, 10);\n  \t\t    if (shouldDouble) {\n  \t\t      tmpNum *= 2;\n  \t\t      if (tmpNum >= 10) {\n  \t\t        sum += tmpNum % 10 + 1;\n  \t\t      } else {\n  \t\t        sum += tmpNum;\n  \t\t      }\n  \t\t    } else {\n  \t\t      sum += tmpNum;\n  \t\t    }\n  \t\t    shouldDouble = !shouldDouble;\n  \t\t  }\n  \t\t  return !!(sum % 10 === 0 ? sanitized : false);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isLuhnNumber, isLuhnNumber.exports));\n  \treturn isLuhnNumber.exports;\n  }\n\n  var isCreditCard = {exports: {}};\n\n  var hasRequiredIsCreditCard;\n\n  function requireIsCreditCard () {\n  \tif (hasRequiredIsCreditCard) return isCreditCard.exports;\n  \thasRequiredIsCreditCard = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isCreditCard;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _isLuhnNumber = _interopRequireDefault(requireIsLuhnNumber());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar cards = {\n  \t\t  amex: /^3[47][0-9]{13}$/,\n  \t\t  dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,\n  \t\t  discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,\n  \t\t  jcb: /^(?:2131|1800|35\\d{3})\\d{11}$/,\n  \t\t  mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,\n  \t\t  // /^[25][1-7][0-9]{14}$/;\n  \t\t  unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,\n  \t\t  visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/\n  \t\t};\n  \t\tvar allCards = function () {\n  \t\t  var tmpCardsArray = [];\n  \t\t  for (var cardProvider in cards) {\n  \t\t    // istanbul ignore else\n  \t\t    if (cards.hasOwnProperty(cardProvider)) {\n  \t\t      tmpCardsArray.push(cards[cardProvider]);\n  \t\t    }\n  \t\t  }\n  \t\t  return tmpCardsArray;\n  \t\t}();\n  \t\tfunction isCreditCard(card) {\n  \t\t  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  \t\t  (0, _assertString.default)(card);\n  \t\t  var provider = options.provider;\n  \t\t  var sanitized = card.replace(/[- ]+/g, '');\n  \t\t  if (provider && provider.toLowerCase() in cards) {\n  \t\t    // specific provider in the list\n  \t\t    if (!cards[provider.toLowerCase()].test(sanitized)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  } else if (provider && !(provider.toLowerCase() in cards)) {\n  \t\t    /* specific provider not in the list */\n  \t\t    throw new Error(\"\".concat(provider, \" is not a valid credit card provider.\"));\n  \t\t  } else if (!allCards.some(function (cardProvider) {\n  \t\t    return cardProvider.test(sanitized);\n  \t\t  })) {\n  \t\t    // no specific provider\n  \t\t    return false;\n  \t\t  }\n  \t\t  return (0, _isLuhnNumber.default)(card);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isCreditCard, isCreditCard.exports));\n  \treturn isCreditCard.exports;\n  }\n\n  var isIdentityCard = {exports: {}};\n\n  var hasRequiredIsIdentityCard;\n\n  function requireIsIdentityCard () {\n  \tif (hasRequiredIsIdentityCard) return isIdentityCard.exports;\n  \thasRequiredIsIdentityCard = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isIdentityCard;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _includesArray = _interopRequireDefault(requireIncludesArray());\n  \t\tvar _isInt = _interopRequireDefault(requireIsInt());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar validators = {\n  \t\t  PL: function PL(str) {\n  \t\t    (0, _assertString.default)(str);\n  \t\t    var weightOfDigits = {\n  \t\t      1: 1,\n  \t\t      2: 3,\n  \t\t      3: 7,\n  \t\t      4: 9,\n  \t\t      5: 1,\n  \t\t      6: 3,\n  \t\t      7: 7,\n  \t\t      8: 9,\n  \t\t      9: 1,\n  \t\t      10: 3,\n  \t\t      11: 0\n  \t\t    };\n  \t\t    if (str != null && str.length === 11 && (0, _isInt.default)(str, {\n  \t\t      allow_leading_zeroes: true\n  \t\t    })) {\n  \t\t      var digits = str.split('').slice(0, -1);\n  \t\t      var sum = digits.reduce(function (acc, digit, index) {\n  \t\t        return acc + Number(digit) * weightOfDigits[index + 1];\n  \t\t      }, 0);\n  \t\t      var modulo = sum % 10;\n  \t\t      var lastDigit = Number(str.charAt(str.length - 1));\n  \t\t      if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {\n  \t\t        return true;\n  \t\t      }\n  \t\t    }\n  \t\t    return false;\n  \t\t  },\n  \t\t  ES: function ES(str) {\n  \t\t    (0, _assertString.default)(str);\n  \t\t    var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;\n  \t\t    var charsValue = {\n  \t\t      X: 0,\n  \t\t      Y: 1,\n  \t\t      Z: 2\n  \t\t    };\n  \t\t    var controlDigits = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E'];\n\n  \t\t    // sanitize user input\n  \t\t    var sanitized = str.trim().toUpperCase();\n\n  \t\t    // validate the data structure\n  \t\t    if (!DNI.test(sanitized)) {\n  \t\t      return false;\n  \t\t    }\n\n  \t\t    // validate the control digit\n  \t\t    var number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function (char) {\n  \t\t      return charsValue[char];\n  \t\t    });\n  \t\t    return sanitized.endsWith(controlDigits[number % 23]);\n  \t\t  },\n  \t\t  FI: function FI(str) {\n  \t\t    // https://dvv.fi/en/personal-identity-code#:~:text=control%20character%20for%20a-,personal,-identity%20code%20calculated\n  \t\t    (0, _assertString.default)(str);\n  \t\t    if (str.length !== 11) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (!str.match(/^\\d{6}[\\-A\\+]\\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    var checkDigits = '0123456789ABCDEFHJKLMNPRSTUVWXY';\n  \t\t    var idAsNumber = parseInt(str.slice(0, 6), 10) * 1000 + parseInt(str.slice(7, 10), 10);\n  \t\t    var remainder = idAsNumber % 31;\n  \t\t    var checkDigit = checkDigits[remainder];\n  \t\t    return checkDigit === str.slice(10, 11);\n  \t\t  },\n  \t\t  IN: function IN(str) {\n  \t\t    var DNI = /^[1-9]\\d{3}\\s?\\d{4}\\s?\\d{4}$/;\n\n  \t\t    // multiplication table\n  \t\t    var d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];\n\n  \t\t    // permutation table\n  \t\t    var p = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];\n\n  \t\t    // sanitize user input\n  \t\t    var sanitized = str.trim();\n\n  \t\t    // validate the data structure\n  \t\t    if (!DNI.test(sanitized)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    var c = 0;\n  \t\t    var invertedArray = sanitized.replace(/\\s/g, '').split('').map(Number).reverse();\n  \t\t    invertedArray.forEach(function (val, i) {\n  \t\t      c = d[c][p[i % 8][val]];\n  \t\t    });\n  \t\t    return c === 0;\n  \t\t  },\n  \t\t  IR: function IR(str) {\n  \t\t    if (!str.match(/^\\d{10}$/)) return false;\n  \t\t    str = \"0000\".concat(str).slice(str.length - 6);\n  \t\t    if (parseInt(str.slice(3, 9), 10) === 0) return false;\n  \t\t    var lastNumber = parseInt(str.slice(9, 10), 10);\n  \t\t    var sum = 0;\n  \t\t    for (var i = 0; i < 9; i++) {\n  \t\t      sum += parseInt(str.slice(i, i + 1), 10) * (10 - i);\n  \t\t    }\n  \t\t    sum %= 11;\n  \t\t    return sum < 2 && lastNumber === sum || sum >= 2 && lastNumber === 11 - sum;\n  \t\t  },\n  \t\t  IT: function IT(str) {\n  \t\t    if (str.length !== 9) return false;\n  \t\t    if (str === 'CA00000AA') return false; // https://it.wikipedia.org/wiki/Carta_d%27identit%C3%A0_elettronica_italiana\n  \t\t    return str.search(/C[A-Z]\\d{5}[A-Z]{2}/i) > -1;\n  \t\t  },\n  \t\t  NO: function NO(str) {\n  \t\t    var sanitized = str.trim();\n  \t\t    if (isNaN(Number(sanitized))) return false;\n  \t\t    if (sanitized.length !== 11) return false;\n  \t\t    if (sanitized === '00000000000') return false;\n\n  \t\t    // https://no.wikipedia.org/wiki/F%C3%B8dselsnummer\n  \t\t    var f = sanitized.split('').map(Number);\n  \t\t    var k1 = (11 - (3 * f[0] + 7 * f[1] + 6 * f[2] + 1 * f[3] + 8 * f[4] + 9 * f[5] + 4 * f[6] + 5 * f[7] + 2 * f[8]) % 11) % 11;\n  \t\t    var k2 = (11 - (5 * f[0] + 4 * f[1] + 3 * f[2] + 2 * f[3] + 7 * f[4] + 6 * f[5] + 5 * f[6] + 4 * f[7] + 3 * f[8] + 2 * k1) % 11) % 11;\n  \t\t    if (k1 !== f[9] || k2 !== f[10]) return false;\n  \t\t    return true;\n  \t\t  },\n  \t\t  TH: function TH(str) {\n  \t\t    if (!str.match(/^[1-8]\\d{12}$/)) return false;\n\n  \t\t    // validate check digit\n  \t\t    var sum = 0;\n  \t\t    for (var i = 0; i < 12; i++) {\n  \t\t      sum += parseInt(str[i], 10) * (13 - i);\n  \t\t    }\n  \t\t    return str[12] === ((11 - sum % 11) % 10).toString();\n  \t\t  },\n  \t\t  LK: function LK(str) {\n  \t\t    var old_nic = /^[1-9]\\d{8}[vx]$/i;\n  \t\t    var new_nic = /^[1-9]\\d{11}$/i;\n  \t\t    if (str.length === 10 && old_nic.test(str)) return true;else if (str.length === 12 && new_nic.test(str)) return true;\n  \t\t    return false;\n  \t\t  },\n  \t\t  'he-IL': function heIL(str) {\n  \t\t    var DNI = /^\\d{9}$/;\n\n  \t\t    // sanitize user input\n  \t\t    var sanitized = str.trim();\n\n  \t\t    // validate the data structure\n  \t\t    if (!DNI.test(sanitized)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    var id = sanitized;\n  \t\t    var sum = 0,\n  \t\t      incNum;\n  \t\t    for (var i = 0; i < id.length; i++) {\n  \t\t      incNum = Number(id[i]) * (i % 2 + 1); // Multiply number by 1 or 2\n  \t\t      sum += incNum > 9 ? incNum - 9 : incNum; // Sum the digits up and add to total\n  \t\t    }\n  \t\t    return sum % 10 === 0;\n  \t\t  },\n  \t\t  'ar-LY': function arLY(str) {\n  \t\t    // Libya National Identity Number NIN is 12 digits, the first digit is either 1 or 2\n  \t\t    var NIN = /^(1|2)\\d{11}$/;\n\n  \t\t    // sanitize user input\n  \t\t    var sanitized = str.trim();\n\n  \t\t    // validate the data structure\n  \t\t    if (!NIN.test(sanitized)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    return true;\n  \t\t  },\n  \t\t  'ar-TN': function arTN(str) {\n  \t\t    var DNI = /^\\d{8}$/;\n\n  \t\t    // sanitize user input\n  \t\t    var sanitized = str.trim();\n\n  \t\t    // validate the data structure\n  \t\t    if (!DNI.test(sanitized)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    return true;\n  \t\t  },\n  \t\t  'zh-CN': function zhCN(str) {\n  \t\t    var provincesAndCities = ['11',\n  \t\t    // 北京\n  \t\t    '12',\n  \t\t    // 天津\n  \t\t    '13',\n  \t\t    // 河北\n  \t\t    '14',\n  \t\t    // 山西\n  \t\t    '15',\n  \t\t    // 内蒙古\n  \t\t    '21',\n  \t\t    // 辽宁\n  \t\t    '22',\n  \t\t    // 吉林\n  \t\t    '23',\n  \t\t    // 黑龙江\n  \t\t    '31',\n  \t\t    // 上海\n  \t\t    '32',\n  \t\t    // 江苏\n  \t\t    '33',\n  \t\t    // 浙江\n  \t\t    '34',\n  \t\t    // 安徽\n  \t\t    '35',\n  \t\t    // 福建\n  \t\t    '36',\n  \t\t    // 江西\n  \t\t    '37',\n  \t\t    // 山东\n  \t\t    '41',\n  \t\t    // 河南\n  \t\t    '42',\n  \t\t    // 湖北\n  \t\t    '43',\n  \t\t    // 湖南\n  \t\t    '44',\n  \t\t    // 广东\n  \t\t    '45',\n  \t\t    // 广西\n  \t\t    '46',\n  \t\t    // 海南\n  \t\t    '50',\n  \t\t    // 重庆\n  \t\t    '51',\n  \t\t    // 四川\n  \t\t    '52',\n  \t\t    // 贵州\n  \t\t    '53',\n  \t\t    // 云南\n  \t\t    '54',\n  \t\t    // 西藏\n  \t\t    '61',\n  \t\t    // 陕西\n  \t\t    '62',\n  \t\t    // 甘肃\n  \t\t    '63',\n  \t\t    // 青海\n  \t\t    '64',\n  \t\t    // 宁夏\n  \t\t    '65',\n  \t\t    // 新疆\n  \t\t    '71',\n  \t\t    // 台湾\n  \t\t    '81',\n  \t\t    // 香港\n  \t\t    '82',\n  \t\t    // 澳门\n  \t\t    '91' // 国外\n  \t\t    ];\n  \t\t    var powers = ['7', '9', '10', '5', '8', '4', '2', '1', '6', '3', '7', '9', '10', '5', '8', '4', '2'];\n  \t\t    var parityBit = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];\n  \t\t    var checkAddressCode = function checkAddressCode(addressCode) {\n  \t\t      return (0, _includesArray.default)(provincesAndCities, addressCode);\n  \t\t    };\n  \t\t    var checkBirthDayCode = function checkBirthDayCode(birDayCode) {\n  \t\t      var yyyy = parseInt(birDayCode.substring(0, 4), 10);\n  \t\t      var mm = parseInt(birDayCode.substring(4, 6), 10);\n  \t\t      var dd = parseInt(birDayCode.substring(6), 10);\n  \t\t      var xdata = new Date(yyyy, mm - 1, dd);\n  \t\t      if (xdata > new Date()) {\n  \t\t        return false;\n  \t\t        // eslint-disable-next-line max-len\n  \t\t      } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd) {\n  \t\t        return true;\n  \t\t      }\n  \t\t      return false;\n  \t\t    };\n  \t\t    var getParityBit = function getParityBit(idCardNo) {\n  \t\t      var id17 = idCardNo.substring(0, 17);\n  \t\t      var power = 0;\n  \t\t      for (var i = 0; i < 17; i++) {\n  \t\t        power += parseInt(id17.charAt(i), 10) * parseInt(powers[i], 10);\n  \t\t      }\n  \t\t      var mod = power % 11;\n  \t\t      return parityBit[mod];\n  \t\t    };\n  \t\t    var checkParityBit = function checkParityBit(idCardNo) {\n  \t\t      return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();\n  \t\t    };\n  \t\t    var check15IdCardNo = function check15IdCardNo(idCardNo) {\n  \t\t      var check = /^[1-9]\\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\\d{3}$/.test(idCardNo);\n  \t\t      if (!check) return false;\n  \t\t      var addressCode = idCardNo.substring(0, 2);\n  \t\t      check = checkAddressCode(addressCode);\n  \t\t      if (!check) return false;\n  \t\t      var birDayCode = \"19\".concat(idCardNo.substring(6, 12));\n  \t\t      check = checkBirthDayCode(birDayCode);\n  \t\t      if (!check) return false;\n  \t\t      return true;\n  \t\t    };\n  \t\t    var check18IdCardNo = function check18IdCardNo(idCardNo) {\n  \t\t      var check = /^[1-9]\\d{5}[1-9]\\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\\d{3}(\\d|x|X)$/.test(idCardNo);\n  \t\t      if (!check) return false;\n  \t\t      var addressCode = idCardNo.substring(0, 2);\n  \t\t      check = checkAddressCode(addressCode);\n  \t\t      if (!check) return false;\n  \t\t      var birDayCode = idCardNo.substring(6, 14);\n  \t\t      check = checkBirthDayCode(birDayCode);\n  \t\t      if (!check) return false;\n  \t\t      return checkParityBit(idCardNo);\n  \t\t    };\n  \t\t    var checkIdCardNo = function checkIdCardNo(idCardNo) {\n  \t\t      var check = /^\\d{15}|(\\d{17}(\\d|x|X))$/.test(idCardNo);\n  \t\t      if (!check) return false;\n  \t\t      if (idCardNo.length === 15) {\n  \t\t        return check15IdCardNo(idCardNo);\n  \t\t      }\n  \t\t      return check18IdCardNo(idCardNo);\n  \t\t    };\n  \t\t    return checkIdCardNo(str);\n  \t\t  },\n  \t\t  'zh-HK': function zhHK(str) {\n  \t\t    // sanitize user input\n  \t\t    str = str.trim();\n\n  \t\t    // HKID number starts with 1 or 2 letters, followed by 6 digits,\n  \t\t    // then a checksum contained in square / round brackets or nothing\n  \t\t    var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\\([0-9A]\\))|(\\[[0-9A]\\])|([0-9A]))$/;\n  \t\t    var regexIsDigit = /^[0-9]$/;\n\n  \t\t    // convert the user input to all uppercase and apply regex\n  \t\t    str = str.toUpperCase();\n  \t\t    if (!regexHKID.test(str)) return false;\n  \t\t    str = str.replace(/\\[|\\]|\\(|\\)/g, '');\n  \t\t    if (str.length === 8) str = \"3\".concat(str);\n  \t\t    var checkSumVal = 0;\n  \t\t    for (var i = 0; i <= 7; i++) {\n  \t\t      var convertedChar = void 0;\n  \t\t      if (!regexIsDigit.test(str[i])) convertedChar = (str[i].charCodeAt(0) - 55) % 11;else convertedChar = str[i];\n  \t\t      checkSumVal += convertedChar * (9 - i);\n  \t\t    }\n  \t\t    checkSumVal %= 11;\n  \t\t    var checkSumConverted;\n  \t\t    if (checkSumVal === 0) checkSumConverted = '0';else if (checkSumVal === 1) checkSumConverted = 'A';else checkSumConverted = String(11 - checkSumVal);\n  \t\t    if (checkSumConverted === str[str.length - 1]) return true;\n  \t\t    return false;\n  \t\t  },\n  \t\t  'zh-TW': function zhTW(str) {\n  \t\t    var ALPHABET_CODES = {\n  \t\t      A: 10,\n  \t\t      B: 11,\n  \t\t      C: 12,\n  \t\t      D: 13,\n  \t\t      E: 14,\n  \t\t      F: 15,\n  \t\t      G: 16,\n  \t\t      H: 17,\n  \t\t      I: 34,\n  \t\t      J: 18,\n  \t\t      K: 19,\n  \t\t      L: 20,\n  \t\t      M: 21,\n  \t\t      N: 22,\n  \t\t      O: 35,\n  \t\t      P: 23,\n  \t\t      Q: 24,\n  \t\t      R: 25,\n  \t\t      S: 26,\n  \t\t      T: 27,\n  \t\t      U: 28,\n  \t\t      V: 29,\n  \t\t      W: 32,\n  \t\t      X: 30,\n  \t\t      Y: 31,\n  \t\t      Z: 33\n  \t\t    };\n  \t\t    var sanitized = str.trim().toUpperCase();\n  \t\t    if (!/^[A-Z][0-9]{9}$/.test(sanitized)) return false;\n  \t\t    return Array.from(sanitized).reduce(function (sum, number, index) {\n  \t\t      if (index === 0) {\n  \t\t        var code = ALPHABET_CODES[number];\n  \t\t        return code % 10 * 9 + Math.floor(code / 10);\n  \t\t      }\n  \t\t      if (index === 9) {\n  \t\t        return (10 - sum % 10 - Number(number)) % 10 === 0;\n  \t\t      }\n  \t\t      return sum + Number(number) * (9 - index);\n  \t\t    }, 0);\n  \t\t  },\n  \t\t  PK: function PK(str) {\n  \t\t    // Pakistani National Identity Number CNIC is 13 digits\n  \t\t    var CNIC = /^[1-7][0-9]{4}-[0-9]{7}-[1-9]$/;\n\n  \t\t    // sanitize user input\n  \t\t    var sanitized = str.trim();\n\n  \t\t    // validate the data structure\n  \t\t    return CNIC.test(sanitized);\n  \t\t  }\n  \t\t};\n  \t\tfunction isIdentityCard(str, locale) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (locale in validators) {\n  \t\t    return validators[locale](str);\n  \t\t  } else if (locale === 'any') {\n  \t\t    for (var key in validators) {\n  \t\t      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n  \t\t      // istanbul ignore else\n  \t\t      if (validators.hasOwnProperty(key)) {\n  \t\t        var validator = validators[key];\n  \t\t        if (validator(str)) {\n  \t\t          return true;\n  \t\t        }\n  \t\t      }\n  \t\t    }\n  \t\t    return false;\n  \t\t  }\n  \t\t  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isIdentityCard, isIdentityCard.exports));\n  \treturn isIdentityCard.exports;\n  }\n\n  var isEAN = {exports: {}};\n\n  var hasRequiredIsEAN;\n\n  function requireIsEAN () {\n  \tif (hasRequiredIsEAN) return isEAN.exports;\n  \thasRequiredIsEAN = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isEAN;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t/**\n  \t\t * The most commonly used EAN standard is\n  \t\t * the thirteen-digit EAN-13, while the\n  \t\t * less commonly used 8-digit EAN-8 barcode was\n  \t\t * introduced for use on small packages.\n  \t\t * Also EAN/UCC-14 is used for Grouping of individual\n  \t\t * trade items above unit level(Intermediate, Carton or Pallet).\n  \t\t * For more info about EAN-14 checkout: https://www.gtin.info/itf-14-barcodes/\n  \t\t * EAN consists of:\n  \t\t * GS1 prefix, manufacturer code, product code and check digit\n  \t\t * Reference: https://en.wikipedia.org/wiki/International_Article_Number\n  \t\t * Reference: https://www.gtin.info/\n  \t\t */\n\n  \t\t/**\n  \t\t * Define EAN Lengths; 8 for EAN-8; 13 for EAN-13; 14 for EAN-14\n  \t\t * and Regular Expression for valid EANs (EAN-8, EAN-13, EAN-14),\n  \t\t * with exact numeric matching of 8 or 13 or 14 digits [0-9]\n  \t\t */\n  \t\tvar LENGTH_EAN_8 = 8;\n  \t\tvar LENGTH_EAN_14 = 14;\n  \t\tvar validEanRegex = /^(\\d{8}|\\d{13}|\\d{14})$/;\n\n  \t\t/**\n  \t\t * Get position weight given:\n  \t\t * EAN length and digit index/position\n  \t\t *\n  \t\t * @param {number} length\n  \t\t * @param {number} index\n  \t\t * @return {number}\n  \t\t */\n  \t\tfunction getPositionWeightThroughLengthAndIndex(length, index) {\n  \t\t  if (length === LENGTH_EAN_8 || length === LENGTH_EAN_14) {\n  \t\t    return index % 2 === 0 ? 3 : 1;\n  \t\t  }\n  \t\t  return index % 2 === 0 ? 1 : 3;\n  \t\t}\n\n  \t\t/**\n  \t\t * Calculate EAN Check Digit\n  \t\t * Reference: https://en.wikipedia.org/wiki/International_Article_Number#Calculation_of_checksum_digit\n  \t\t *\n  \t\t * @param {string} ean\n  \t\t * @return {number}\n  \t\t */\n  \t\tfunction calculateCheckDigit(ean) {\n  \t\t  var checksum = ean.slice(0, -1).split('').map(function (char, index) {\n  \t\t    return Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index);\n  \t\t  }).reduce(function (acc, partialSum) {\n  \t\t    return acc + partialSum;\n  \t\t  }, 0);\n  \t\t  var remainder = 10 - checksum % 10;\n  \t\t  return remainder < 10 ? remainder : 0;\n  \t\t}\n\n  \t\t/**\n  \t\t * Check if string is valid EAN:\n  \t\t * Matches EAN-8/EAN-13/EAN-14 regex\n  \t\t * Has valid check digit.\n  \t\t *\n  \t\t * @param {string} str\n  \t\t * @return {boolean}\n  \t\t */\n  \t\tfunction isEAN(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var actualCheckDigit = Number(str.slice(-1));\n  \t\t  return validEanRegex.test(str) && actualCheckDigit === calculateCheckDigit(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isEAN, isEAN.exports));\n  \treturn isEAN.exports;\n  }\n\n  var isISIN = {exports: {}};\n\n  var hasRequiredIsISIN;\n\n  function requireIsISIN () {\n  \tif (hasRequiredIsISIN) return isISIN.exports;\n  \thasRequiredIsISIN = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isISIN;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;\n\n  \t\t// this link details how the check digit is calculated:\n  \t\t// https://www.isin.org/isin-format/. it is a little bit\n  \t\t// odd in that it works with digits, not numbers. in order\n  \t\t// to make only one pass through the ISIN characters, the\n  \t\t// each alpha character is handled as 2 characters within\n  \t\t// the loop.\n\n  \t\tfunction isISIN(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (!isin.test(str)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var double = true;\n  \t\t  var sum = 0;\n  \t\t  // convert values\n  \t\t  for (var i = str.length - 2; i >= 0; i--) {\n  \t\t    if (str[i] >= 'A' && str[i] <= 'Z') {\n  \t\t      var value = str[i].charCodeAt(0) - 55;\n  \t\t      var lo = value % 10;\n  \t\t      var hi = Math.trunc(value / 10);\n  \t\t      // letters have two digits, so handle the low order\n  \t\t      // and high order digits separately.\n  \t\t      for (var _i = 0, _arr = [lo, hi]; _i < _arr.length; _i++) {\n  \t\t        var digit = _arr[_i];\n  \t\t        if (double) {\n  \t\t          if (digit >= 5) {\n  \t\t            sum += 1 + (digit - 5) * 2;\n  \t\t          } else {\n  \t\t            sum += digit * 2;\n  \t\t          }\n  \t\t        } else {\n  \t\t          sum += digit;\n  \t\t        }\n  \t\t        double = !double;\n  \t\t      }\n  \t\t    } else {\n  \t\t      var _digit = str[i].charCodeAt(0) - '0'.charCodeAt(0);\n  \t\t      if (double) {\n  \t\t        if (_digit >= 5) {\n  \t\t          sum += 1 + (_digit - 5) * 2;\n  \t\t        } else {\n  \t\t          sum += _digit * 2;\n  \t\t        }\n  \t\t      } else {\n  \t\t        sum += _digit;\n  \t\t      }\n  \t\t      double = !double;\n  \t\t    }\n  \t\t  }\n  \t\t  var check = Math.trunc((sum + 9) / 10) * 10 - sum;\n  \t\t  return +str[str.length - 1] === check;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isISIN, isISIN.exports));\n  \treturn isISIN.exports;\n  }\n\n  var isISBN = {exports: {}};\n\n  var hasRequiredIsISBN;\n\n  function requireIsISBN () {\n  \tif (hasRequiredIsISBN) return isISBN.exports;\n  \thasRequiredIsISBN = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isISBN;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;\n  \t\tvar possibleIsbn13 = /^(?:[0-9]{13})$/;\n  \t\tvar factor = [1, 3];\n  \t\tfunction isISBN(isbn, options) {\n  \t\t  (0, _assertString.default)(isbn);\n\n  \t\t  // For backwards compatibility:\n  \t\t  // isISBN(str [, version]), i.e. `options` could be used as argument for the legacy `version`\n  \t\t  var version = String((options === null || options === void 0 ? void 0 : options.version) || options);\n  \t\t  if (!(options !== null && options !== void 0 && options.version || options)) {\n  \t\t    return isISBN(isbn, {\n  \t\t      version: 10\n  \t\t    }) || isISBN(isbn, {\n  \t\t      version: 13\n  \t\t    });\n  \t\t  }\n  \t\t  var sanitizedIsbn = isbn.replace(/[\\s-]+/g, '');\n  \t\t  var checksum = 0;\n  \t\t  if (version === '10') {\n  \t\t    if (!possibleIsbn10.test(sanitizedIsbn)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    for (var i = 0; i < version - 1; i++) {\n  \t\t      checksum += (i + 1) * sanitizedIsbn.charAt(i);\n  \t\t    }\n  \t\t    if (sanitizedIsbn.charAt(9) === 'X') {\n  \t\t      checksum += 10 * 10;\n  \t\t    } else {\n  \t\t      checksum += 10 * sanitizedIsbn.charAt(9);\n  \t\t    }\n  \t\t    if (checksum % 11 === 0) {\n  \t\t      return true;\n  \t\t    }\n  \t\t  } else if (version === '13') {\n  \t\t    if (!possibleIsbn13.test(sanitizedIsbn)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    for (var _i = 0; _i < 12; _i++) {\n  \t\t      checksum += factor[_i % 2] * sanitizedIsbn.charAt(_i);\n  \t\t    }\n  \t\t    if (sanitizedIsbn.charAt(12) - (10 - checksum % 10) % 10 === 0) {\n  \t\t      return true;\n  \t\t    }\n  \t\t  }\n  \t\t  return false;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isISBN, isISBN.exports));\n  \treturn isISBN.exports;\n  }\n\n  var isISSN = {exports: {}};\n\n  var hasRequiredIsISSN;\n\n  function requireIsISSN () {\n  \tif (hasRequiredIsISSN) return isISSN.exports;\n  \thasRequiredIsISSN = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isISSN;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar issn = '^\\\\d{4}-?\\\\d{3}[\\\\dX]$';\n  \t\tfunction isISSN(str) {\n  \t\t  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var testIssn = issn;\n  \t\t  testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;\n  \t\t  testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');\n  \t\t  if (!testIssn.test(str)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var digits = str.replace('-', '').toUpperCase();\n  \t\t  var checksum = 0;\n  \t\t  for (var i = 0; i < digits.length; i++) {\n  \t\t    var digit = digits[i];\n  \t\t    checksum += (digit === 'X' ? 10 : +digit) * (8 - i);\n  \t\t  }\n  \t\t  return checksum % 11 === 0;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isISSN, isISSN.exports));\n  \treturn isISSN.exports;\n  }\n\n  var isTaxID = {exports: {}};\n\n  var algorithms = {};\n\n  var hasRequiredAlgorithms;\n\n  function requireAlgorithms () {\n  \tif (hasRequiredAlgorithms) return algorithms;\n  \thasRequiredAlgorithms = 1;\n\n  \tObject.defineProperty(algorithms, \"__esModule\", {\n  \t  value: true\n  \t});\n  \talgorithms.iso7064Check = iso7064Check;\n  \talgorithms.luhnCheck = luhnCheck;\n  \talgorithms.reverseMultiplyAndSum = reverseMultiplyAndSum;\n  \talgorithms.verhoeffCheck = verhoeffCheck;\n  \t/**\n  \t * Algorithmic validation functions\n  \t * May be used as is or implemented in the workflow of other validators.\n  \t */\n\n  \t/*\n  \t * ISO 7064 validation function\n  \t * Called with a string of numbers (incl. check digit)\n  \t * to validate according to ISO 7064 (MOD 11, 10).\n  \t */\n  \tfunction iso7064Check(str) {\n  \t  var checkvalue = 10;\n  \t  for (var i = 0; i < str.length - 1; i++) {\n  \t    checkvalue = (parseInt(str[i], 10) + checkvalue) % 10 === 0 ? 10 * 2 % 11 : (parseInt(str[i], 10) + checkvalue) % 10 * 2 % 11;\n  \t  }\n  \t  checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;\n  \t  return checkvalue === parseInt(str[10], 10);\n  \t}\n\n  \t/*\n  \t * Luhn (mod 10) validation function\n  \t * Called with a string of numbers (incl. check digit)\n  \t * to validate according to the Luhn algorithm.\n  \t */\n  \tfunction luhnCheck(str) {\n  \t  var checksum = 0;\n  \t  var second = false;\n  \t  for (var i = str.length - 1; i >= 0; i--) {\n  \t    if (second) {\n  \t      var product = parseInt(str[i], 10) * 2;\n  \t      if (product > 9) {\n  \t        // sum digits of product and add to checksum\n  \t        checksum += product.toString().split('').map(function (a) {\n  \t          return parseInt(a, 10);\n  \t        }).reduce(function (a, b) {\n  \t          return a + b;\n  \t        }, 0);\n  \t      } else {\n  \t        checksum += product;\n  \t      }\n  \t    } else {\n  \t      checksum += parseInt(str[i], 10);\n  \t    }\n  \t    second = !second;\n  \t  }\n  \t  return checksum % 10 === 0;\n  \t}\n\n  \t/*\n  \t * Reverse TIN multiplication and summation helper function\n  \t * Called with an array of single-digit integers and a base multiplier\n  \t * to calculate the sum of the digits multiplied in reverse.\n  \t * Normally used in variations of MOD 11 algorithmic checks.\n  \t */\n  \tfunction reverseMultiplyAndSum(digits, base) {\n  \t  var total = 0;\n  \t  for (var i = 0; i < digits.length; i++) {\n  \t    total += digits[i] * (base - i);\n  \t  }\n  \t  return total;\n  \t}\n\n  \t/*\n  \t * Verhoeff validation helper function\n  \t * Called with a string of numbers\n  \t * to validate according to the Verhoeff algorithm.\n  \t */\n  \tfunction verhoeffCheck(str) {\n  \t  var d_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];\n  \t  var p_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];\n\n  \t  // Copy (to prevent replacement) and reverse\n  \t  var str_copy = str.split('').reverse().join('');\n  \t  var checksum = 0;\n  \t  for (var i = 0; i < str_copy.length; i++) {\n  \t    checksum = d_table[checksum][p_table[i % 8][parseInt(str_copy[i], 10)]];\n  \t  }\n  \t  return checksum === 0;\n  \t}\n  \treturn algorithms;\n  }\n\n  var hasRequiredIsTaxID;\n\n  function requireIsTaxID () {\n  \tif (hasRequiredIsTaxID) return isTaxID.exports;\n  \thasRequiredIsTaxID = 1;\n  \t(function (module, exports$1) {\n\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isTaxID;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar algorithms = _interopRequireWildcard(requireAlgorithms());\n  \t\tvar _isDate = _interopRequireDefault(requireIsDate());\n  \t\tfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\n  \t\tfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n  \t\tfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\n  \t\tfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\n  \t\tfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\n  \t\tfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n  \t\t/**\n  \t\t * TIN Validation\n  \t\t * Validates Tax Identification Numbers (TINs) from the US, EU member states and the United Kingdom.\n  \t\t *\n  \t\t * EU-UK:\n  \t\t * National TIN validity is calculated using public algorithms as made available by DG TAXUD.\n  \t\t *\n  \t\t * See `https://ec.europa.eu/taxation_customs/tin/specs/FS-TIN%20Algorithms-Public.docx` for more information.\n  \t\t *\n  \t\t * US:\n  \t\t * An Employer Identification Number (EIN), also known as a Federal Tax Identification Number,\n  \t\t *  is used to identify a business entity.\n  \t\t *\n  \t\t * NOTES:\n  \t\t *  - Prefix 47 is being reserved for future use\n  \t\t *  - Prefixes 26, 27, 45, 46 and 47 were previously assigned by the Philadelphia campus.\n  \t\t *\n  \t\t * See `http://www.irs.gov/Businesses/Small-Businesses-&-Self-Employed/How-EINs-are-Assigned-and-Valid-EIN-Prefixes`\n  \t\t * for more information.\n  \t\t */\n\n  \t\t// Locale functions\n\n  \t\t/*\n  \t\t * bg-BG validation function\n  \t\t * (Edinen graždanski nomer (EGN/ЕГН), persons only)\n  \t\t * Checks if birth date (first six digits) is valid and calculates check (last) digit\n  \t\t */\n  \t\tfunction bgBgCheck(tin) {\n  \t\t  // Extract full year, normalize month and check birth date validity\n  \t\t  var century_year = tin.slice(0, 2);\n  \t\t  var month = parseInt(tin.slice(2, 4), 10);\n  \t\t  if (month > 40) {\n  \t\t    month -= 40;\n  \t\t    century_year = \"20\".concat(century_year);\n  \t\t  } else if (month > 20) {\n  \t\t    month -= 20;\n  \t\t    century_year = \"18\".concat(century_year);\n  \t\t  } else {\n  \t\t    century_year = \"19\".concat(century_year);\n  \t\t  }\n  \t\t  if (month < 10) {\n  \t\t    month = \"0\".concat(month);\n  \t\t  }\n  \t\t  var date = \"\".concat(century_year, \"/\").concat(month, \"/\").concat(tin.slice(4, 6));\n  \t\t  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // split digits into an array for further processing\n  \t\t  var digits = tin.split('').map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  });\n\n  \t\t  // Calculate checksum by multiplying digits with fixed values\n  \t\t  var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];\n  \t\t  var checksum = 0;\n  \t\t  for (var i = 0; i < multip_lookup.length; i++) {\n  \t\t    checksum += digits[i] * multip_lookup[i];\n  \t\t  }\n  \t\t  checksum = checksum % 11 === 10 ? 0 : checksum % 11;\n  \t\t  return checksum === digits[9];\n  \t\t}\n\n  \t\t/**\n  \t\t * Check if an input is a valid Canadian SIN (Social Insurance Number)\n  \t\t *\n  \t\t * The Social Insurance Number (SIN) is a 9 digit number that\n  \t\t * you need to work in Canada or to have access to government programs and benefits.\n  \t\t *\n  \t\t * https://en.wikipedia.org/wiki/Social_Insurance_Number\n  \t\t * https://www.canada.ca/en/employment-social-development/services/sin.html\n  \t\t * https://www.codercrunch.com/challenge/819302488/sin-validator\n  \t\t *\n  \t\t * @param {string} input\n  \t\t * @return {boolean}\n  \t\t */\n  \t\tfunction isCanadianSIN(input) {\n  \t\t  var digitsArray = input.split('');\n  \t\t  var even = digitsArray.filter(function (_, idx) {\n  \t\t    return idx % 2;\n  \t\t  }).map(function (i) {\n  \t\t    return Number(i) * 2;\n  \t\t  }).join('').split('');\n  \t\t  var total = digitsArray.filter(function (_, idx) {\n  \t\t    return !(idx % 2);\n  \t\t  }).concat(even).map(function (i) {\n  \t\t    return Number(i);\n  \t\t  }).reduce(function (acc, cur) {\n  \t\t    return acc + cur;\n  \t\t  });\n  \t\t  return total % 10 === 0;\n  \t\t}\n\n  \t\t/*\n  \t\t * cs-CZ validation function\n  \t\t * (Rodné číslo (RČ), persons only)\n  \t\t * Checks if birth date (first six digits) is valid and divisibility by 11\n  \t\t * Material not in DG TAXUD document sourced from:\n  \t\t * -`https://lorenc.info/3MA381/overeni-spravnosti-rodneho-cisla.htm`\n  \t\t * -`https://www.mvcr.cz/clanek/rady-a-sluzby-dokumenty-rodne-cislo.aspx`\n  \t\t */\n  \t\tfunction csCzCheck(tin) {\n  \t\t  tin = tin.replace(/\\W/, '');\n\n  \t\t  // Extract full year from TIN length\n  \t\t  var full_year = parseInt(tin.slice(0, 2), 10);\n  \t\t  if (tin.length === 10) {\n  \t\t    if (full_year < 54) {\n  \t\t      full_year = \"20\".concat(full_year);\n  \t\t    } else {\n  \t\t      full_year = \"19\".concat(full_year);\n  \t\t    }\n  \t\t  } else {\n  \t\t    if (tin.slice(6) === '000') {\n  \t\t      return false;\n  \t\t    } // Three-zero serial not assigned before 1954\n  \t\t    if (full_year < 54) {\n  \t\t      full_year = \"19\".concat(full_year);\n  \t\t    } else {\n  \t\t      return false; // No 18XX years seen in any of the resources\n  \t\t    }\n  \t\t  }\n  \t\t  // Add missing zero if needed\n  \t\t  if (full_year.length === 3) {\n  \t\t    full_year = [full_year.slice(0, 2), '0', full_year.slice(2)].join('');\n  \t\t  }\n\n  \t\t  // Extract month from TIN and normalize\n  \t\t  var month = parseInt(tin.slice(2, 4), 10);\n  \t\t  if (month > 50) {\n  \t\t    month -= 50;\n  \t\t  }\n  \t\t  if (month > 20) {\n  \t\t    // Month-plus-twenty was only introduced in 2004\n  \t\t    if (parseInt(full_year, 10) < 2004) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    month -= 20;\n  \t\t  }\n  \t\t  if (month < 10) {\n  \t\t    month = \"0\".concat(month);\n  \t\t  }\n\n  \t\t  // Check date validity\n  \t\t  var date = \"\".concat(full_year, \"/\").concat(month, \"/\").concat(tin.slice(4, 6));\n  \t\t  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Verify divisibility by 11\n  \t\t  if (tin.length === 10) {\n  \t\t    if (parseInt(tin, 10) % 11 !== 0) {\n  \t\t      // Some numbers up to and including 1985 are still valid if\n  \t\t      // check (last) digit equals 0 and modulo of first 9 digits equals 10\n  \t\t      var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;\n  \t\t      if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {\n  \t\t        if (parseInt(tin.slice(9), 10) !== 0) {\n  \t\t          return false;\n  \t\t        }\n  \t\t      } else {\n  \t\t        return false;\n  \t\t      }\n  \t\t    }\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n\n  \t\t/*\n  \t\t * de-AT validation function\n  \t\t * (Abgabenkontonummer, persons/entities)\n  \t\t * Verify TIN validity by calling luhnCheck()\n  \t\t */\n  \t\tfunction deAtCheck(tin) {\n  \t\t  return algorithms.luhnCheck(tin);\n  \t\t}\n\n  \t\t/*\n  \t\t * de-DE validation function\n  \t\t * (Steueridentifikationsnummer (Steuer-IdNr.), persons only)\n  \t\t * Tests for single duplicate/triplicate value, then calculates ISO 7064 check (last) digit\n  \t\t * Partial implementation of spec (same result with both algorithms always)\n  \t\t */\n  \t\tfunction deDeCheck(tin) {\n  \t\t  // Split digits into an array for further processing\n  \t\t  var digits = tin.split('').map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  });\n\n  \t\t  // Fill array with strings of number positions\n  \t\t  var occurrences = [];\n  \t\t  for (var i = 0; i < digits.length - 1; i++) {\n  \t\t    occurrences.push('');\n  \t\t    for (var j = 0; j < digits.length - 1; j++) {\n  \t\t      if (digits[i] === digits[j]) {\n  \t\t        occurrences[i] += j;\n  \t\t      }\n  \t\t    }\n  \t\t  }\n\n  \t\t  // Remove digits with one occurrence and test for only one duplicate/triplicate\n  \t\t  occurrences = occurrences.filter(function (a) {\n  \t\t    return a.length > 1;\n  \t\t  });\n  \t\t  if (occurrences.length !== 2 && occurrences.length !== 3) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // In case of triplicate value only two digits are allowed next to each other\n  \t\t  if (occurrences[0].length === 3) {\n  \t\t    var trip_locations = occurrences[0].split('').map(function (a) {\n  \t\t      return parseInt(a, 10);\n  \t\t    });\n  \t\t    var recurrent = 0; // Amount of neighbor occurrences\n  \t\t    for (var _i = 0; _i < trip_locations.length - 1; _i++) {\n  \t\t      if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {\n  \t\t        recurrent += 1;\n  \t\t      }\n  \t\t    }\n  \t\t    if (recurrent === 2) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  return algorithms.iso7064Check(tin);\n  \t\t}\n\n  \t\t/*\n  \t\t * dk-DK validation function\n  \t\t * (CPR-nummer (personnummer), persons only)\n  \t\t * Checks if birth date (first six digits) is valid and assigned to century (seventh) digit,\n  \t\t * and calculates check (last) digit\n  \t\t */\n  \t\tfunction dkDkCheck(tin) {\n  \t\t  tin = tin.replace(/\\W/, '');\n\n  \t\t  // Extract year, check if valid for given century digit and add century\n  \t\t  var year = parseInt(tin.slice(4, 6), 10);\n  \t\t  var century_digit = tin.slice(6, 7);\n  \t\t  switch (century_digit) {\n  \t\t    case '0':\n  \t\t    case '1':\n  \t\t    case '2':\n  \t\t    case '3':\n  \t\t      year = \"19\".concat(year);\n  \t\t      break;\n  \t\t    case '4':\n  \t\t    case '9':\n  \t\t      if (year < 37) {\n  \t\t        year = \"20\".concat(year);\n  \t\t      } else {\n  \t\t        year = \"19\".concat(year);\n  \t\t      }\n  \t\t      break;\n  \t\t    default:\n  \t\t      if (year < 37) {\n  \t\t        year = \"20\".concat(year);\n  \t\t      } else if (year > 58) {\n  \t\t        year = \"18\".concat(year);\n  \t\t      } else {\n  \t\t        return false;\n  \t\t      }\n  \t\t      break;\n  \t\t  }\n  \t\t  // Add missing zero if needed\n  \t\t  if (year.length === 3) {\n  \t\t    year = [year.slice(0, 2), '0', year.slice(2)].join('');\n  \t\t  }\n  \t\t  // Check date validity\n  \t\t  var date = \"\".concat(year, \"/\").concat(tin.slice(2, 4), \"/\").concat(tin.slice(0, 2));\n  \t\t  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Split digits into an array for further processing\n  \t\t  var digits = tin.split('').map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  });\n  \t\t  var checksum = 0;\n  \t\t  var weight = 4;\n  \t\t  // Multiply by weight and add to checksum\n  \t\t  for (var i = 0; i < 9; i++) {\n  \t\t    checksum += digits[i] * weight;\n  \t\t    weight -= 1;\n  \t\t    if (weight === 1) {\n  \t\t      weight = 7;\n  \t\t    }\n  \t\t  }\n  \t\t  checksum %= 11;\n  \t\t  if (checksum === 1) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return checksum === 0 ? digits[9] === 0 : digits[9] === 11 - checksum;\n  \t\t}\n\n  \t\t/*\n  \t\t * el-CY validation function\n  \t\t * (Arithmos Forologikou Mitroou (AFM/ΑΦΜ), persons only)\n  \t\t * Verify TIN validity by calculating ASCII value of check (last) character\n  \t\t */\n  \t\tfunction elCyCheck(tin) {\n  \t\t  // split digits into an array for further processing\n  \t\t  var digits = tin.slice(0, 8).split('').map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  });\n  \t\t  var checksum = 0;\n  \t\t  // add digits in even places\n  \t\t  for (var i = 1; i < digits.length; i += 2) {\n  \t\t    checksum += digits[i];\n  \t\t  }\n\n  \t\t  // add digits in odd places\n  \t\t  for (var _i2 = 0; _i2 < digits.length; _i2 += 2) {\n  \t\t    if (digits[_i2] < 2) {\n  \t\t      checksum += 1 - digits[_i2];\n  \t\t    } else {\n  \t\t      checksum += 2 * (digits[_i2] - 2) + 5;\n  \t\t      if (digits[_i2] > 4) {\n  \t\t        checksum += 2;\n  \t\t      }\n  \t\t    }\n  \t\t  }\n  \t\t  return String.fromCharCode(checksum % 26 + 65) === tin.charAt(8);\n  \t\t}\n\n  \t\t/*\n  \t\t * el-GR validation function\n  \t\t * (Arithmos Forologikou Mitroou (AFM/ΑΦΜ), persons/entities)\n  \t\t * Verify TIN validity by calculating check (last) digit\n  \t\t * Algorithm not in DG TAXUD document- sourced from:\n  \t\t * - `http://epixeirisi.gr/%CE%9A%CE%A1%CE%99%CE%A3%CE%99%CE%9C%CE%91-%CE%98%CE%95%CE%9C%CE%91%CE%A4%CE%91-%CE%A6%CE%9F%CE%A1%CE%9F%CE%9B%CE%9F%CE%93%CE%99%CE%91%CE%A3-%CE%9A%CE%91%CE%99-%CE%9B%CE%9F%CE%93%CE%99%CE%A3%CE%A4%CE%99%CE%9A%CE%97%CE%A3/23791/%CE%91%CF%81%CE%B9%CE%B8%CE%BC%CF%8C%CF%82-%CE%A6%CE%BF%CF%81%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CE%BA%CE%BF%CF%8D-%CE%9C%CE%B7%CF%84%CF%81%CF%8E%CE%BF%CF%85`\n  \t\t */\n  \t\tfunction elGrCheck(tin) {\n  \t\t  // split digits into an array for further processing\n  \t\t  var digits = tin.split('').map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  });\n  \t\t  var checksum = 0;\n  \t\t  for (var i = 0; i < 8; i++) {\n  \t\t    checksum += digits[i] * Math.pow(2, 8 - i);\n  \t\t  }\n  \t\t  return checksum % 11 % 10 === digits[8];\n  \t\t}\n\n  \t\t/*\n  \t\t * en-GB validation function (should go here if needed)\n  \t\t * (National Insurance Number (NINO) or Unique Taxpayer Reference (UTR),\n  \t\t * persons/entities respectively)\n  \t\t */\n\n  \t\t/*\n  \t\t * en-IE validation function\n  \t\t * (Personal Public Service Number (PPS No), persons only)\n  \t\t * Verify TIN validity by calculating check (second to last) character\n  \t\t */\n  \t\tfunction enIeCheck(tin) {\n  \t\t  var checksum = algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 7).map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  }), 8);\n  \t\t  if (tin.length === 9 && tin[8] !== 'W') {\n  \t\t    checksum += (tin[8].charCodeAt(0) - 64) * 9;\n  \t\t  }\n  \t\t  checksum %= 23;\n  \t\t  if (checksum === 0) {\n  \t\t    return tin[7].toUpperCase() === 'W';\n  \t\t  }\n  \t\t  return tin[7].toUpperCase() === String.fromCharCode(64 + checksum);\n  \t\t}\n\n  \t\t// Valid US IRS campus prefixes\n  \t\tvar enUsCampusPrefix = {\n  \t\t  andover: ['10', '12'],\n  \t\t  atlanta: ['60', '67'],\n  \t\t  austin: ['50', '53'],\n  \t\t  brookhaven: ['01', '02', '03', '04', '05', '06', '11', '13', '14', '16', '21', '22', '23', '25', '34', '51', '52', '54', '55', '56', '57', '58', '59', '65'],\n  \t\t  cincinnati: ['30', '32', '35', '36', '37', '38', '61'],\n  \t\t  fresno: ['15', '24'],\n  \t\t  internet: ['20', '26', '27', '45', '46', '47'],\n  \t\t  kansas: ['40', '44'],\n  \t\t  memphis: ['94', '95'],\n  \t\t  ogden: ['80', '90'],\n  \t\t  philadelphia: ['33', '39', '41', '42', '43', '46', '48', '62', '63', '64', '66', '68', '71', '72', '73', '74', '75', '76', '77', '81', '82', '83', '84', '85', '86', '87', '88', '91', '92', '93', '98', '99'],\n  \t\t  sba: ['31']\n  \t\t};\n\n  \t\t// Return an array of all US IRS campus prefixes\n  \t\tfunction enUsGetPrefixes() {\n  \t\t  var prefixes = [];\n  \t\t  for (var location in enUsCampusPrefix) {\n  \t\t    // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n  \t\t    // istanbul ignore else\n  \t\t    if (enUsCampusPrefix.hasOwnProperty(location)) {\n  \t\t      prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location]));\n  \t\t    }\n  \t\t  }\n  \t\t  return prefixes;\n  \t\t}\n\n  \t\t/*\n  \t\t * en-US validation function\n  \t\t * Verify that the TIN starts with a valid IRS campus prefix\n  \t\t */\n  \t\tfunction enUsCheck(tin) {\n  \t\t  return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;\n  \t\t}\n\n  \t\t/*\n  \t\t * es-AR validation function\n  \t\t * Clave Única de Identificación Tributaria (CUIT/CUIL)\n  \t\t * Sourced from:\n  \t\t * - https://servicioscf.afip.gob.ar/publico/abc/ABCpaso2.aspx?id_nivel1=3036&id_nivel2=3040&p=Conceptos%20b%C3%A1sicos\n  \t\t * - https://es.wikipedia.org/wiki/Clave_%C3%9Anica_de_Identificaci%C3%B3n_Tributaria\n  \t\t */\n\n  \t\tfunction esArCheck(tin) {\n  \t\t  var accum = 0;\n  \t\t  var digits = tin.split('');\n  \t\t  var digit = parseInt(digits.pop(), 10);\n  \t\t  for (var i = 0; i < digits.length; i++) {\n  \t\t    accum += digits[9 - i] * (2 + i % 6);\n  \t\t  }\n  \t\t  var verif = 11 - accum % 11;\n  \t\t  if (verif === 11) {\n  \t\t    verif = 0;\n  \t\t  } else if (verif === 10) {\n  \t\t    verif = 9;\n  \t\t  }\n  \t\t  return digit === verif;\n  \t\t}\n\n  \t\t/*\n  \t\t * es-ES validation function\n  \t\t * (Documento Nacional de Identidad (DNI)\n  \t\t * or Número de Identificación de Extranjero (NIE), persons only)\n  \t\t * Verify TIN validity by calculating check (last) character\n  \t\t */\n  \t\tfunction esEsCheck(tin) {\n  \t\t  // Split characters into an array for further processing\n  \t\t  var chars = tin.toUpperCase().split('');\n\n  \t\t  // Replace initial letter if needed\n  \t\t  if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {\n  \t\t    var lead_replace = 0;\n  \t\t    switch (chars[0]) {\n  \t\t      case 'Y':\n  \t\t        lead_replace = 1;\n  \t\t        break;\n  \t\t      case 'Z':\n  \t\t        lead_replace = 2;\n  \t\t        break;\n  \t\t    }\n  \t\t    chars.splice(0, 1, lead_replace);\n  \t\t    // Fill with zeros if smaller than proper\n  \t\t  } else {\n  \t\t    while (chars.length < 9) {\n  \t\t      chars.unshift(0);\n  \t\t    }\n  \t\t  }\n\n  \t\t  // Calculate checksum and check according to lookup\n  \t\t  var lookup = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E'];\n  \t\t  chars = chars.join('');\n  \t\t  var checksum = parseInt(chars.slice(0, 8), 10) % 23;\n  \t\t  return chars[8] === lookup[checksum];\n  \t\t}\n\n  \t\t/*\n  \t\t * et-EE validation function\n  \t\t * (Isikukood (IK), persons only)\n  \t\t * Checks if birth date (century digit and six following) is valid and calculates check (last) digit\n  \t\t * Material not in DG TAXUD document sourced from:\n  \t\t * - `https://www.oecd.org/tax/automatic-exchange/crs-implementation-and-assistance/tax-identification-numbers/Estonia-TIN.pdf`\n  \t\t */\n  \t\tfunction etEeCheck(tin) {\n  \t\t  // Extract year and add century\n  \t\t  var full_year = tin.slice(1, 3);\n  \t\t  var century_digit = tin.slice(0, 1);\n  \t\t  switch (century_digit) {\n  \t\t    case '1':\n  \t\t    case '2':\n  \t\t      full_year = \"18\".concat(full_year);\n  \t\t      break;\n  \t\t    case '3':\n  \t\t    case '4':\n  \t\t      full_year = \"19\".concat(full_year);\n  \t\t      break;\n  \t\t    default:\n  \t\t      full_year = \"20\".concat(full_year);\n  \t\t      break;\n  \t\t  }\n  \t\t  // Check date validity\n  \t\t  var date = \"\".concat(full_year, \"/\").concat(tin.slice(3, 5), \"/\").concat(tin.slice(5, 7));\n  \t\t  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Split digits into an array for further processing\n  \t\t  var digits = tin.split('').map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  });\n  \t\t  var checksum = 0;\n  \t\t  var weight = 1;\n  \t\t  // Multiply by weight and add to checksum\n  \t\t  for (var i = 0; i < 10; i++) {\n  \t\t    checksum += digits[i] * weight;\n  \t\t    weight += 1;\n  \t\t    if (weight === 10) {\n  \t\t      weight = 1;\n  \t\t    }\n  \t\t  }\n  \t\t  // Do again if modulo 11 of checksum is 10\n  \t\t  if (checksum % 11 === 10) {\n  \t\t    checksum = 0;\n  \t\t    weight = 3;\n  \t\t    for (var _i3 = 0; _i3 < 10; _i3++) {\n  \t\t      checksum += digits[_i3] * weight;\n  \t\t      weight += 1;\n  \t\t      if (weight === 10) {\n  \t\t        weight = 1;\n  \t\t      }\n  \t\t    }\n  \t\t    if (checksum % 11 === 10) {\n  \t\t      return digits[10] === 0;\n  \t\t    }\n  \t\t  }\n  \t\t  return checksum % 11 === digits[10];\n  \t\t}\n\n  \t\t/*\n  \t\t * fi-FI validation function\n  \t\t * (Henkilötunnus (HETU), persons only)\n  \t\t * Checks if birth date (first six digits plus century symbol) is valid\n  \t\t * and calculates check (last) digit\n  \t\t */\n  \t\tfunction fiFiCheck(tin) {\n  \t\t  // Extract year and add century\n  \t\t  var full_year = tin.slice(4, 6);\n  \t\t  var century_symbol = tin.slice(6, 7);\n  \t\t  switch (century_symbol) {\n  \t\t    case '+':\n  \t\t      full_year = \"18\".concat(full_year);\n  \t\t      break;\n  \t\t    case '-':\n  \t\t      full_year = \"19\".concat(full_year);\n  \t\t      break;\n  \t\t    default:\n  \t\t      full_year = \"20\".concat(full_year);\n  \t\t      break;\n  \t\t  }\n  \t\t  // Check date validity\n  \t\t  var date = \"\".concat(full_year, \"/\").concat(tin.slice(2, 4), \"/\").concat(tin.slice(0, 2));\n  \t\t  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Calculate check character\n  \t\t  var checksum = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;\n  \t\t  if (checksum < 10) {\n  \t\t    return checksum === parseInt(tin.slice(10), 10);\n  \t\t  }\n  \t\t  checksum -= 10;\n  \t\t  var letters_lookup = ['A', 'B', 'C', 'D', 'E', 'F', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'];\n  \t\t  return letters_lookup[checksum] === tin.slice(10);\n  \t\t}\n\n  \t\t/*\n  \t\t * fr/nl-BE validation function\n  \t\t * (Numéro national (N.N.), persons only)\n  \t\t * Checks if birth date (first six digits) is valid and calculates check (last two) digits\n  \t\t */\n  \t\tfunction frBeCheck(tin) {\n  \t\t  // Zero month/day value is acceptable\n  \t\t  if (tin.slice(2, 4) !== '00' || tin.slice(4, 6) !== '00') {\n  \t\t    // Extract date from first six digits of TIN\n  \t\t    var date = \"\".concat(tin.slice(0, 2), \"/\").concat(tin.slice(2, 4), \"/\").concat(tin.slice(4, 6));\n  \t\t    if (!(0, _isDate.default)(date, 'YY/MM/DD')) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  var checksum = 97 - parseInt(tin.slice(0, 9), 10) % 97;\n  \t\t  var checkdigits = parseInt(tin.slice(9, 11), 10);\n  \t\t  if (checksum !== checkdigits) {\n  \t\t    checksum = 97 - parseInt(\"2\".concat(tin.slice(0, 9)), 10) % 97;\n  \t\t    if (checksum !== checkdigits) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n\n  \t\t/*\n  \t\t * fr-FR validation function\n  \t\t * (Numéro fiscal de référence (numéro SPI), persons only)\n  \t\t * Verify TIN validity by calculating check (last three) digits\n  \t\t */\n  \t\tfunction frFrCheck(tin) {\n  \t\t  tin = tin.replace(/\\s/g, '');\n  \t\t  var checksum = parseInt(tin.slice(0, 10), 10) % 511;\n  \t\t  var checkdigits = parseInt(tin.slice(10, 13), 10);\n  \t\t  return checksum === checkdigits;\n  \t\t}\n\n  \t\t/*\n  \t\t * fr/lb-LU validation function\n  \t\t * (numéro d’identification personnelle, persons only)\n  \t\t * Verify birth date validity and run Luhn and Verhoeff checks\n  \t\t */\n  \t\tfunction frLuCheck(tin) {\n  \t\t  // Extract date and check validity\n  \t\t  var date = \"\".concat(tin.slice(0, 4), \"/\").concat(tin.slice(4, 6), \"/\").concat(tin.slice(6, 8));\n  \t\t  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Run Luhn check\n  \t\t  if (!algorithms.luhnCheck(tin.slice(0, 12))) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  // Remove Luhn check digit and run Verhoeff check\n  \t\t  return algorithms.verhoeffCheck(\"\".concat(tin.slice(0, 11)).concat(tin[12]));\n  \t\t}\n\n  \t\t/*\n  \t\t * hr-HR validation function\n  \t\t * (Osobni identifikacijski broj (OIB), persons/entities)\n  \t\t * Verify TIN validity by calling iso7064Check(digits)\n  \t\t */\n  \t\tfunction hrHrCheck(tin) {\n  \t\t  return algorithms.iso7064Check(tin);\n  \t\t}\n\n  \t\t/*\n  \t\t * hu-HU validation function\n  \t\t * (Adóazonosító jel, persons only)\n  \t\t * Verify TIN validity by calculating check (last) digit\n  \t\t */\n  \t\tfunction huHuCheck(tin) {\n  \t\t  // split digits into an array for further processing\n  \t\t  var digits = tin.split('').map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  });\n  \t\t  var checksum = 8;\n  \t\t  for (var i = 1; i < 9; i++) {\n  \t\t    checksum += digits[i] * (i + 1);\n  \t\t  }\n  \t\t  return checksum % 11 === digits[9];\n  \t\t}\n\n  \t\t/*\n  \t\t * lt-LT validation function (should go here if needed)\n  \t\t * (Asmens kodas, persons/entities respectively)\n  \t\t * Current validation check is alias of etEeCheck- same format applies\n  \t\t */\n\n  \t\t/*\n  \t\t * it-IT first/last name validity check\n  \t\t * Accepts it-IT TIN-encoded names as a three-element character array and checks their validity\n  \t\t * Due to lack of clarity between resources (\"Are only Italian consonants used?\n  \t\t * What happens if a person has X in their name?\" etc.) only two test conditions\n  \t\t * have been implemented:\n  \t\t * Vowels may only be followed by other vowels or an X character\n  \t\t * and X characters after vowels may only be followed by other X characters.\n  \t\t */\n  \t\tfunction itItNameCheck(name) {\n  \t\t  // true at the first occurrence of a vowel\n  \t\t  var vowelflag = false;\n\n  \t\t  // true at the first occurrence of an X AFTER vowel\n  \t\t  // (to properly handle last names with X as consonant)\n  \t\t  var xflag = false;\n  \t\t  for (var i = 0; i < 3; i++) {\n  \t\t    if (!vowelflag && /[AEIOU]/.test(name[i])) {\n  \t\t      vowelflag = true;\n  \t\t    } else if (!xflag && vowelflag && name[i] === 'X') {\n  \t\t      xflag = true;\n  \t\t    } else if (i > 0) {\n  \t\t      if (vowelflag && !xflag) {\n  \t\t        if (!/[AEIOU]/.test(name[i])) {\n  \t\t          return false;\n  \t\t        }\n  \t\t      }\n  \t\t      if (xflag) {\n  \t\t        if (!/X/.test(name[i])) {\n  \t\t          return false;\n  \t\t        }\n  \t\t      }\n  \t\t    }\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n\n  \t\t/*\n  \t\t * it-IT validation function\n  \t\t * (Codice fiscale (TIN-IT), persons only)\n  \t\t * Verify name, birth date and codice catastale validity\n  \t\t * and calculate check character.\n  \t\t * Material not in DG-TAXUD document sourced from:\n  \t\t * `https://en.wikipedia.org/wiki/Italian_fiscal_code`\n  \t\t */\n  \t\tfunction itItCheck(tin) {\n  \t\t  // Capitalize and split characters into an array for further processing\n  \t\t  var chars = tin.toUpperCase().split('');\n\n  \t\t  // Check first and last name validity calling itItNameCheck()\n  \t\t  if (!itItNameCheck(chars.slice(0, 3))) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  if (!itItNameCheck(chars.slice(3, 6))) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Convert letters in number spaces back to numbers if any\n  \t\t  var number_locations = [6, 7, 9, 10, 12, 13, 14];\n  \t\t  var number_replace = {\n  \t\t    L: '0',\n  \t\t    M: '1',\n  \t\t    N: '2',\n  \t\t    P: '3',\n  \t\t    Q: '4',\n  \t\t    R: '5',\n  \t\t    S: '6',\n  \t\t    T: '7',\n  \t\t    U: '8',\n  \t\t    V: '9'\n  \t\t  };\n  \t\t  for (var _i4 = 0, _number_locations = number_locations; _i4 < _number_locations.length; _i4++) {\n  \t\t    var i = _number_locations[_i4];\n  \t\t    if (chars[i] in number_replace) {\n  \t\t      chars.splice(i, 1, number_replace[chars[i]]);\n  \t\t    }\n  \t\t  }\n\n  \t\t  // Extract month and day, and check date validity\n  \t\t  var month_replace = {\n  \t\t    A: '01',\n  \t\t    B: '02',\n  \t\t    C: '03',\n  \t\t    D: '04',\n  \t\t    E: '05',\n  \t\t    H: '06',\n  \t\t    L: '07',\n  \t\t    M: '08',\n  \t\t    P: '09',\n  \t\t    R: '10',\n  \t\t    S: '11',\n  \t\t    T: '12'\n  \t\t  };\n  \t\t  var month = month_replace[chars[8]];\n  \t\t  var day = parseInt(chars[9] + chars[10], 10);\n  \t\t  if (day > 40) {\n  \t\t    day -= 40;\n  \t\t  }\n  \t\t  if (day < 10) {\n  \t\t    day = \"0\".concat(day);\n  \t\t  }\n  \t\t  var date = \"\".concat(chars[6]).concat(chars[7], \"/\").concat(month, \"/\").concat(day);\n  \t\t  if (!(0, _isDate.default)(date, 'YY/MM/DD')) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Calculate check character by adding up even and odd characters as numbers\n  \t\t  var checksum = 0;\n  \t\t  for (var _i5 = 1; _i5 < chars.length - 1; _i5 += 2) {\n  \t\t    var char_to_int = parseInt(chars[_i5], 10);\n  \t\t    if (isNaN(char_to_int)) {\n  \t\t      char_to_int = chars[_i5].charCodeAt(0) - 65;\n  \t\t    }\n  \t\t    checksum += char_to_int;\n  \t\t  }\n  \t\t  var odd_convert = {\n  \t\t    // Maps of characters at odd places\n  \t\t    A: 1,\n  \t\t    B: 0,\n  \t\t    C: 5,\n  \t\t    D: 7,\n  \t\t    E: 9,\n  \t\t    F: 13,\n  \t\t    G: 15,\n  \t\t    H: 17,\n  \t\t    I: 19,\n  \t\t    J: 21,\n  \t\t    K: 2,\n  \t\t    L: 4,\n  \t\t    M: 18,\n  \t\t    N: 20,\n  \t\t    O: 11,\n  \t\t    P: 3,\n  \t\t    Q: 6,\n  \t\t    R: 8,\n  \t\t    S: 12,\n  \t\t    T: 14,\n  \t\t    U: 16,\n  \t\t    V: 10,\n  \t\t    W: 22,\n  \t\t    X: 25,\n  \t\t    Y: 24,\n  \t\t    Z: 23,\n  \t\t    0: 1,\n  \t\t    1: 0\n  \t\t  };\n  \t\t  for (var _i6 = 0; _i6 < chars.length - 1; _i6 += 2) {\n  \t\t    var _char_to_int = 0;\n  \t\t    if (chars[_i6] in odd_convert) {\n  \t\t      _char_to_int = odd_convert[chars[_i6]];\n  \t\t    } else {\n  \t\t      var multiplier = parseInt(chars[_i6], 10);\n  \t\t      _char_to_int = 2 * multiplier + 1;\n  \t\t      if (multiplier > 4) {\n  \t\t        _char_to_int += 2;\n  \t\t      }\n  \t\t    }\n  \t\t    checksum += _char_to_int;\n  \t\t  }\n  \t\t  if (String.fromCharCode(65 + checksum % 26) !== chars[15]) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n\n  \t\t/*\n  \t\t * lv-LV validation function\n  \t\t * (Personas kods (PK), persons only)\n  \t\t * Check validity of birth date and calculate check (last) digit\n  \t\t * Support only for old format numbers (not starting with '32', issued before 2017/07/01)\n  \t\t * Material not in DG TAXUD document sourced from:\n  \t\t * `https://boot.ritakafija.lv/forums/index.php?/topic/88314-personas-koda-algoritms-%C4%8Deksumma/`\n  \t\t */\n  \t\tfunction lvLvCheck(tin) {\n  \t\t  tin = tin.replace(/\\W/, '');\n  \t\t  // Extract date from TIN\n  \t\t  var day = tin.slice(0, 2);\n  \t\t  if (day !== '32') {\n  \t\t    // No date/checksum check if new format\n  \t\t    var month = tin.slice(2, 4);\n  \t\t    if (month !== '00') {\n  \t\t      // No date check if unknown month\n  \t\t      var full_year = tin.slice(4, 6);\n  \t\t      switch (tin[6]) {\n  \t\t        case '0':\n  \t\t          full_year = \"18\".concat(full_year);\n  \t\t          break;\n  \t\t        case '1':\n  \t\t          full_year = \"19\".concat(full_year);\n  \t\t          break;\n  \t\t        default:\n  \t\t          full_year = \"20\".concat(full_year);\n  \t\t          break;\n  \t\t      }\n  \t\t      // Check date validity\n  \t\t      var date = \"\".concat(full_year, \"/\").concat(tin.slice(2, 4), \"/\").concat(day);\n  \t\t      if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t        return false;\n  \t\t      }\n  \t\t    }\n\n  \t\t    // Calculate check digit\n  \t\t    var checksum = 1101;\n  \t\t    var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];\n  \t\t    for (var i = 0; i < tin.length - 1; i++) {\n  \t\t      checksum -= parseInt(tin[i], 10) * multip_lookup[i];\n  \t\t    }\n  \t\t    return parseInt(tin[10], 10) === checksum % 11;\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n\n  \t\t/*\n  \t\t * mt-MT validation function\n  \t\t * (Identity Card Number or Unique Taxpayer Reference, persons/entities)\n  \t\t * Verify Identity Card Number structure (no other tests found)\n  \t\t */\n  \t\tfunction mtMtCheck(tin) {\n  \t\t  if (tin.length !== 9) {\n  \t\t    // No tests for UTR\n  \t\t    var chars = tin.toUpperCase().split('');\n  \t\t    // Fill with zeros if smaller than proper\n  \t\t    while (chars.length < 8) {\n  \t\t      chars.unshift(0);\n  \t\t    }\n  \t\t    // Validate format according to last character\n  \t\t    switch (tin[7]) {\n  \t\t      case 'A':\n  \t\t      case 'P':\n  \t\t        if (parseInt(chars[6], 10) === 0) {\n  \t\t          return false;\n  \t\t        }\n  \t\t        break;\n  \t\t      default:\n  \t\t        {\n  \t\t          var first_part = parseInt(chars.join('').slice(0, 5), 10);\n  \t\t          if (first_part > 32000) {\n  \t\t            return false;\n  \t\t          }\n  \t\t          var second_part = parseInt(chars.join('').slice(5, 7), 10);\n  \t\t          if (first_part === second_part) {\n  \t\t            return false;\n  \t\t          }\n  \t\t        }\n  \t\t    }\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n\n  \t\t/*\n  \t\t * nl-NL validation function\n  \t\t * (Burgerservicenummer (BSN) or Rechtspersonen Samenwerkingsverbanden Informatie Nummer (RSIN),\n  \t\t * persons/entities respectively)\n  \t\t * Verify TIN validity by calculating check (last) digit (variant of MOD 11)\n  \t\t */\n  \t\tfunction nlNlCheck(tin) {\n  \t\t  return algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  }), 9) % 11 === parseInt(tin[8], 10);\n  \t\t}\n\n  \t\t/*\n  \t\t * pl-PL validation function\n  \t\t * (Powszechny Elektroniczny System Ewidencji Ludności (PESEL)\n  \t\t * or Numer identyfikacji podatkowej (NIP), persons/entities)\n  \t\t * Verify TIN validity by validating birth date (PESEL) and calculating check (last) digit\n  \t\t */\n  \t\tfunction plPlCheck(tin) {\n  \t\t  // NIP\n  \t\t  if (tin.length === 10) {\n  \t\t    // Calculate last digit by multiplying with lookup\n  \t\t    var lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];\n  \t\t    var _checksum = 0;\n  \t\t    for (var i = 0; i < lookup.length; i++) {\n  \t\t      _checksum += parseInt(tin[i], 10) * lookup[i];\n  \t\t    }\n  \t\t    _checksum %= 11;\n  \t\t    if (_checksum === 10) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    return _checksum === parseInt(tin[9], 10);\n  \t\t  }\n\n  \t\t  // PESEL\n  \t\t  // Extract full year using month\n  \t\t  var full_year = tin.slice(0, 2);\n  \t\t  var month = parseInt(tin.slice(2, 4), 10);\n  \t\t  if (month > 80) {\n  \t\t    full_year = \"18\".concat(full_year);\n  \t\t    month -= 80;\n  \t\t  } else if (month > 60) {\n  \t\t    full_year = \"22\".concat(full_year);\n  \t\t    month -= 60;\n  \t\t  } else if (month > 40) {\n  \t\t    full_year = \"21\".concat(full_year);\n  \t\t    month -= 40;\n  \t\t  } else if (month > 20) {\n  \t\t    full_year = \"20\".concat(full_year);\n  \t\t    month -= 20;\n  \t\t  } else {\n  \t\t    full_year = \"19\".concat(full_year);\n  \t\t  }\n  \t\t  // Add leading zero to month if needed\n  \t\t  if (month < 10) {\n  \t\t    month = \"0\".concat(month);\n  \t\t  }\n  \t\t  // Check date validity\n  \t\t  var date = \"\".concat(full_year, \"/\").concat(month, \"/\").concat(tin.slice(4, 6));\n  \t\t  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t    return false;\n  \t\t  }\n\n  \t\t  // Calculate last digit by multiplying with odd one-digit numbers except 5\n  \t\t  var checksum = 0;\n  \t\t  var multiplier = 1;\n  \t\t  for (var _i7 = 0; _i7 < tin.length - 1; _i7++) {\n  \t\t    checksum += parseInt(tin[_i7], 10) * multiplier % 10;\n  \t\t    multiplier += 2;\n  \t\t    if (multiplier > 10) {\n  \t\t      multiplier = 1;\n  \t\t    } else if (multiplier === 5) {\n  \t\t      multiplier += 2;\n  \t\t    }\n  \t\t  }\n  \t\t  checksum = 10 - checksum % 10;\n  \t\t  return checksum === parseInt(tin[10], 10);\n  \t\t}\n\n  \t\t/*\n  \t\t* pt-BR validation function\n  \t\t* (Cadastro de Pessoas Físicas (CPF, persons)\n  \t\t* Cadastro Nacional de Pessoas Jurídicas (CNPJ, entities)\n  \t\t* Both inputs will be validated\n  \t\t*/\n\n  \t\tfunction ptBrCheck(tin) {\n  \t\t  if (tin.length === 11) {\n  \t\t    var _sum;\n  \t\t    var remainder;\n  \t\t    _sum = 0;\n  \t\t    if (\n  \t\t    // Reject known invalid CPFs\n  \t\t    tin === '11111111111' || tin === '22222222222' || tin === '33333333333' || tin === '44444444444' || tin === '55555555555' || tin === '66666666666' || tin === '77777777777' || tin === '88888888888' || tin === '99999999999' || tin === '00000000000') return false;\n  \t\t    for (var i = 1; i <= 9; i++) _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);\n  \t\t    remainder = _sum * 10 % 11;\n  \t\t    if (remainder === 10) remainder = 0;\n  \t\t    if (remainder !== parseInt(tin.substring(9, 10), 10)) return false;\n  \t\t    _sum = 0;\n  \t\t    for (var _i8 = 1; _i8 <= 10; _i8++) _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);\n  \t\t    remainder = _sum * 10 % 11;\n  \t\t    if (remainder === 10) remainder = 0;\n  \t\t    if (remainder !== parseInt(tin.substring(10, 11), 10)) return false;\n  \t\t    return true;\n  \t\t  }\n  \t\t  if (\n  \t\t  // Reject know invalid CNPJs\n  \t\t  tin === '00000000000000' || tin === '11111111111111' || tin === '22222222222222' || tin === '33333333333333' || tin === '44444444444444' || tin === '55555555555555' || tin === '66666666666666' || tin === '77777777777777' || tin === '88888888888888' || tin === '99999999999999') {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var length = tin.length - 2;\n  \t\t  var identifiers = tin.substring(0, length);\n  \t\t  var verificators = tin.substring(length);\n  \t\t  var sum = 0;\n  \t\t  var pos = length - 7;\n  \t\t  for (var _i9 = length; _i9 >= 1; _i9--) {\n  \t\t    sum += identifiers.charAt(length - _i9) * pos;\n  \t\t    pos -= 1;\n  \t\t    if (pos < 2) {\n  \t\t      pos = 9;\n  \t\t    }\n  \t\t  }\n  \t\t  var result = sum % 11 < 2 ? 0 : 11 - sum % 11;\n  \t\t  if (result !== parseInt(verificators.charAt(0), 10)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  length += 1;\n  \t\t  identifiers = tin.substring(0, length);\n  \t\t  sum = 0;\n  \t\t  pos = length - 7;\n  \t\t  for (var _i0 = length; _i0 >= 1; _i0--) {\n  \t\t    sum += identifiers.charAt(length - _i0) * pos;\n  \t\t    pos -= 1;\n  \t\t    if (pos < 2) {\n  \t\t      pos = 9;\n  \t\t    }\n  \t\t  }\n  \t\t  result = sum % 11 < 2 ? 0 : 11 - sum % 11;\n  \t\t  if (result !== parseInt(verificators.charAt(1), 10)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n\n  \t\t/*\n  \t\t * pt-PT validation function\n  \t\t * (Número de identificação fiscal (NIF), persons/entities)\n  \t\t * Verify TIN validity by calculating check (last) digit (variant of MOD 11)\n  \t\t */\n  \t\tfunction ptPtCheck(tin) {\n  \t\t  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  }), 9) % 11;\n  \t\t  if (checksum > 9) {\n  \t\t    return parseInt(tin[8], 10) === 0;\n  \t\t  }\n  \t\t  return checksum === parseInt(tin[8], 10);\n  \t\t}\n\n  \t\t/*\n  \t\t * ro-RO validation function\n  \t\t * (Cod Numeric Personal (CNP) or Cod de înregistrare fiscală (CIF),\n  \t\t * persons only)\n  \t\t * Verify CNP validity by calculating check (last) digit (test not found for CIF)\n  \t\t * Material not in DG TAXUD document sourced from:\n  \t\t * `https://en.wikipedia.org/wiki/National_identification_number#Romania`\n  \t\t */\n  \t\tfunction roRoCheck(tin) {\n  \t\t  if (tin.slice(0, 4) !== '9000') {\n  \t\t    // No test found for this format\n  \t\t    // Extract full year using century digit if possible\n  \t\t    var full_year = tin.slice(1, 3);\n  \t\t    switch (tin[0]) {\n  \t\t      case '1':\n  \t\t      case '2':\n  \t\t        full_year = \"19\".concat(full_year);\n  \t\t        break;\n  \t\t      case '3':\n  \t\t      case '4':\n  \t\t        full_year = \"18\".concat(full_year);\n  \t\t        break;\n  \t\t      case '5':\n  \t\t      case '6':\n  \t\t        full_year = \"20\".concat(full_year);\n  \t\t        break;\n  \t\t    }\n\n  \t\t    // Check date validity\n  \t\t    var date = \"\".concat(full_year, \"/\").concat(tin.slice(3, 5), \"/\").concat(tin.slice(5, 7));\n  \t\t    if (date.length === 8) {\n  \t\t      if (!(0, _isDate.default)(date, 'YY/MM/DD')) {\n  \t\t        return false;\n  \t\t      }\n  \t\t    } else if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t      return false;\n  \t\t    }\n\n  \t\t    // Calculate check digit\n  \t\t    var digits = tin.split('').map(function (a) {\n  \t\t      return parseInt(a, 10);\n  \t\t    });\n  \t\t    var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];\n  \t\t    var checksum = 0;\n  \t\t    for (var i = 0; i < multipliers.length; i++) {\n  \t\t      checksum += digits[i] * multipliers[i];\n  \t\t    }\n  \t\t    if (checksum % 11 === 10) {\n  \t\t      return digits[12] === 1;\n  \t\t    }\n  \t\t    return digits[12] === checksum % 11;\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n\n  \t\t/*\n  \t\t * sk-SK validation function\n  \t\t * (Rodné číslo (RČ) or bezvýznamové identifikačné číslo (BIČ), persons only)\n  \t\t * Checks validity of pre-1954 birth numbers (rodné číslo) only\n  \t\t * Due to the introduction of the pseudo-random BIČ it is not possible to test\n  \t\t * post-1954 birth numbers without knowing whether they are BIČ or RČ beforehand\n  \t\t */\n  \t\tfunction skSkCheck(tin) {\n  \t\t  if (tin.length === 9) {\n  \t\t    tin = tin.replace(/\\W/, '');\n  \t\t    if (tin.slice(6) === '000') {\n  \t\t      return false;\n  \t\t    } // Three-zero serial not assigned before 1954\n\n  \t\t    // Extract full year from TIN length\n  \t\t    var full_year = parseInt(tin.slice(0, 2), 10);\n  \t\t    if (full_year > 53) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (full_year < 10) {\n  \t\t      full_year = \"190\".concat(full_year);\n  \t\t    } else {\n  \t\t      full_year = \"19\".concat(full_year);\n  \t\t    }\n\n  \t\t    // Extract month from TIN and normalize\n  \t\t    var month = parseInt(tin.slice(2, 4), 10);\n  \t\t    if (month > 50) {\n  \t\t      month -= 50;\n  \t\t    }\n  \t\t    if (month < 10) {\n  \t\t      month = \"0\".concat(month);\n  \t\t    }\n\n  \t\t    // Check date validity\n  \t\t    var date = \"\".concat(full_year, \"/\").concat(month, \"/\").concat(tin.slice(4, 6));\n  \t\t    if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n\n  \t\t/*\n  \t\t * sl-SI validation function\n  \t\t * (Davčna številka, persons/entities)\n  \t\t * Verify TIN validity by calculating check (last) digit (variant of MOD 11)\n  \t\t */\n  \t\tfunction slSiCheck(tin) {\n  \t\t  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 7).map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  }), 8) % 11;\n  \t\t  if (checksum === 10) {\n  \t\t    return parseInt(tin[7], 10) === 0;\n  \t\t  }\n  \t\t  return checksum === parseInt(tin[7], 10);\n  \t\t}\n\n  \t\t/*\n  \t\t * sv-SE validation function\n  \t\t * (Personnummer or samordningsnummer, persons only)\n  \t\t * Checks validity of birth date and calls luhnCheck() to validate check (last) digit\n  \t\t */\n  \t\tfunction svSeCheck(tin) {\n  \t\t  // Make copy of TIN and normalize to two-digit year form\n  \t\t  var tin_copy = tin.slice(0);\n  \t\t  if (tin.length > 11) {\n  \t\t    tin_copy = tin_copy.slice(2);\n  \t\t  }\n\n  \t\t  // Extract date of birth\n  \t\t  var full_year = '';\n  \t\t  var month = tin_copy.slice(2, 4);\n  \t\t  var day = parseInt(tin_copy.slice(4, 6), 10);\n  \t\t  if (tin.length > 11) {\n  \t\t    full_year = tin.slice(0, 4);\n  \t\t  } else {\n  \t\t    full_year = tin.slice(0, 2);\n  \t\t    if (tin.length === 11 && day < 60) {\n  \t\t      // Extract full year from centenarian symbol\n  \t\t      // Should work just fine until year 10000 or so\n  \t\t      var current_year = new Date().getFullYear().toString();\n  \t\t      var current_century = parseInt(current_year.slice(0, 2), 10);\n  \t\t      current_year = parseInt(current_year, 10);\n  \t\t      if (tin[6] === '-') {\n  \t\t        if (parseInt(\"\".concat(current_century).concat(full_year), 10) > current_year) {\n  \t\t          full_year = \"\".concat(current_century - 1).concat(full_year);\n  \t\t        } else {\n  \t\t          full_year = \"\".concat(current_century).concat(full_year);\n  \t\t        }\n  \t\t      } else {\n  \t\t        full_year = \"\".concat(current_century - 1).concat(full_year);\n  \t\t        if (current_year - parseInt(full_year, 10) < 100) {\n  \t\t          return false;\n  \t\t        }\n  \t\t      }\n  \t\t    }\n  \t\t  }\n\n  \t\t  // Normalize day and check date validity\n  \t\t  if (day > 60) {\n  \t\t    day -= 60;\n  \t\t  }\n  \t\t  if (day < 10) {\n  \t\t    day = \"0\".concat(day);\n  \t\t  }\n  \t\t  var date = \"\".concat(full_year, \"/\").concat(month, \"/\").concat(day);\n  \t\t  if (date.length === 8) {\n  \t\t    if (!(0, _isDate.default)(date, 'YY/MM/DD')) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  } else if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return algorithms.luhnCheck(tin.replace(/\\W/, ''));\n  \t\t}\n\n  \t\t/**\n  \t\t * uk-UA validation function\n  \t\t * Verify TIN validity by calculating check (last) digit (variant of MOD 11)\n  \t\t */\n  \t\tfunction ukUaCheck(tin) {\n  \t\t  // Calculate check digit\n  \t\t  var digits = tin.split('').map(function (a) {\n  \t\t    return parseInt(a, 10);\n  \t\t  });\n  \t\t  var multipliers = [-1, 5, 7, 9, 4, 6, 10, 5, 7];\n  \t\t  var checksum = 0;\n  \t\t  for (var i = 0; i < multipliers.length; i++) {\n  \t\t    checksum += digits[i] * multipliers[i];\n  \t\t  }\n  \t\t  return checksum % 11 === 10 ? digits[9] === 0 : digits[9] === checksum % 11;\n  \t\t}\n\n  \t\t// Locale lookup objects\n\n  \t\t/*\n  \t\t * Tax id regex formats for various locales\n  \t\t *\n  \t\t * Where not explicitly specified in DG-TAXUD document both\n  \t\t * uppercase and lowercase letters are acceptable.\n  \t\t */\n  \t\tvar taxIdFormat = {\n  \t\t  'bg-BG': /^\\d{10}$/,\n  \t\t  'cs-CZ': /^\\d{6}\\/{0,1}\\d{3,4}$/,\n  \t\t  'de-AT': /^\\d{9}$/,\n  \t\t  'de-DE': /^[1-9]\\d{10}$/,\n  \t\t  'dk-DK': /^\\d{6}-{0,1}\\d{4}$/,\n  \t\t  'el-CY': /^[09]\\d{7}[A-Z]$/,\n  \t\t  'el-GR': /^([0-4]|[7-9])\\d{8}$/,\n  \t\t  'en-CA': /^\\d{9}$/,\n  \t\t  'en-GB': /^\\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\\d{6}[ABCD ]$/i,\n  \t\t  'en-IE': /^\\d{7}[A-W][A-IW]{0,1}$/i,\n  \t\t  'en-US': /^\\d{2}[- ]{0,1}\\d{7}$/,\n  \t\t  'es-AR': /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,\n  \t\t  'es-ES': /^(\\d{0,8}|[XYZKLM]\\d{7})[A-HJ-NP-TV-Z]$/i,\n  \t\t  'et-EE': /^[1-6]\\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\\d$/,\n  \t\t  'fi-FI': /^\\d{6}[-+A]\\d{3}[0-9A-FHJ-NPR-Y]$/i,\n  \t\t  'fr-BE': /^\\d{11}$/,\n  \t\t  'fr-FR': /^[0-3]\\d{12}$|^[0-3]\\d\\s\\d{2}(\\s\\d{3}){3}$/,\n  \t\t  // Conforms both to official spec and provided example\n  \t\t  'fr-LU': /^\\d{13}$/,\n  \t\t  'hr-HR': /^\\d{11}$/,\n  \t\t  'hu-HU': /^8\\d{9}$/,\n  \t\t  'it-IT': /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,\n  \t\t  'lv-LV': /^\\d{6}-{0,1}\\d{5}$/,\n  \t\t  // Conforms both to DG TAXUD spec and original research\n  \t\t  'mt-MT': /^\\d{3,7}[APMGLHBZ]$|^([1-8])\\1\\d{7}$/i,\n  \t\t  'nl-NL': /^\\d{9}$/,\n  \t\t  'pl-PL': /^\\d{10,11}$/,\n  \t\t  'pt-BR': /(?:^\\d{11}$)|(?:^\\d{14}$)/,\n  \t\t  'pt-PT': /^\\d{9}$/,\n  \t\t  'ro-RO': /^\\d{13}$/,\n  \t\t  'sk-SK': /^\\d{6}\\/{0,1}\\d{3,4}$/,\n  \t\t  'sl-SI': /^[1-9]\\d{7}$/,\n  \t\t  'sv-SE': /^(\\d{6}[-+]{0,1}\\d{4}|(18|19|20)\\d{6}[-+]{0,1}\\d{4})$/,\n  \t\t  'uk-UA': /^\\d{10}$/\n  \t\t};\n  \t\t// taxIdFormat locale aliases\n  \t\ttaxIdFormat['lb-LU'] = taxIdFormat['fr-LU'];\n  \t\ttaxIdFormat['lt-LT'] = taxIdFormat['et-EE'];\n  \t\ttaxIdFormat['nl-BE'] = taxIdFormat['fr-BE'];\n  \t\ttaxIdFormat['fr-CA'] = taxIdFormat['en-CA'];\n\n  \t\t// Algorithmic tax id check functions for various locales\n  \t\tvar taxIdCheck = {\n  \t\t  'bg-BG': bgBgCheck,\n  \t\t  'cs-CZ': csCzCheck,\n  \t\t  'de-AT': deAtCheck,\n  \t\t  'de-DE': deDeCheck,\n  \t\t  'dk-DK': dkDkCheck,\n  \t\t  'el-CY': elCyCheck,\n  \t\t  'el-GR': elGrCheck,\n  \t\t  'en-CA': isCanadianSIN,\n  \t\t  'en-IE': enIeCheck,\n  \t\t  'en-US': enUsCheck,\n  \t\t  'es-AR': esArCheck,\n  \t\t  'es-ES': esEsCheck,\n  \t\t  'et-EE': etEeCheck,\n  \t\t  'fi-FI': fiFiCheck,\n  \t\t  'fr-BE': frBeCheck,\n  \t\t  'fr-FR': frFrCheck,\n  \t\t  'fr-LU': frLuCheck,\n  \t\t  'hr-HR': hrHrCheck,\n  \t\t  'hu-HU': huHuCheck,\n  \t\t  'it-IT': itItCheck,\n  \t\t  'lv-LV': lvLvCheck,\n  \t\t  'mt-MT': mtMtCheck,\n  \t\t  'nl-NL': nlNlCheck,\n  \t\t  'pl-PL': plPlCheck,\n  \t\t  'pt-BR': ptBrCheck,\n  \t\t  'pt-PT': ptPtCheck,\n  \t\t  'ro-RO': roRoCheck,\n  \t\t  'sk-SK': skSkCheck,\n  \t\t  'sl-SI': slSiCheck,\n  \t\t  'sv-SE': svSeCheck,\n  \t\t  'uk-UA': ukUaCheck\n  \t\t};\n  \t\t// taxIdCheck locale aliases\n  \t\ttaxIdCheck['lb-LU'] = taxIdCheck['fr-LU'];\n  \t\ttaxIdCheck['lt-LT'] = taxIdCheck['et-EE'];\n  \t\ttaxIdCheck['nl-BE'] = taxIdCheck['fr-BE'];\n  \t\ttaxIdCheck['fr-CA'] = taxIdCheck['en-CA'];\n\n  \t\t// Regexes for locales where characters should be omitted before checking format\n  \t\tvar allsymbols = /[-\\\\\\/!@#$%\\^&\\*\\(\\)\\+\\=\\[\\]]+/g;\n  \t\tvar sanitizeRegexes = {\n  \t\t  'de-AT': allsymbols,\n  \t\t  'de-DE': /[\\/\\\\]/g,\n  \t\t  'fr-BE': allsymbols\n  \t\t};\n  \t\t// sanitizeRegexes locale aliases\n  \t\tsanitizeRegexes['nl-BE'] = sanitizeRegexes['fr-BE'];\n\n  \t\t/*\n  \t\t * Validator function\n  \t\t * Return true if the passed string is a valid tax identification number\n  \t\t * for the specified locale.\n  \t\t * Throw an error exception if the locale is not supported.\n  \t\t */\n  \t\tfunction isTaxID(str) {\n  \t\t  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';\n  \t\t  (0, _assertString.default)(str);\n  \t\t  // Copy TIN to avoid replacement if sanitized\n  \t\t  var strcopy = str.slice(0);\n  \t\t  if (locale in taxIdFormat) {\n  \t\t    if (locale in sanitizeRegexes) {\n  \t\t      strcopy = strcopy.replace(sanitizeRegexes[locale], '');\n  \t\t    }\n  \t\t    if (!taxIdFormat[locale].test(strcopy)) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (locale in taxIdCheck) {\n  \t\t      return taxIdCheck[locale](strcopy);\n  \t\t    }\n  \t\t    // Fallthrough; not all locales have algorithmic checks\n  \t\t    return true;\n  \t\t  }\n  \t\t  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isTaxID, isTaxID.exports));\n  \treturn isTaxID.exports;\n  }\n\n  var isMobilePhone = {};\n\n  var hasRequiredIsMobilePhone;\n\n  function requireIsMobilePhone () {\n  \tif (hasRequiredIsMobilePhone) return isMobilePhone;\n  \thasRequiredIsMobilePhone = 1;\n\n  \tObject.defineProperty(isMobilePhone, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisMobilePhone.default = isMobilePhone$1;\n  \tisMobilePhone.locales = void 0;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t/* eslint-disable max-len */\n  \tvar phones = {\n  \t  'am-AM': /^(\\+?374|0)(33|4[134]|55|77|88|9[13-689])\\d{6}$/,\n  \t  'ar-AE': /^((\\+?971)|0)?5[024568]\\d{7}$/,\n  \t  'ar-BH': /^(\\+?973)?(3|6)\\d{7}$/,\n  \t  'ar-DZ': /^(\\+?213|0)(5|6|7)\\d{8}$/,\n  \t  'ar-LB': /^(\\+?961)?((3|81)\\d{6}|7\\d{7})$/,\n  \t  'ar-EG': /^((\\+?20)|0)?1[0125]\\d{8}$/,\n  \t  'ar-IQ': /^(\\+?964|0)?7[0-9]\\d{8}$/,\n  \t  'ar-JO': /^(\\+?962|0)?7[789]\\d{7}$/,\n  \t  'ar-KW': /^(\\+?965)([569]\\d{7}|41\\d{6})$/,\n  \t  'ar-LY': /^((\\+?218)|0)?(9[1-6]\\d{7}|[1-8]\\d{7,9})$/,\n  \t  'ar-MA': /^(?:(?:\\+|00)212|0)[5-7]\\d{8}$/,\n  \t  'ar-OM': /^((\\+|00)968)?([79][1-9])\\d{6}$/,\n  \t  'ar-PS': /^(\\+?970|0)5[6|9](\\d{7})$/,\n  \t  'ar-SA': /^(!?(\\+?966)|0)?5\\d{8}$/,\n  \t  'ar-SD': /^((\\+?249)|0)?(9[012369]|1[012])\\d{7}$/,\n  \t  'ar-SY': /^(!?(\\+?963)|0)?9\\d{8}$/,\n  \t  'ar-TN': /^(\\+?216)?[2459]\\d{7}$/,\n  \t  'az-AZ': /^(\\+994|0)(10|5[015]|7[07]|99)\\d{7}$/,\n  \t  'ar-QA': /^(\\+?974|0)?([3567]\\d{7})$/,\n  \t  'bs-BA': /^((((\\+|00)3876)|06))((([0-3]|[5-6])\\d{6})|(4\\d{7}))$/,\n  \t  'be-BY': /^(\\+?375)?(24|25|29|33|44)\\d{7}$/,\n  \t  'bg-BG': /^(\\+?359|0)?8[789]\\d{7}$/,\n  \t  'bn-BD': /^(\\+?880|0)1[13456789][0-9]{8}$/,\n  \t  'ca-AD': /^(\\+376)?[346]\\d{5}$/,\n  \t  'cs-CZ': /^(\\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,\n  \t  'da-DK': /^(\\+?45)?\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}$/,\n  \t  'de-DE': /^((\\+49|0)1)(5[0-25-9]\\d|6([23]|0\\d?)|7([0-57-9]|6\\d))\\d{7,9}$/,\n  \t  'de-AT': /^(\\+43|0)\\d{1,4}\\d{3,12}$/,\n  \t  'de-CH': /^(\\+41|0)([1-9])\\d{1,9}$/,\n  \t  'de-LU': /^(\\+352)?((6\\d1)\\d{6})$/,\n  \t  'dv-MV': /^(\\+?960)?(7[2-9]|9[1-9])\\d{5}$/,\n  \t  'el-GR': /^(\\+?30|0)?6(8[5-9]|9(?![26])[0-9])\\d{7}$/,\n  \t  'el-CY': /^(\\+?357?)?(9(9|7|6|5|4)\\d{6})$/,\n  \t  'en-AI': /^(\\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\\d{4}$/,\n  \t  'en-AU': /^(\\+?61|0)4\\d{8}$/,\n  \t  'en-AG': /^(?:\\+1|1)268(?:464|7(?:1[3-9]|[28]\\d|3[0246]|64|7[0-689]))\\d{4}$/,\n  \t  'en-BM': /^(\\+?1)?441(((3|7)\\d{6}$)|(5[0-3][0-9]\\d{4}$)|(59\\d{5}$))/,\n  \t  'en-BS': /^(\\+?1[-\\s]?|0)?\\(?242\\)?[-\\s]?\\d{3}[-\\s]?\\d{4}$/,\n  \t  'en-GB': /^(\\+?44|0)7[1-9]\\d{8}$/,\n  \t  'en-GG': /^(\\+?44|0)1481\\d{6}$/,\n  \t  'en-GH': /^(\\+233|0)(20|50|24|54|27|57|26|56|23|53|28|55|59)\\d{7}$/,\n  \t  'en-GY': /^(\\+592|0)6\\d{6}$/,\n  \t  'en-HK': /^(\\+?852[-\\s]?)?[456789]\\d{3}[-\\s]?\\d{4}$/,\n  \t  'en-MO': /^(\\+?853[-\\s]?)?[6]\\d{3}[-\\s]?\\d{4}$/,\n  \t  'en-IE': /^(\\+?353|0)8[356789]\\d{7}$/,\n  \t  'en-IN': /^(\\+?91|0)?[6789]\\d{9}$/,\n  \t  'en-JM': /^(\\+?876)?\\d{7}$/,\n  \t  'en-KE': /^(\\+?254|0)(7|1)\\d{8}$/,\n  \t  'fr-CF': /^(\\+?236| ?)(70|75|77|72|21|22)\\d{6}$/,\n  \t  'en-SS': /^(\\+?211|0)(9[1257])\\d{7}$/,\n  \t  'en-KI': /^((\\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,\n  \t  'en-KN': /^(?:\\+1|1)869(?:46\\d|48[89]|55[6-8]|66\\d|76[02-7])\\d{4}$/,\n  \t  'en-LS': /^(\\+?266)(22|28|57|58|59|27|52)\\d{6}$/,\n  \t  'en-MT': /^(\\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,\n  \t  'en-MU': /^(\\+?230|0)?\\d{8}$/,\n  \t  'en-MW': /^(\\+?265|0)(((77|88|31|99|98|21)\\d{7})|(((111)|1)\\d{6})|(32000\\d{4}))$/,\n  \t  'en-NA': /^(\\+?264|0)(6|8)\\d{7}$/,\n  \t  'en-NG': /^(\\+?234|0)?[789]\\d{9}$/,\n  \t  'en-NZ': /^(\\+?64|0)[28]\\d{7,9}$/,\n  \t  'en-PG': /^(\\+?675|0)?(7\\d|8[18])\\d{6}$/,\n  \t  'en-PK': /^((00|\\+)?92|0)3[0-6]\\d{8}$/,\n  \t  'en-PH': /^(09|\\+639)\\d{9}$/,\n  \t  'en-RW': /^(\\+?250|0)?[7]\\d{8}$/,\n  \t  'en-SG': /^(\\+65)?[3689]\\d{7}$/,\n  \t  'en-SL': /^(\\+?232|0)\\d{8}$/,\n  \t  'en-TZ': /^(\\+?255|0)?[67]\\d{8}$/,\n  \t  'en-UG': /^(\\+?256|0)?[7]\\d{8}$/,\n  \t  'en-US': /^((\\+1|1)?( |-)?)?(\\([2-9][0-9]{2}\\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,\n  \t  'en-ZA': /^(\\+?27|0)\\d{9}$/,\n  \t  'en-ZM': /^(\\+?26)?0[79][567]\\d{7}$/,\n  \t  'en-ZW': /^(\\+263)[0-9]{9}$/,\n  \t  'en-BW': /^(\\+?267)?(7[1-8]{1})\\d{6}$/,\n  \t  'es-AR': /^\\+?549(11|[2368]\\d)\\d{8}$/,\n  \t  'es-BO': /^(\\+?591)?(6|7)\\d{7}$/,\n  \t  'es-CO': /^(\\+?57)?3(0(0|1|2|4|5)|1\\d|2[0-4]|5(0|1))\\d{7}$/,\n  \t  'es-CL': /^(\\+?56|0)[2-9]\\d{1}\\d{7}$/,\n  \t  'es-CR': /^(\\+506)?[2-8]\\d{7}$/,\n  \t  'es-CU': /^(\\+53|0053)?5\\d{7}$/,\n  \t  'es-DO': /^(\\+?1)?8[024]9\\d{7}$/,\n  \t  'es-HN': /^(\\+?504)?[9|8|3|2]\\d{7}$/,\n  \t  'es-EC': /^(\\+?593|0)([2-7]|9[2-9])\\d{7}$/,\n  \t  'es-ES': /^(\\+?34)?[6|7]\\d{8}$/,\n  \t  'es-GT': /^(\\+?502)?[2|6|7]\\d{7}$/,\n  \t  'es-PE': /^(\\+?51)?9\\d{8}$/,\n  \t  'es-MX': /^(\\+?52)?(1|01)?\\d{10,11}$/,\n  \t  'es-NI': /^(\\+?505)\\d{7,8}$/,\n  \t  'es-PA': /^(\\+?507)\\d{7,8}$/,\n  \t  'es-PY': /^(\\+?595|0)9[9876]\\d{7}$/,\n  \t  'es-SV': /^(\\+?503)?[67]\\d{7}$/,\n  \t  'es-UY': /^(\\+598|0)9[1-9][\\d]{6}$/,\n  \t  'es-VE': /^(\\+?58)?(2|4)\\d{9}$/,\n  \t  'et-EE': /^(\\+?372)?\\s?(5|8[1-4])\\s?([0-9]\\s?){6,7}$/,\n  \t  'fa-IR': /^(\\+?98[\\-\\s]?|0)9[0-39]\\d[\\-\\s]?\\d{3}[\\-\\s]?\\d{4}$/,\n  \t  'fi-FI': /^(\\+?358|0)\\s?(4[0-6]|50)\\s?(\\d\\s?){4,8}$/,\n  \t  'fj-FJ': /^(\\+?679)?\\s?\\d{3}\\s?\\d{4}$/,\n  \t  'fo-FO': /^(\\+?298)?\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}$/,\n  \t  'fr-BF': /^(\\+226|0)[67]\\d{7}$/,\n  \t  'fr-BJ': /^(\\+229)\\d{8}$/,\n  \t  'fr-CD': /^(\\+?243|0)?(8|9)\\d{8}$/,\n  \t  'fr-CM': /^(\\+?237)6[0-9]{8}$/,\n  \t  'fr-FR': /^(\\+?33|0)[67]\\d{8}$/,\n  \t  'fr-GF': /^(\\+?594|0|00594)[67]\\d{8}$/,\n  \t  'fr-GP': /^(\\+?590|0|00590)[67]\\d{8}$/,\n  \t  'fr-MQ': /^(\\+?596|0|00596)[67]\\d{8}$/,\n  \t  'fr-PF': /^(\\+?689)?8[789]\\d{6}$/,\n  \t  'fr-RE': /^(\\+?262|0|00262)[67]\\d{8}$/,\n  \t  'fr-WF': /^(\\+681)?\\d{6}$/,\n  \t  'he-IL': /^(\\+972|0)([23489]|5[012345689]|77)[1-9]\\d{6}$/,\n  \t  'hu-HU': /^(\\+?36|06)(20|30|31|50|70)\\d{7}$/,\n  \t  'id-ID': /^(\\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\\s?|\\d]{5,11})$/,\n  \t  'ir-IR': /^(\\+98|0)?9\\d{9}$/,\n  \t  'it-IT': /^(\\+?39)?\\s?3\\d{2} ?\\d{6,7}$/,\n  \t  'it-SM': /^((\\+378)|(0549)|(\\+390549)|(\\+3780549))?6\\d{5,9}$/,\n  \t  'ja-JP': /^(\\+81[ \\-]?(\\(0\\))?|0)[6789]0[ \\-]?\\d{4}[ \\-]?\\d{4}$/,\n  \t  'ka-GE': /^(\\+?995)?(79\\d{7}|5\\d{8})$/,\n  \t  'kk-KZ': /^(\\+?7|8)?7\\d{9}$/,\n  \t  'kl-GL': /^(\\+?299)?\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}$/,\n  \t  'ko-KR': /^((\\+?82)[ \\-]?)?0?1([0|1|6|7|8|9]{1})[ \\-]?\\d{3,4}[ \\-]?\\d{4}$/,\n  \t  'ky-KG': /^(\\+996\\s?)?(22[0-9]|50[0-9]|55[0-9]|70[0-9]|75[0-9]|77[0-9]|880|990|995|996|997|998)\\s?\\d{3}\\s?\\d{3}$/,\n  \t  'lt-LT': /^(\\+370|8)\\d{8}$/,\n  \t  'lv-LV': /^(\\+?371)2\\d{7}$/,\n  \t  'mg-MG': /^((\\+?261|0)(2|3)\\d)?\\d{7}$/,\n  \t  'mn-MN': /^(\\+|00|011)?976(77|81|88|91|94|95|96|99)\\d{6}$/,\n  \t  'my-MM': /^(\\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,\n  \t  'ms-MY': /^(\\+?60|0)1(([0145](-|\\s)?\\d{7,8})|([236-9](-|\\s)?\\d{7}))$/,\n  \t  'mz-MZ': /^(\\+?258)?8[234567]\\d{7}$/,\n  \t  'nb-NO': /^(\\+?47)?[49]\\d{7}$/,\n  \t  'ne-NP': /^(\\+?977)?9[78]\\d{8}$/,\n  \t  'nl-BE': /^(\\+?32|0)4\\d{8}$/,\n  \t  'nl-NL': /^(((\\+|00)?31\\(0\\))|((\\+|00)?31)|0)6{1}\\d{8}$/,\n  \t  'nl-AW': /^(\\+)?297(56|59|64|73|74|99)\\d{5}$/,\n  \t  'nn-NO': /^(\\+?47)?[49]\\d{7}$/,\n  \t  'pl-PL': /^(\\+?48)? ?([5-8]\\d|45) ?\\d{3} ?\\d{2} ?\\d{2}$/,\n  \t  'pt-BR': /^((\\+?55\\ ?[1-9]{2}\\ ?)|(\\+?55\\ ?\\([1-9]{2}\\)\\ ?)|(0[1-9]{2}\\ ?)|(\\([1-9]{2}\\)\\ ?)|([1-9]{2}\\ ?))((\\d{4}\\-?\\d{4})|(9[1-9]{1}\\d{3}\\-?\\d{4}))$/,\n  \t  'pt-PT': /^(\\+?351)?9[1236]\\d{7}$/,\n  \t  'pt-AO': /^(\\+?244)?9\\d{8}$/,\n  \t  'ro-MD': /^(\\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\\d{6}$/,\n  \t  'ro-RO': /^(\\+?40|0)\\s?7\\d{2}(\\/|\\s|\\.|-)?\\d{3}(\\s|\\.|-)?\\d{3}$/,\n  \t  'ru-RU': /^(\\+?7|8)?9\\d{9}$/,\n  \t  'si-LK': /^(?:0|94|\\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\\d{7}$/,\n  \t  'sl-SI': /^(\\+386\\s?|0)(\\d{1}\\s?\\d{3}\\s?\\d{2}\\s?\\d{2}|\\d{2}\\s?\\d{3}\\s?\\d{3})$/,\n  \t  'sk-SK': /^(\\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,\n  \t  'so-SO': /^(\\+?252|0)((6[0-9])\\d{7}|(7[1-9])\\d{7})$/,\n  \t  'sq-AL': /^(\\+355|0)6[2-9]\\d{7}$/,\n  \t  'sr-RS': /^(\\+3816|06)[- \\d]{5,9}$/,\n  \t  'sv-SE': /^(\\+?46|0)[\\s\\-]?7[\\s\\-]?[02369]([\\s\\-]?\\d){7}$/,\n  \t  'tg-TJ': /^(\\+?992)?[5][5]\\d{7}$/,\n  \t  'th-TH': /^(\\+66|66|0)\\d{9}$/,\n  \t  'tr-TR': /^(\\+?90|0)?5\\d{9}$/,\n  \t  'tk-TM': /^(\\+993|993|8)\\d{8}$/,\n  \t  'uk-UA': /^(\\+?38)?0(50|6[36-8]|7[357]|9[1-9])\\d{7}$/,\n  \t  'uz-UZ': /^(\\+?998)?(6[125-79]|7[1-69]|88|9\\d)\\d{7}$/,\n  \t  'vi-VN': /^((\\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,\n  \t  'zh-CN': /^((\\+|00)86)?(1[3-9]|9[28])\\d{9}$/,\n  \t  'zh-TW': /^(\\+?886\\-?|0)?9\\d{8}$/,\n  \t  'dz-BT': /^(\\+?975|0)?(17|16|77|02)\\d{6}$/,\n  \t  'ar-YE': /^(((\\+|00)9677|0?7)[0137]\\d{7}|((\\+|00)967|0)[1-7]\\d{6})$/,\n  \t  'ar-EH': /^(\\+?212|0)[\\s\\-]?(5288|5289)[\\s\\-]?\\d{5}$/,\n  \t  'fa-AF': /^(\\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\\d{7})$/,\n  \t  'mk-MK': /^(\\+?389|0)?((?:2[2-9]\\d{6}|(?:3[1-4]|4[2-8])\\d{6}|500\\d{5}|5[2-9]\\d{6}|7[0-9][2-9]\\d{5}|8[1-9]\\d{6}|800\\d{5}|8009\\d{4}))$/\n  \t};\n  \t/* eslint-enable max-len */\n\n  \t// aliases\n  \tphones['en-CA'] = phones['en-US'];\n  \tphones['fr-CA'] = phones['en-CA'];\n  \tphones['fr-BE'] = phones['nl-BE'];\n  \tphones['zh-HK'] = phones['en-HK'];\n  \tphones['zh-MO'] = phones['en-MO'];\n  \tphones['ga-IE'] = phones['en-IE'];\n  \tphones['fr-CH'] = phones['de-CH'];\n  \tphones['it-CH'] = phones['fr-CH'];\n  \tfunction isMobilePhone$1(str, locale, options) {\n  \t  (0, _assertString.default)(str);\n  \t  if (options && options.strictMode && !str.startsWith('+')) {\n  \t    return false;\n  \t  }\n  \t  if (Array.isArray(locale)) {\n  \t    return locale.some(function (key) {\n  \t      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n  \t      // istanbul ignore else\n  \t      if (phones.hasOwnProperty(key)) {\n  \t        var phone = phones[key];\n  \t        if (phone.test(str)) {\n  \t          return true;\n  \t        }\n  \t      }\n  \t      return false;\n  \t    });\n  \t  } else if (locale in phones) {\n  \t    return phones[locale].test(str);\n  \t    // alias falsey locale as 'any'\n  \t  } else if (!locale || locale === 'any') {\n  \t    for (var key in phones) {\n  \t      // istanbul ignore else\n  \t      if (phones.hasOwnProperty(key)) {\n  \t        var phone = phones[key];\n  \t        if (phone.test(str)) {\n  \t          return true;\n  \t        }\n  \t      }\n  \t    }\n  \t    return false;\n  \t  }\n  \t  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n  \t}\n  \tisMobilePhone.locales = Object.keys(phones);\n  \treturn isMobilePhone;\n  }\n\n  var isEthereumAddress = {exports: {}};\n\n  var hasRequiredIsEthereumAddress;\n\n  function requireIsEthereumAddress () {\n  \tif (hasRequiredIsEthereumAddress) return isEthereumAddress.exports;\n  \thasRequiredIsEthereumAddress = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isEthereumAddress;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar eth = /^(0x)[0-9a-f]{40}$/i;\n  \t\tfunction isEthereumAddress(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return eth.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isEthereumAddress, isEthereumAddress.exports));\n  \treturn isEthereumAddress.exports;\n  }\n\n  var isCurrency = {exports: {}};\n\n  var hasRequiredIsCurrency;\n\n  function requireIsCurrency () {\n  \tif (hasRequiredIsCurrency) return isCurrency.exports;\n  \thasRequiredIsCurrency = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isCurrency;\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction currencyRegex(options) {\n  \t\t  var decimal_digits = \"\\\\d{\".concat(options.digits_after_decimal[0], \"}\");\n  \t\t  options.digits_after_decimal.forEach(function (digit, index) {\n  \t\t    if (index !== 0) decimal_digits = \"\".concat(decimal_digits, \"|\\\\d{\").concat(digit, \"}\");\n  \t\t  });\n  \t\t  var symbol = \"(\".concat(options.symbol.replace(/\\W/, function (m) {\n  \t\t      return \"\\\\\".concat(m);\n  \t\t    }), \")\").concat(options.require_symbol ? '' : '?'),\n  \t\t    negative = '-?',\n  \t\t    whole_dollar_amount_without_sep = '[1-9]\\\\d*',\n  \t\t    whole_dollar_amount_with_sep = \"[1-9]\\\\d{0,2}(\\\\\".concat(options.thousands_separator, \"\\\\d{3})*\"),\n  \t\t    valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],\n  \t\t    whole_dollar_amount = \"(\".concat(valid_whole_dollar_amounts.join('|'), \")?\"),\n  \t\t    decimal_amount = \"(\\\\\".concat(options.decimal_separator, \"(\").concat(decimal_digits, \"))\").concat(options.require_decimal ? '' : '?');\n  \t\t  var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : '');\n\n  \t\t  // default is negative sign before symbol, but there are two other options (besides parens)\n  \t\t  if (options.allow_negatives && !options.parens_for_negatives) {\n  \t\t    if (options.negative_sign_after_digits) {\n  \t\t      pattern += negative;\n  \t\t    } else if (options.negative_sign_before_digits) {\n  \t\t      pattern = negative + pattern;\n  \t\t    }\n  \t\t  }\n\n  \t\t  // South African Rand, for example, uses R 123 (space) and R-123 (no space)\n  \t\t  if (options.allow_negative_sign_placeholder) {\n  \t\t    pattern = \"( (?!\\\\-))?\".concat(pattern);\n  \t\t  } else if (options.allow_space_after_symbol) {\n  \t\t    pattern = \" ?\".concat(pattern);\n  \t\t  } else if (options.allow_space_after_digits) {\n  \t\t    pattern += '( (?!$))?';\n  \t\t  }\n  \t\t  if (options.symbol_after_digits) {\n  \t\t    pattern += symbol;\n  \t\t  } else {\n  \t\t    pattern = symbol + pattern;\n  \t\t  }\n  \t\t  if (options.allow_negatives) {\n  \t\t    if (options.parens_for_negatives) {\n  \t\t      pattern = \"(\\\\(\".concat(pattern, \"\\\\)|\").concat(pattern, \")\");\n  \t\t    } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {\n  \t\t      pattern = negative + pattern;\n  \t\t    }\n  \t\t  }\n\n  \t\t  // ensure there's a dollar and/or decimal amount, and that\n  \t\t  // it doesn't start with a space or a negative sign followed by a space\n  \t\t  return new RegExp(\"^(?!-? )(?=.*\\\\d)\".concat(pattern, \"$\"));\n  \t\t}\n  \t\tvar default_currency_options = {\n  \t\t  symbol: '$',\n  \t\t  require_symbol: false,\n  \t\t  allow_space_after_symbol: false,\n  \t\t  symbol_after_digits: false,\n  \t\t  allow_negatives: true,\n  \t\t  parens_for_negatives: false,\n  \t\t  negative_sign_before_digits: false,\n  \t\t  negative_sign_after_digits: false,\n  \t\t  allow_negative_sign_placeholder: false,\n  \t\t  thousands_separator: ',',\n  \t\t  decimal_separator: '.',\n  \t\t  allow_decimal: true,\n  \t\t  require_decimal: false,\n  \t\t  digits_after_decimal: [2],\n  \t\t  allow_space_after_digits: false\n  \t\t};\n  \t\tfunction isCurrency(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = (0, _merge.default)(options, default_currency_options);\n  \t\t  return currencyRegex(options).test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isCurrency, isCurrency.exports));\n  \treturn isCurrency.exports;\n  }\n\n  var isBtcAddress = {exports: {}};\n\n  var hasRequiredIsBtcAddress;\n\n  function requireIsBtcAddress () {\n  \tif (hasRequiredIsBtcAddress) return isBtcAddress.exports;\n  \thasRequiredIsBtcAddress = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isBtcAddress;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar bech32 = /^(bc1|tb1|bc1p|tb1p)[ac-hj-np-z02-9]{39,58}$/;\n  \t\tvar base58 = /^(1|2|3|m)[A-HJ-NP-Za-km-z1-9]{25,39}$/;\n  \t\tfunction isBtcAddress(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return bech32.test(str) || base58.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isBtcAddress, isBtcAddress.exports));\n  \treturn isBtcAddress.exports;\n  }\n\n  var isISO6346 = {};\n\n  var hasRequiredIsISO6346;\n\n  function requireIsISO6346 () {\n  \tif (hasRequiredIsISO6346) return isISO6346;\n  \thasRequiredIsISO6346 = 1;\n\n  \tObject.defineProperty(isISO6346, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisISO6346.isFreightContainerID = void 0;\n  \tisISO6346.isISO6346 = isISO6346$1;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t// https://en.wikipedia.org/wiki/ISO_6346\n  \t// according to ISO6346 standard, checksum digit is mandatory for freight container but recommended\n  \t// for other container types (J and Z)\n  \tvar isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;\n  \tvar isDigit = /^[0-9]$/;\n  \tfunction isISO6346$1(str) {\n  \t  (0, _assertString.default)(str);\n  \t  str = str.toUpperCase();\n  \t  if (!isISO6346Str.test(str)) return false;\n  \t  if (str.length === 11) {\n  \t    var sum = 0;\n  \t    for (var i = 0; i < str.length - 1; i++) {\n  \t      if (!isDigit.test(str[i])) {\n  \t        var convertedCode = void 0;\n  \t        var letterCode = str.charCodeAt(i) - 55;\n  \t        if (letterCode < 11) convertedCode = letterCode;else if (letterCode >= 11 && letterCode <= 20) convertedCode = 12 + letterCode % 11;else if (letterCode >= 21 && letterCode <= 30) convertedCode = 23 + letterCode % 21;else convertedCode = 34 + letterCode % 31;\n  \t        sum += convertedCode * Math.pow(2, i);\n  \t      } else sum += str[i] * Math.pow(2, i);\n  \t    }\n  \t    var checkSumDigit = sum % 11;\n  \t    if (checkSumDigit === 10) checkSumDigit = 0;\n  \t    return Number(str[str.length - 1]) === checkSumDigit;\n  \t  }\n  \t  return true;\n  \t}\n  \tisISO6346.isFreightContainerID = isISO6346$1;\n  \treturn isISO6346;\n  }\n\n  var isISO6391 = {exports: {}};\n\n  var hasRequiredIsISO6391;\n\n  function requireIsISO6391 () {\n  \tif (hasRequiredIsISO6391) return isISO6391.exports;\n  \thasRequiredIsISO6391 = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isISO6391;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar isISO6391Set = new Set(['aa', 'ab', 'ae', 'af', 'ak', 'am', 'an', 'ar', 'as', 'av', 'ay', 'az', 'az', 'ba', 'be', 'bg', 'bh', 'bi', 'bm', 'bn', 'bo', 'br', 'bs', 'ca', 'ce', 'ch', 'co', 'cr', 'cs', 'cu', 'cv', 'cy', 'da', 'de', 'dv', 'dz', 'ee', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'ff', 'fi', 'fj', 'fo', 'fr', 'fy', 'ga', 'gd', 'gl', 'gn', 'gu', 'gv', 'ha', 'he', 'hi', 'ho', 'hr', 'ht', 'hu', 'hy', 'hz', 'ia', 'id', 'ie', 'ig', 'ii', 'ik', 'io', 'is', 'it', 'iu', 'ja', 'jv', 'ka', 'kg', 'ki', 'kj', 'kk', 'kl', 'km', 'kn', 'ko', 'kr', 'ks', 'ku', 'kv', 'kw', 'ky', 'la', 'lb', 'lg', 'li', 'ln', 'lo', 'lt', 'lu', 'lv', 'mg', 'mh', 'mi', 'mk', 'ml', 'mn', 'mr', 'ms', 'mt', 'my', 'na', 'nb', 'nd', 'ne', 'ng', 'nl', 'nn', 'no', 'nr', 'nv', 'ny', 'oc', 'oj', 'om', 'or', 'os', 'pa', 'pi', 'pl', 'ps', 'pt', 'qu', 'rm', 'rn', 'ro', 'ru', 'rw', 'sa', 'sc', 'sd', 'se', 'sg', 'si', 'sk', 'sl', 'sm', 'sn', 'so', 'sq', 'sr', 'ss', 'st', 'su', 'sv', 'sw', 'ta', 'te', 'tg', 'th', 'ti', 'tk', 'tl', 'tn', 'to', 'tr', 'ts', 'tt', 'tw', 'ty', 'ug', 'uk', 'ur', 'uz', 've', 'vi', 'vo', 'wa', 'wo', 'xh', 'yi', 'yo', 'za', 'zh', 'zu']);\n  \t\tfunction isISO6391(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return isISO6391Set.has(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isISO6391, isISO6391.exports));\n  \treturn isISO6391.exports;\n  }\n\n  var isISO8601 = {exports: {}};\n\n  var hasRequiredIsISO8601;\n\n  function requireIsISO8601 () {\n  \tif (hasRequiredIsISO8601) return isISO8601.exports;\n  \thasRequiredIsISO8601 = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isISO8601;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t/* eslint-disable max-len */\n  \t\t// from http://goo.gl/0ejHHW\n  \t\tvar iso8601 = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n  \t\t// same as above, except with a strict 'T' separator between date and time\n  \t\tvar iso8601StrictSeparator = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n  \t\t/* eslint-enable max-len */\n  \t\tvar isValidDate = function isValidDate(str) {\n  \t\t  // str must have passed the ISO8601 check\n  \t\t  // this check is meant to catch invalid dates\n  \t\t  // like 2009-02-31\n  \t\t  // first check for ordinal dates\n  \t\t  var ordinalMatch = str.match(/^(\\d{4})-?(\\d{3})([ T]{1}\\.*|$)/);\n  \t\t  if (ordinalMatch) {\n  \t\t    var oYear = Number(ordinalMatch[1]);\n  \t\t    var oDay = Number(ordinalMatch[2]);\n  \t\t    // if is leap year\n  \t\t    if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0) return oDay <= 366;\n  \t\t    return oDay <= 365;\n  \t\t  }\n  \t\t  var match = str.match(/(\\d{4})-?(\\d{0,2})-?(\\d*)/).map(Number);\n  \t\t  var year = match[1];\n  \t\t  var month = match[2];\n  \t\t  var day = match[3];\n  \t\t  var monthString = month ? \"0\".concat(month).slice(-2) : month;\n  \t\t  var dayString = day ? \"0\".concat(day).slice(-2) : day;\n\n  \t\t  // create a date object and compare\n  \t\t  var d = new Date(\"\".concat(year, \"-\").concat(monthString || '01', \"-\").concat(dayString || '01'));\n  \t\t  if (month && day) {\n  \t\t    return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;\n  \t\t  }\n  \t\t  return true;\n  \t\t};\n  \t\tfunction isISO8601(str) {\n  \t\t  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);\n  \t\t  if (check && options.strict) return isValidDate(str);\n  \t\t  return check;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isISO8601, isISO8601.exports));\n  \treturn isISO8601.exports;\n  }\n\n  var isRFC3339 = {exports: {}};\n\n  var hasRequiredIsRFC3339;\n\n  function requireIsRFC3339 () {\n  \tif (hasRequiredIsRFC3339) return isRFC3339.exports;\n  \thasRequiredIsRFC3339 = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isRFC3339;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t/* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */\n\n  \t\tvar dateFullYear = /[0-9]{4}/;\n  \t\tvar dateMonth = /(0[1-9]|1[0-2])/;\n  \t\tvar dateMDay = /([12]\\d|0[1-9]|3[01])/;\n  \t\tvar timeHour = /([01][0-9]|2[0-3])/;\n  \t\tvar timeMinute = /[0-5][0-9]/;\n  \t\tvar timeSecond = /([0-5][0-9]|60)/;\n  \t\tvar timeSecFrac = /(\\.[0-9]+)?/;\n  \t\tvar timeNumOffset = new RegExp(\"[-+]\".concat(timeHour.source, \":\").concat(timeMinute.source));\n  \t\tvar timeOffset = new RegExp(\"([zZ]|\".concat(timeNumOffset.source, \")\"));\n  \t\tvar partialTime = new RegExp(\"\".concat(timeHour.source, \":\").concat(timeMinute.source, \":\").concat(timeSecond.source).concat(timeSecFrac.source));\n  \t\tvar fullDate = new RegExp(\"\".concat(dateFullYear.source, \"-\").concat(dateMonth.source, \"-\").concat(dateMDay.source));\n  \t\tvar fullTime = new RegExp(\"\".concat(partialTime.source).concat(timeOffset.source));\n  \t\tvar rfc3339 = new RegExp(\"^\".concat(fullDate.source, \"[ tT]\").concat(fullTime.source, \"$\"));\n  \t\tfunction isRFC3339(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return rfc3339.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isRFC3339, isRFC3339.exports));\n  \treturn isRFC3339.exports;\n  }\n\n  var isISO15924 = {};\n\n  var hasRequiredIsISO15924;\n\n  function requireIsISO15924 () {\n  \tif (hasRequiredIsISO15924) return isISO15924;\n  \thasRequiredIsISO15924 = 1;\n\n  \tObject.defineProperty(isISO15924, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisISO15924.ScriptCodes = void 0;\n  \tisISO15924.default = isISO15924$1;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t// from https://www.unicode.org/iso15924/iso15924-codes.html\n  \tvar validISO15924Codes = new Set(['Adlm', 'Afak', 'Aghb', 'Ahom', 'Arab', 'Aran', 'Armi', 'Armn', 'Avst', 'Bali', 'Bamu', 'Bass', 'Batk', 'Beng', 'Bhks', 'Blis', 'Bopo', 'Brah', 'Brai', 'Bugi', 'Buhd', 'Cakm', 'Cans', 'Cari', 'Cham', 'Cher', 'Chis', 'Chrs', 'Cirt', 'Copt', 'Cpmn', 'Cprt', 'Cyrl', 'Cyrs', 'Deva', 'Diak', 'Dogr', 'Dsrt', 'Dupl', 'Egyd', 'Egyh', 'Egyp', 'Elba', 'Elym', 'Ethi', 'Gara', 'Geok', 'Geor', 'Glag', 'Gong', 'Gonm', 'Goth', 'Gran', 'Grek', 'Gujr', 'Gukh', 'Guru', 'Hanb', 'Hang', 'Hani', 'Hano', 'Hans', 'Hant', 'Hatr', 'Hebr', 'Hira', 'Hluw', 'Hmng', 'Hmnp', 'Hrkt', 'Hung', 'Inds', 'Ital', 'Jamo', 'Java', 'Jpan', 'Jurc', 'Kali', 'Kana', 'Kawi', 'Khar', 'Khmr', 'Khoj', 'Kitl', 'Kits', 'Knda', 'Kore', 'Kpel', 'Krai', 'Kthi', 'Lana', 'Laoo', 'Latf', 'Latg', 'Latn', 'Leke', 'Lepc', 'Limb', 'Lina', 'Linb', 'Lisu', 'Loma', 'Lyci', 'Lydi', 'Mahj', 'Maka', 'Mand', 'Mani', 'Marc', 'Maya', 'Medf', 'Mend', 'Merc', 'Mero', 'Mlym', 'Modi', 'Mong', 'Moon', 'Mroo', 'Mtei', 'Mult', 'Mymr', 'Nagm', 'Nand', 'Narb', 'Nbat', 'Newa', 'Nkdb', 'Nkgb', 'Nkoo', 'Nshu', 'Ogam', 'Olck', 'Onao', 'Orkh', 'Orya', 'Osge', 'Osma', 'Ougr', 'Palm', 'Pauc', 'Pcun', 'Pelm', 'Perm', 'Phag', 'Phli', 'Phlp', 'Phlv', 'Phnx', 'Plrd', 'Piqd', 'Prti', 'Psin', 'Qaaa', 'Qaab', 'Qaac', 'Qaad', 'Qaae', 'Qaaf', 'Qaag', 'Qaah', 'Qaai', 'Qaaj', 'Qaak', 'Qaal', 'Qaam', 'Qaan', 'Qaao', 'Qaap', 'Qaaq', 'Qaar', 'Qaas', 'Qaat', 'Qaau', 'Qaav', 'Qaaw', 'Qaax', 'Qaay', 'Qaaz', 'Qaba', 'Qabb', 'Qabc', 'Qabd', 'Qabe', 'Qabf', 'Qabg', 'Qabh', 'Qabi', 'Qabj', 'Qabk', 'Qabl', 'Qabm', 'Qabn', 'Qabo', 'Qabp', 'Qabq', 'Qabr', 'Qabs', 'Qabt', 'Qabu', 'Qabv', 'Qabw', 'Qabx', 'Ranj', 'Rjng', 'Rohg', 'Roro', 'Runr', 'Samr', 'Sara', 'Sarb', 'Saur', 'Sgnw', 'Shaw', 'Shrd', 'Shui', 'Sidd', 'Sidt', 'Sind', 'Sinh', 'Sogd', 'Sogo', 'Sora', 'Soyo', 'Sund', 'Sunu', 'Sylo', 'Syrc', 'Syre', 'Syrj', 'Syrn', 'Tagb', 'Takr', 'Tale', 'Talu', 'Taml', 'Tang', 'Tavt', 'Tayo', 'Telu', 'Teng', 'Tfng', 'Tglg', 'Thaa', 'Thai', 'Tibt', 'Tirh', 'Tnsa', 'Todr', 'Tols', 'Toto', 'Tutg', 'Ugar', 'Vaii', 'Visp', 'Vith', 'Wara', 'Wcho', 'Wole', 'Xpeo', 'Xsux', 'Yezi', 'Yiii', 'Zanb', 'Zinh', 'Zmth', 'Zsye', 'Zsym', 'Zxxx', 'Zyyy', 'Zzzz']);\n  \tfunction isISO15924$1(str) {\n  \t  (0, _assertString.default)(str);\n  \t  return validISO15924Codes.has(str);\n  \t}\n  \tisISO15924.ScriptCodes = validISO15924Codes;\n  \treturn isISO15924;\n  }\n\n  var isISO31661Alpha3 = {exports: {}};\n\n  var hasRequiredIsISO31661Alpha3;\n\n  function requireIsISO31661Alpha3 () {\n  \tif (hasRequiredIsISO31661Alpha3) return isISO31661Alpha3.exports;\n  \thasRequiredIsISO31661Alpha3 = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isISO31661Alpha3;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3\n  \t\tvar validISO31661Alpha3CountriesCodes = new Set(['AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE', 'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA', 'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK', 'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM', 'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB', 'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI', 'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN', 'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE', 'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX', 'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC', 'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN', 'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM', 'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD', 'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL', 'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT', 'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE']);\n  \t\tfunction isISO31661Alpha3(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isISO31661Alpha3, isISO31661Alpha3.exports));\n  \treturn isISO31661Alpha3.exports;\n  }\n\n  var isISO31661Numeric = {exports: {}};\n\n  var hasRequiredIsISO31661Numeric;\n\n  function requireIsISO31661Numeric () {\n  \tif (hasRequiredIsISO31661Numeric) return isISO31661Numeric.exports;\n  \thasRequiredIsISO31661Numeric = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isISO31661Numeric;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t// from https://en.wikipedia.org/wiki/ISO_3166-1_numeric\n  \t\tvar validISO31661NumericCountriesCodes = new Set(['004', '008', '010', '012', '016', '020', '024', '028', '031', '032', '036', '040', '044', '048', '050', '051', '052', '056', '060', '064', '068', '070', '072', '074', '076', '084', '086', '090', '092', '096', '100', '104', '108', '112', '116', '120', '124', '132', '136', '140', '144', '148', '152', '156', '158', '162', '166', '170', '174', '175', '178', '180', '184', '188', '191', '192', '196', '203', '204', '208', '212', '214', '218', '222', '226', '231', '232', '233', '234', '238', '239', '242', '246', '248', '250', '254', '258', '260', '262', '266', '268', '270', '275', '276', '288', '292', '296', '300', '304', '308', '312', '316', '320', '324', '328', '332', '334', '336', '340', '344', '348', '352', '356', '360', '364', '368', '372', '376', '380', '384', '388', '392', '398', '400', '404', '408', '410', '414', '417', '418', '422', '426', '428', '430', '434', '438', '440', '442', '446', '450', '454', '458', '462', '466', '470', '474', '478', '480', '484', '492', '496', '498', '499', '500', '504', '508', '512', '516', '520', '524', '528', '531', '533', '534', '535', '540', '548', '554', '558', '562', '566', '570', '574', '578', '580', '581', '583', '584', '585', '586', '591', '598', '600', '604', '608', '612', '616', '620', '624', '626', '630', '634', '638', '642', '643', '646', '652', '654', '659', '660', '662', '663', '666', '670', '674', '678', '682', '686', '688', '690', '694', '702', '703', '704', '705', '706', '710', '716', '724', '728', '729', '732', '740', '744', '748', '752', '756', '760', '762', '764', '768', '772', '776', '780', '784', '788', '792', '795', '796', '798', '800', '804', '807', '818', '826', '831', '832', '833', '834', '840', '850', '854', '858', '860', '862', '876', '882', '887', '894']);\n  \t\tfunction isISO31661Numeric(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return validISO31661NumericCountriesCodes.has(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isISO31661Numeric, isISO31661Numeric.exports));\n  \treturn isISO31661Numeric.exports;\n  }\n\n  var isISO4217 = {};\n\n  var hasRequiredIsISO4217;\n\n  function requireIsISO4217 () {\n  \tif (hasRequiredIsISO4217) return isISO4217;\n  \thasRequiredIsISO4217 = 1;\n\n  \tObject.defineProperty(isISO4217, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisISO4217.CurrencyCodes = void 0;\n  \tisISO4217.default = isISO4217$1;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t// from https://en.wikipedia.org/wiki/ISO_4217\n  \tvar validISO4217CurrencyCodes = new Set(['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYN', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLE', 'SLL', 'SOS', 'SRD', 'SSP', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'UYI', 'UYU', 'UYW', 'UZS', 'VED', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XAG', 'XAU', 'XBA', 'XBB', 'XBC', 'XBD', 'XCD', 'XDR', 'XOF', 'XPD', 'XPF', 'XPT', 'XSU', 'XTS', 'XUA', 'XXX', 'YER', 'ZAR', 'ZMW', 'ZWL']);\n  \tfunction isISO4217$1(str) {\n  \t  (0, _assertString.default)(str);\n  \t  return validISO4217CurrencyCodes.has(str.toUpperCase());\n  \t}\n  \tisISO4217.CurrencyCodes = validISO4217CurrencyCodes;\n  \treturn isISO4217;\n  }\n\n  var isBase32 = {exports: {}};\n\n  var hasRequiredIsBase32;\n\n  function requireIsBase32 () {\n  \tif (hasRequiredIsBase32) return isBase32.exports;\n  \thasRequiredIsBase32 = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isBase32;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar base32 = /^[A-Z2-7]+=*$/;\n  \t\tvar crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;\n  \t\tvar defaultBase32Options = {\n  \t\t  crockford: false\n  \t\t};\n  \t\tfunction isBase32(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = (0, _merge.default)(options, defaultBase32Options);\n  \t\t  if (options.crockford) {\n  \t\t    return crockfordBase32.test(str);\n  \t\t  }\n  \t\t  var len = str.length;\n  \t\t  if (len % 8 === 0 && base32.test(str)) {\n  \t\t    return true;\n  \t\t  }\n  \t\t  return false;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isBase32, isBase32.exports));\n  \treturn isBase32.exports;\n  }\n\n  var isBase58 = {exports: {}};\n\n  var hasRequiredIsBase58;\n\n  function requireIsBase58 () {\n  \tif (hasRequiredIsBase58) return isBase58.exports;\n  \thasRequiredIsBase58 = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isBase58;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t// Accepted chars - 123456789ABCDEFGH JKLMN PQRSTUVWXYZabcdefghijk mnopqrstuvwxyz\n  \t\tvar base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;\n  \t\tfunction isBase58(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (base58Reg.test(str)) {\n  \t\t    return true;\n  \t\t  }\n  \t\t  return false;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isBase58, isBase58.exports));\n  \treturn isBase58.exports;\n  }\n\n  var isDataURI = {exports: {}};\n\n  var hasRequiredIsDataURI;\n\n  function requireIsDataURI () {\n  \tif (hasRequiredIsDataURI) return isDataURI.exports;\n  \thasRequiredIsDataURI = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isDataURI;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar validMediaType = /^[a-z]+\\/[a-z0-9\\-\\+\\._]+$/i;\n  \t\tvar validAttribute = /^[a-z\\-]+=[a-z0-9\\-]+$/i;\n  \t\tvar validData = /^[a-z0-9!\\$&'\\(\\)\\*\\+,;=\\-\\._~:@\\/\\?%\\s]*$/i;\n  \t\tfunction isDataURI(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var data = str.split(',');\n  \t\t  if (data.length < 2) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var attributes = data.shift().trim().split(';');\n  \t\t  var schemeAndMediaType = attributes.shift();\n  \t\t  if (schemeAndMediaType.slice(0, 5) !== 'data:') {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var mediaType = schemeAndMediaType.slice(5);\n  \t\t  if (mediaType !== '' && !validMediaType.test(mediaType)) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  for (var i = 0; i < attributes.length; i++) {\n  \t\t    if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') && !validAttribute.test(attributes[i])) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  for (var _i = 0; _i < data.length; _i++) {\n  \t\t    if (!validData.test(data[_i])) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isDataURI, isDataURI.exports));\n  \treturn isDataURI.exports;\n  }\n\n  var isMagnetURI = {exports: {}};\n\n  var hasRequiredIsMagnetURI;\n\n  function requireIsMagnetURI () {\n  \tif (hasRequiredIsMagnetURI) return isMagnetURI.exports;\n  \thasRequiredIsMagnetURI = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isMagnetURI;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar magnetURIComponent = /(?:^magnet:\\?|[^?&]&)xt(?:\\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;\n  \t\tfunction isMagnetURI(url) {\n  \t\t  (0, _assertString.default)(url);\n  \t\t  if (url.indexOf('magnet:?') !== 0) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return magnetURIComponent.test(url);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isMagnetURI, isMagnetURI.exports));\n  \treturn isMagnetURI.exports;\n  }\n\n  var isMailtoURI = {exports: {}};\n\n  var trim = {exports: {}};\n\n  var rtrim = {exports: {}};\n\n  var hasRequiredRtrim;\n\n  function requireRtrim () {\n  \tif (hasRequiredRtrim) return rtrim.exports;\n  \thasRequiredRtrim = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = rtrim;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction rtrim(str, chars) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (chars) {\n  \t\t    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n  \t\t    var pattern = new RegExp(\"[\".concat(chars.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), \"]+$\"), 'g');\n  \t\t    return str.replace(pattern, '');\n  \t\t  }\n  \t\t  // Use a faster and more safe than regex trim method https://blog.stevenlevithan.com/archives/faster-trim-javascript\n  \t\t  var strIndex = str.length - 1;\n  \t\t  while (/\\s/.test(str.charAt(strIndex))) {\n  \t\t    strIndex -= 1;\n  \t\t  }\n  \t\t  return str.slice(0, strIndex + 1);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (rtrim, rtrim.exports));\n  \treturn rtrim.exports;\n  }\n\n  var ltrim = {exports: {}};\n\n  var hasRequiredLtrim;\n\n  function requireLtrim () {\n  \tif (hasRequiredLtrim) return ltrim.exports;\n  \thasRequiredLtrim = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = ltrim;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction ltrim(str, chars) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n  \t\t  var pattern = chars ? new RegExp(\"^[\".concat(chars.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), \"]+\"), 'g') : /^\\s+/g;\n  \t\t  return str.replace(pattern, '');\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (ltrim, ltrim.exports));\n  \treturn ltrim.exports;\n  }\n\n  var hasRequiredTrim;\n\n  function requireTrim () {\n  \tif (hasRequiredTrim) return trim.exports;\n  \thasRequiredTrim = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = trim;\n  \t\tvar _rtrim = _interopRequireDefault(requireRtrim());\n  \t\tvar _ltrim = _interopRequireDefault(requireLtrim());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction trim(str, chars) {\n  \t\t  return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (trim, trim.exports));\n  \treturn trim.exports;\n  }\n\n  var hasRequiredIsMailtoURI;\n\n  function requireIsMailtoURI () {\n  \tif (hasRequiredIsMailtoURI) return isMailtoURI.exports;\n  \thasRequiredIsMailtoURI = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isMailtoURI;\n  \t\tvar _trim = _interopRequireDefault(requireTrim());\n  \t\tvar _isEmail = _interopRequireDefault(requireIsEmail());\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\n  \t\tfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n  \t\tfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\n  \t\tfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n  \t\tfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: true } : { done: false, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = true, u = false; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = true, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\n  \t\tfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\n  \t\tfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n  \t\tfunction parseMailtoQueryString(queryString) {\n  \t\t  var allowedParams = new Set(['subject', 'body', 'cc', 'bcc']),\n  \t\t    query = {\n  \t\t      cc: '',\n  \t\t      bcc: ''\n  \t\t    };\n  \t\t  var isParseFailed = false;\n  \t\t  var queryParams = queryString.split('&');\n  \t\t  if (queryParams.length > 4) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var _iterator = _createForOfIteratorHelper(queryParams),\n  \t\t    _step;\n  \t\t  try {\n  \t\t    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n  \t\t      var q = _step.value;\n  \t\t      var _q$split = q.split('='),\n  \t\t        _q$split2 = _slicedToArray(_q$split, 2),\n  \t\t        key = _q$split2[0],\n  \t\t        value = _q$split2[1];\n\n  \t\t      // checked for invalid and duplicated query params\n  \t\t      if (key && !allowedParams.has(key)) {\n  \t\t        isParseFailed = true;\n  \t\t        break;\n  \t\t      }\n  \t\t      if (value && (key === 'cc' || key === 'bcc')) {\n  \t\t        query[key] = value;\n  \t\t      }\n  \t\t      if (key) {\n  \t\t        allowedParams.delete(key);\n  \t\t      }\n  \t\t    }\n  \t\t  } catch (err) {\n  \t\t    _iterator.e(err);\n  \t\t  } finally {\n  \t\t    _iterator.f();\n  \t\t  }\n  \t\t  return isParseFailed ? false : query;\n  \t\t}\n  \t\tfunction isMailtoURI(url, options) {\n  \t\t  (0, _assertString.default)(url);\n  \t\t  if (url.indexOf('mailto:') !== 0) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  var _url$replace$split = url.replace('mailto:', '').split('?'),\n  \t\t    _url$replace$split2 = _slicedToArray(_url$replace$split, 2),\n  \t\t    to = _url$replace$split2[0],\n  \t\t    _url$replace$split2$ = _url$replace$split2[1],\n  \t\t    queryString = _url$replace$split2$ === void 0 ? '' : _url$replace$split2$;\n  \t\t  if (!to && !queryString) {\n  \t\t    return true;\n  \t\t  }\n  \t\t  var query = parseMailtoQueryString(queryString);\n  \t\t  if (!query) {\n  \t\t    return false;\n  \t\t  }\n  \t\t  return \"\".concat(to, \",\").concat(query.cc, \",\").concat(query.bcc).split(',').every(function (email) {\n  \t\t    email = (0, _trim.default)(email, ' ');\n  \t\t    if (email) {\n  \t\t      return (0, _isEmail.default)(email, options);\n  \t\t    }\n  \t\t    return true;\n  \t\t  });\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isMailtoURI, isMailtoURI.exports));\n  \treturn isMailtoURI.exports;\n  }\n\n  var isMimeType = {exports: {}};\n\n  var hasRequiredIsMimeType;\n\n  function requireIsMimeType () {\n  \tif (hasRequiredIsMimeType) return isMimeType.exports;\n  \thasRequiredIsMimeType = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isMimeType;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\t/*\n  \t\t  Checks if the provided string matches to a correct Media type format (MIME type)\n\n  \t\t  This function only checks is the string format follows the\n  \t\t  established rules by the according RFC specifications.\n  \t\t  This function supports 'charset' in textual media types\n  \t\t  (https://tools.ietf.org/html/rfc6657).\n\n  \t\t  This function does not check against all the media types listed\n  \t\t  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)\n  \t\t  because of lightness purposes : it would require to include\n  \t\t  all these MIME types in this library, which would weigh it\n  \t\t  significantly. This kind of effort maybe is not worth for the use that\n  \t\t  this function has in this entire library.\n\n  \t\t  More information in the RFC specifications :\n  \t\t  - https://tools.ietf.org/html/rfc2045\n  \t\t  - https://tools.ietf.org/html/rfc2046\n  \t\t  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n  \t\t  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n  \t\t*/\n\n  \t\t// Match simple MIME types\n  \t\t// NB :\n  \t\t//   Subtype length must not exceed 100 characters.\n  \t\t//   This rule does not comply to the RFC specs (what is the max length ?).\n  \t\tvar mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\\/[a-zA-Z0-9\\.\\-\\+_]{1,100}$/i; // eslint-disable-line max-len\n\n  \t\t// Handle \"charset\" in \"text/*\"\n  \t\tvar mimeTypeText = /^text\\/[a-zA-Z0-9\\.\\-\\+]{1,100};\\s?charset=(\"[a-zA-Z0-9\\.\\-\\+\\s]{0,70}\"|[a-zA-Z0-9\\.\\-\\+]{0,70})(\\s?\\([a-zA-Z0-9\\.\\-\\+\\s]{1,20}\\))?$/i; // eslint-disable-line max-len\n\n  \t\t// Handle \"boundary\" in \"multipart/*\"\n  \t\tvar mimeTypeMultipart = /^multipart\\/[a-zA-Z0-9\\.\\-\\+]{1,100}(;\\s?(boundary|charset)=(\"[a-zA-Z0-9\\.\\-\\+\\s]{0,70}\"|[a-zA-Z0-9\\.\\-\\+]{0,70})(\\s?\\([a-zA-Z0-9\\.\\-\\+\\s]{1,20}\\))?){0,2}$/i; // eslint-disable-line max-len\n\n  \t\tfunction isMimeType(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isMimeType, isMimeType.exports));\n  \treturn isMimeType.exports;\n  }\n\n  var isLatLong = {exports: {}};\n\n  var hasRequiredIsLatLong;\n\n  function requireIsLatLong () {\n  \tif (hasRequiredIsLatLong) return isLatLong.exports;\n  \thasRequiredIsLatLong = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isLatLong;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tvar _includesString = _interopRequireDefault(requireIncludesString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar lat = /^\\(?[+-]?(90(\\.0+)?|[1-8]?\\d(\\.\\d+)?)$/;\n  \t\tvar long = /^\\s?[+-]?(180(\\.0+)?|1[0-7]\\d(\\.\\d+)?|\\d{1,2}(\\.\\d+)?)\\)?$/;\n  \t\tvar latDMS = /^(([1-8]?\\d)\\D+([1-5]?\\d|60)\\D+([1-5]?\\d|60)(\\.\\d+)?|90\\D+0\\D+0)\\D+[NSns]?$/i;\n  \t\tvar longDMS = /^\\s*([1-7]?\\d{1,2}\\D+([1-5]?\\d|60)\\D+([1-5]?\\d|60)(\\.\\d+)?|180\\D+0\\D+0)\\D+[EWew]?$/i;\n  \t\tvar defaultLatLongOptions = {\n  \t\t  checkDMS: false\n  \t\t};\n  \t\tfunction isLatLong(str, options) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  options = (0, _merge.default)(options, defaultLatLongOptions);\n  \t\t  if (!(0, _includesString.default)(str, ',')) return false;\n  \t\t  var pair = str.split(',');\n  \t\t  if (pair[0].startsWith('(') && !pair[1].endsWith(')') || pair[1].endsWith(')') && !pair[0].startsWith('(')) return false;\n  \t\t  if (options.checkDMS) {\n  \t\t    return latDMS.test(pair[0]) && longDMS.test(pair[1]);\n  \t\t  }\n  \t\t  return lat.test(pair[0]) && long.test(pair[1]);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isLatLong, isLatLong.exports));\n  \treturn isLatLong.exports;\n  }\n\n  var isPostalCode = {};\n\n  var hasRequiredIsPostalCode;\n\n  function requireIsPostalCode () {\n  \tif (hasRequiredIsPostalCode) return isPostalCode;\n  \thasRequiredIsPostalCode = 1;\n\n  \tObject.defineProperty(isPostalCode, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisPostalCode.default = isPostalCode$1;\n  \tisPostalCode.locales = void 0;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t// common patterns\n  \tvar threeDigit = /^\\d{3}$/;\n  \tvar fourDigit = /^\\d{4}$/;\n  \tvar fiveDigit = /^\\d{5}$/;\n  \tvar sixDigit = /^\\d{6}$/;\n  \tvar patterns = {\n  \t  AD: /^AD\\d{3}$/,\n  \t  AT: fourDigit,\n  \t  AU: fourDigit,\n  \t  AZ: /^AZ\\d{4}$/,\n  \t  BA: /^([7-8]\\d{4}$)/,\n  \t  BD: /^([1-8][0-9]{3}|9[0-4][0-9]{2})$/,\n  \t  BE: fourDigit,\n  \t  BG: fourDigit,\n  \t  BR: /^\\d{5}-?\\d{3}$/,\n  \t  BY: /^2[1-4]\\d{4}$/,\n  \t  CA: /^[ABCEGHJKLMNPRSTVXY]\\d[ABCEGHJ-NPRSTV-Z][\\s\\-]?\\d[ABCEGHJ-NPRSTV-Z]\\d$/i,\n  \t  CH: fourDigit,\n  \t  CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\\d{4}$/,\n  \t  CO: /^(05|08|11|13|15|17|18|19|20|23|25|27|41|44|47|50|52|54|63|66|68|70|73|76|81|85|86|88|91|94|95|97|99)(\\d{4})$/,\n  \t  CZ: /^\\d{3}\\s?\\d{2}$/,\n  \t  DE: fiveDigit,\n  \t  DK: fourDigit,\n  \t  DO: fiveDigit,\n  \t  DZ: fiveDigit,\n  \t  EE: fiveDigit,\n  \t  ES: /^(5[0-2]{1}|[0-4]{1}\\d{1})\\d{3}$/,\n  \t  FI: fiveDigit,\n  \t  FR: /^(?:(?:0[1-9]|[1-8]\\d|9[0-5])\\d{3}|97[1-46]\\d{2})$/,\n  \t  GB: /^(gir\\s?0aa|[a-z]{1,2}\\d[\\da-z]?\\s?(\\d[a-z]{2})?)$/i,\n  \t  GR: /^\\d{3}\\s?\\d{2}$/,\n  \t  HR: /^([1-5]\\d{4}$)/,\n  \t  HT: /^HT\\d{4}$/,\n  \t  HU: fourDigit,\n  \t  ID: fiveDigit,\n  \t  IE: /^(?!.*(?:o))[A-Za-z]\\d[\\dw]\\s\\w{4}$/i,\n  \t  IL: /^(\\d{5}|\\d{7})$/,\n  \t  IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,\n  \t  IR: /^(?!(\\d)\\1{3})[13-9]{4}[1346-9][013-9]{5}$/,\n  \t  IS: threeDigit,\n  \t  IT: fiveDigit,\n  \t  JP: /^\\d{3}\\-\\d{4}$/,\n  \t  KE: fiveDigit,\n  \t  KR: /^(\\d{5}|\\d{6})$/,\n  \t  LI: /^(948[5-9]|949[0-7])$/,\n  \t  LT: /^LT\\-\\d{5}$/,\n  \t  LU: fourDigit,\n  \t  LV: /^LV\\-\\d{4}$/,\n  \t  LK: fiveDigit,\n  \t  MG: threeDigit,\n  \t  MX: fiveDigit,\n  \t  MT: /^[A-Za-z]{3}\\s{0,1}\\d{4}$/,\n  \t  MY: fiveDigit,\n  \t  NL: /^[1-9]\\d{3}\\s?(?!sa|sd|ss)[a-z]{2}$/i,\n  \t  NO: fourDigit,\n  \t  NP: /^(10|21|22|32|33|34|44|45|56|57)\\d{3}$|^(977)$/i,\n  \t  NZ: fourDigit,\n  \t  // https://www.pakpost.gov.pk/postcodes.php\n  \t  PK: fiveDigit,\n  \t  PL: /^\\d{2}\\-\\d{3}$/,\n  \t  PR: /^00[679]\\d{2}([ -]\\d{4})?$/,\n  \t  PT: /^\\d{4}\\-\\d{3}?$/,\n  \t  RO: sixDigit,\n  \t  RU: sixDigit,\n  \t  SA: fiveDigit,\n  \t  SE: /^[1-9]\\d{2}\\s?\\d{2}$/,\n  \t  SG: sixDigit,\n  \t  SI: fourDigit,\n  \t  SK: /^\\d{3}\\s?\\d{2}$/,\n  \t  TH: fiveDigit,\n  \t  TN: fourDigit,\n  \t  TW: /^\\d{3}(\\d{2,3})?$/,\n  \t  UA: fiveDigit,\n  \t  US: /^\\d{5}(-\\d{4})?$/,\n  \t  ZA: fourDigit,\n  \t  ZM: fiveDigit\n  \t};\n  \tisPostalCode.locales = Object.keys(patterns);\n  \tfunction isPostalCode$1(str, locale) {\n  \t  (0, _assertString.default)(str);\n  \t  if (locale in patterns) {\n  \t    return patterns[locale].test(str);\n  \t  } else if (locale === 'any') {\n  \t    for (var key in patterns) {\n  \t      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n  \t      // istanbul ignore else\n  \t      if (patterns.hasOwnProperty(key)) {\n  \t        var pattern = patterns[key];\n  \t        if (pattern.test(str)) {\n  \t          return true;\n  \t        }\n  \t      }\n  \t    }\n  \t    return false;\n  \t  }\n  \t  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n  \t}\n  \treturn isPostalCode;\n  }\n\n  var _escape = {exports: {}};\n\n  var hasRequired_escape;\n\n  function require_escape () {\n  \tif (hasRequired_escape) return _escape.exports;\n  \thasRequired_escape = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = escape;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction escape(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return str.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\//g, '&#x2F;').replace(/\\\\/g, '&#x5C;').replace(/`/g, '&#96;');\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (_escape, _escape.exports));\n  \treturn _escape.exports;\n  }\n\n  var _unescape = {exports: {}};\n\n  var hasRequired_unescape;\n\n  function require_unescape () {\n  \tif (hasRequired_unescape) return _unescape.exports;\n  \thasRequired_unescape = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = unescape;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction unescape(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return str.replace(/&quot;/g, '\"').replace(/&#x27;/g, \"'\").replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#x2F;/g, '/').replace(/&#x5C;/g, '\\\\').replace(/&#96;/g, '`').replace(/&amp;/g, '&');\n  \t\t  // &amp; replacement has to be the last one to prevent\n  \t\t  // bugs with intermediate strings containing escape sequences\n  \t\t  // See: https://github.com/validatorjs/validator.js/issues/1827\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (_unescape, _unescape.exports));\n  \treturn _unescape.exports;\n  }\n\n  var stripLow = {exports: {}};\n\n  var blacklist = {exports: {}};\n\n  var hasRequiredBlacklist;\n\n  function requireBlacklist () {\n  \tif (hasRequiredBlacklist) return blacklist.exports;\n  \thasRequiredBlacklist = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = blacklist;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction blacklist(str, chars) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return str.replace(new RegExp(\"[\".concat(chars, \"]+\"), 'g'), '');\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (blacklist, blacklist.exports));\n  \treturn blacklist.exports;\n  }\n\n  var hasRequiredStripLow;\n\n  function requireStripLow () {\n  \tif (hasRequiredStripLow) return stripLow.exports;\n  \thasRequiredStripLow = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = stripLow;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tvar _blacklist = _interopRequireDefault(requireBlacklist());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction stripLow(str, keep_new_lines) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var chars = keep_new_lines ? '\\\\x00-\\\\x09\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F' : '\\\\x00-\\\\x1F\\\\x7F';\n  \t\t  return (0, _blacklist.default)(str, chars);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (stripLow, stripLow.exports));\n  \treturn stripLow.exports;\n  }\n\n  var whitelist = {exports: {}};\n\n  var hasRequiredWhitelist;\n\n  function requireWhitelist () {\n  \tif (hasRequiredWhitelist) return whitelist.exports;\n  \thasRequiredWhitelist = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = whitelist;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction whitelist(str, chars) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return str.replace(new RegExp(\"[^\".concat(chars, \"]+\"), 'g'), '');\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (whitelist, whitelist.exports));\n  \treturn whitelist.exports;\n  }\n\n  var isWhitelisted = {exports: {}};\n\n  var hasRequiredIsWhitelisted;\n\n  function requireIsWhitelisted () {\n  \tif (hasRequiredIsWhitelisted) return isWhitelisted.exports;\n  \thasRequiredIsWhitelisted = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isWhitelisted;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tfunction isWhitelisted(str, chars) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  for (var i = str.length - 1; i >= 0; i--) {\n  \t\t    if (chars.indexOf(str[i]) === -1) {\n  \t\t      return false;\n  \t\t    }\n  \t\t  }\n  \t\t  return true;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isWhitelisted, isWhitelisted.exports));\n  \treturn isWhitelisted.exports;\n  }\n\n  var normalizeEmail = {exports: {}};\n\n  var hasRequiredNormalizeEmail;\n\n  function requireNormalizeEmail () {\n  \tif (hasRequiredNormalizeEmail) return normalizeEmail.exports;\n  \thasRequiredNormalizeEmail = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = normalizeEmail;\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar default_normalize_email_options = {\n  \t\t  // The following options apply to all email addresses\n  \t\t  // Lowercases the local part of the email address.\n  \t\t  // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).\n  \t\t  // The domain is always lowercased, as per RFC 1035\n  \t\t  all_lowercase: true,\n  \t\t  // The following conversions are specific to GMail\n  \t\t  // Lowercases the local part of the GMail address (known to be case-insensitive)\n  \t\t  gmail_lowercase: true,\n  \t\t  // Removes dots from the local part of the email address, as that's ignored by GMail\n  \t\t  gmail_remove_dots: true,\n  \t\t  // Removes the subaddress (e.g. \"+foo\") from the email address\n  \t\t  gmail_remove_subaddress: true,\n  \t\t  // Conversts the googlemail.com domain to gmail.com\n  \t\t  gmail_convert_googlemaildotcom: true,\n  \t\t  // The following conversions are specific to Outlook.com / Windows Live / Hotmail\n  \t\t  // Lowercases the local part of the Outlook.com address (known to be case-insensitive)\n  \t\t  outlookdotcom_lowercase: true,\n  \t\t  // Removes the subaddress (e.g. \"+foo\") from the email address\n  \t\t  outlookdotcom_remove_subaddress: true,\n  \t\t  // The following conversions are specific to Yahoo\n  \t\t  // Lowercases the local part of the Yahoo address (known to be case-insensitive)\n  \t\t  yahoo_lowercase: true,\n  \t\t  // Removes the subaddress (e.g. \"-foo\") from the email address\n  \t\t  yahoo_remove_subaddress: true,\n  \t\t  // The following conversions are specific to Yandex\n  \t\t  // Lowercases the local part of the Yandex address (known to be case-insensitive)\n  \t\t  yandex_lowercase: true,\n  \t\t  // all yandex domains are equal, this explicitly sets the domain to 'yandex.ru'\n  \t\t  yandex_convert_yandexru: true,\n  \t\t  // The following conversions are specific to iCloud\n  \t\t  // Lowercases the local part of the iCloud address (known to be case-insensitive)\n  \t\t  icloud_lowercase: true,\n  \t\t  // Removes the subaddress (e.g. \"+foo\") from the email address\n  \t\t  icloud_remove_subaddress: true\n  \t\t};\n\n  \t\t// List of domains used by iCloud\n  \t\tvar icloud_domains = ['icloud.com', 'me.com'];\n\n  \t\t// List of domains used by Outlook.com and its predecessors\n  \t\t// This list is likely incomplete.\n  \t\t// Partial reference:\n  \t\t// https://blogs.office.com/2013/04/17/outlook-com-gets-two-step-verification-sign-in-by-alias-and-new-international-domains/\n  \t\tvar outlookdotcom_domains = ['hotmail.at', 'hotmail.be', 'hotmail.ca', 'hotmail.cl', 'hotmail.co.il', 'hotmail.co.nz', 'hotmail.co.th', 'hotmail.co.uk', 'hotmail.com', 'hotmail.com.ar', 'hotmail.com.au', 'hotmail.com.br', 'hotmail.com.gr', 'hotmail.com.mx', 'hotmail.com.pe', 'hotmail.com.tr', 'hotmail.com.vn', 'hotmail.cz', 'hotmail.de', 'hotmail.dk', 'hotmail.es', 'hotmail.fr', 'hotmail.hu', 'hotmail.id', 'hotmail.ie', 'hotmail.in', 'hotmail.it', 'hotmail.jp', 'hotmail.kr', 'hotmail.lv', 'hotmail.my', 'hotmail.ph', 'hotmail.pt', 'hotmail.sa', 'hotmail.sg', 'hotmail.sk', 'live.be', 'live.co.uk', 'live.com', 'live.com.ar', 'live.com.mx', 'live.de', 'live.es', 'live.eu', 'live.fr', 'live.it', 'live.nl', 'msn.com', 'outlook.at', 'outlook.be', 'outlook.cl', 'outlook.co.il', 'outlook.co.nz', 'outlook.co.th', 'outlook.com', 'outlook.com.ar', 'outlook.com.au', 'outlook.com.br', 'outlook.com.gr', 'outlook.com.pe', 'outlook.com.tr', 'outlook.com.vn', 'outlook.cz', 'outlook.de', 'outlook.dk', 'outlook.es', 'outlook.fr', 'outlook.hu', 'outlook.id', 'outlook.ie', 'outlook.in', 'outlook.it', 'outlook.jp', 'outlook.kr', 'outlook.lv', 'outlook.my', 'outlook.ph', 'outlook.pt', 'outlook.sa', 'outlook.sg', 'outlook.sk', 'passport.com'];\n\n  \t\t// List of domains used by Yahoo Mail\n  \t\t// This list is likely incomplete\n  \t\tvar yahoo_domains = ['rocketmail.com', 'yahoo.ca', 'yahoo.co.uk', 'yahoo.com', 'yahoo.de', 'yahoo.fr', 'yahoo.in', 'yahoo.it', 'ymail.com'];\n\n  \t\t// List of domains used by yandex.ru\n  \t\tvar yandex_domains = ['yandex.ru', 'yandex.ua', 'yandex.kz', 'yandex.com', 'yandex.by', 'ya.ru'];\n\n  \t\t// replace single dots, but not multiple consecutive dots\n  \t\tfunction dotsReplacer(match) {\n  \t\t  if (match.length > 1) {\n  \t\t    return match;\n  \t\t  }\n  \t\t  return '';\n  \t\t}\n  \t\tfunction normalizeEmail(email, options) {\n  \t\t  options = (0, _merge.default)(options, default_normalize_email_options);\n  \t\t  var raw_parts = email.split('@');\n  \t\t  var domain = raw_parts.pop();\n  \t\t  var user = raw_parts.join('@');\n  \t\t  var parts = [user, domain];\n\n  \t\t  // The domain is always lowercased, as it's case-insensitive per RFC 1035\n  \t\t  parts[1] = parts[1].toLowerCase();\n  \t\t  if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {\n  \t\t    // Address is GMail\n  \t\t    if (options.gmail_remove_subaddress) {\n  \t\t      parts[0] = parts[0].split('+')[0];\n  \t\t    }\n  \t\t    if (options.gmail_remove_dots) {\n  \t\t      // this does not replace consecutive dots like example..email@gmail.com\n  \t\t      parts[0] = parts[0].replace(/\\.+/g, dotsReplacer);\n  \t\t    }\n  \t\t    if (!parts[0].length) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (options.all_lowercase || options.gmail_lowercase) {\n  \t\t      parts[0] = parts[0].toLowerCase();\n  \t\t    }\n  \t\t    parts[1] = options.gmail_convert_googlemaildotcom ? 'gmail.com' : parts[1];\n  \t\t  } else if (icloud_domains.indexOf(parts[1]) >= 0) {\n  \t\t    // Address is iCloud\n  \t\t    if (options.icloud_remove_subaddress) {\n  \t\t      parts[0] = parts[0].split('+')[0];\n  \t\t    }\n  \t\t    if (!parts[0].length) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (options.all_lowercase || options.icloud_lowercase) {\n  \t\t      parts[0] = parts[0].toLowerCase();\n  \t\t    }\n  \t\t  } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {\n  \t\t    // Address is Outlook.com\n  \t\t    if (options.outlookdotcom_remove_subaddress) {\n  \t\t      parts[0] = parts[0].split('+')[0];\n  \t\t    }\n  \t\t    if (!parts[0].length) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (options.all_lowercase || options.outlookdotcom_lowercase) {\n  \t\t      parts[0] = parts[0].toLowerCase();\n  \t\t    }\n  \t\t  } else if (yahoo_domains.indexOf(parts[1]) >= 0) {\n  \t\t    // Address is Yahoo\n  \t\t    if (options.yahoo_remove_subaddress) {\n  \t\t      var components = parts[0].split('-');\n  \t\t      parts[0] = components.length > 1 ? components.slice(0, -1).join('-') : components[0];\n  \t\t    }\n  \t\t    if (!parts[0].length) {\n  \t\t      return false;\n  \t\t    }\n  \t\t    if (options.all_lowercase || options.yahoo_lowercase) {\n  \t\t      parts[0] = parts[0].toLowerCase();\n  \t\t    }\n  \t\t  } else if (yandex_domains.indexOf(parts[1]) >= 0) {\n  \t\t    if (options.all_lowercase || options.yandex_lowercase) {\n  \t\t      parts[0] = parts[0].toLowerCase();\n  \t\t    }\n  \t\t    parts[1] = options.yandex_convert_yandexru ? 'yandex.ru' : parts[1];\n  \t\t  } else if (options.all_lowercase) {\n  \t\t    // Any other address\n  \t\t    parts[0] = parts[0].toLowerCase();\n  \t\t  }\n  \t\t  return parts.join('@');\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (normalizeEmail, normalizeEmail.exports));\n  \treturn normalizeEmail.exports;\n  }\n\n  var isSlug = {exports: {}};\n\n  var hasRequiredIsSlug;\n\n  function requireIsSlug () {\n  \tif (hasRequiredIsSlug) return isSlug.exports;\n  \thasRequiredIsSlug = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isSlug;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar charsetRegex = /^[^\\s-_](?!.*?[-_]{2,})[a-z0-9-\\\\][^\\s]*[^-_\\s]$/;\n  \t\tfunction isSlug(str) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  return charsetRegex.test(str);\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isSlug, isSlug.exports));\n  \treturn isSlug.exports;\n  }\n\n  var isLicensePlate = {exports: {}};\n\n  var hasRequiredIsLicensePlate;\n\n  function requireIsLicensePlate () {\n  \tif (hasRequiredIsLicensePlate) return isLicensePlate.exports;\n  \thasRequiredIsLicensePlate = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isLicensePlate;\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar validators = {\n  \t\t  'cs-CZ': function csCZ(str) {\n  \t\t    return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(str);\n  \t\t  },\n  \t\t  'de-DE': function deDE(str) {\n  \t\t    return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|AÖ|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|BÖ|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|FÜ|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|GÖ|GP|GR|GS|GT|GÜ|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|LÖ|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|MÜ|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|NÖ|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|TÜ|ÜB|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|WÜ|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BÜD|BUL|BÜR|BÜS|BÜZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DÜW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FLÖ|FOR|FRG|FRI|FRW|FTL|FÜS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HMÜ|HOG|HOH|HOL|HOM|HOR|HÖS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JÜL|KEH|KEL|KEM|KIB|KLE|KLZ|KÖN|KÖT|KÖZ|KRU|KÜN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LÖB|LOS|LRO|LSZ|LÜN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MÜB|MÜR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|ÖHR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PLÖ|PRÜ|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RÜD|RÜG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SLÜ|SLZ|SMÜ|SOB|SOG|SOK|SÖM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SÜW|SWA|SZB|TBB|TDO|TET|TIR|TÖL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WÜM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\\d{1,4})|([A-Z]{2}[- ]?\\d{1,3})))[- ]?(E|H)?$/.test(str);\n  \t\t  },\n  \t\t  'de-LI': function deLI(str) {\n  \t\t    return /^FL[- ]?\\d{1,5}[UZ]?$/.test(str);\n  \t\t  },\n  \t\t  'en-IN': function enIN(str) {\n  \t\t    return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(str);\n  \t\t  },\n  \t\t  'en-SG': function enSG(str) {\n  \t\t    return /^[A-Z]{3}[ -]?[\\d]{4}[ -]?[A-Z]{1}$/.test(str);\n  \t\t  },\n  \t\t  'es-AR': function esAR(str) {\n  \t\t    return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(str);\n  \t\t  },\n  \t\t  'fi-FI': function fiFI(str) {\n  \t\t    return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(str);\n  \t\t  },\n  \t\t  'hu-HU': function huHU(str) {\n  \t\t    return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\\d{3})|(M\\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \\d{2}-\\d{2})|(CD \\d{3}-\\d{3})|(C-(C|X) \\d{4})|(X-(A|B|C) \\d{4})|(([EPVZ]-\\d{5}))|(S A[A-Z]{2} \\d{2})|(SP \\d{2}-\\d{2}))$/.test(str);\n  \t\t  },\n  \t\t  'pt-BR': function ptBR(str) {\n  \t\t    return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(str);\n  \t\t  },\n  \t\t  'pt-PT': function ptPT(str) {\n  \t\t    return /^(([A-Z]{2}[ -·]?[0-9]{2}[ -·]?[0-9]{2})|([0-9]{2}[ -·]?[A-Z]{2}[ -·]?[0-9]{2})|([0-9]{2}[ -·]?[0-9]{2}[ -·]?[A-Z]{2})|([A-Z]{2}[ -·]?[0-9]{2}[ -·]?[A-Z]{2}))$/.test(str);\n  \t\t  },\n  \t\t  'sq-AL': function sqAL(str) {\n  \t\t    return /^[A-Z]{2}[- ]?((\\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\\d{3}))$/.test(str);\n  \t\t  },\n  \t\t  'sv-SE': function svSE(str) {\n  \t\t    return /^[A-HJ-PR-UW-Z]{3} ?[\\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-ZÅÄÖ ]{2,7}$)/.test(str.trim());\n  \t\t  },\n  \t\t  'en-PK': function enPK(str) {\n  \t\t    return /(^[A-Z]{2}((\\s|-){0,1})[0-9]{3,4}((\\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{3}((\\s|-){0,1})[0-9]{3,4}((\\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{4}((\\s|-){0,1})[0-9]{3,4}((\\s|-)[0-9]{2}){0,1}$)|(^[A-Z]((\\s|-){0,1})[0-9]{4}((\\s|-)[0-9]{2}){0,1}$)/.test(str.trim());\n  \t\t  }\n  \t\t};\n  \t\tfunction isLicensePlate(str, locale) {\n  \t\t  (0, _assertString.default)(str);\n  \t\t  if (locale in validators) {\n  \t\t    return validators[locale](str);\n  \t\t  } else if (locale === 'any') {\n  \t\t    for (var key in validators) {\n  \t\t      /* eslint guard-for-in: 0 */\n  \t\t      var validator = validators[key];\n  \t\t      if (validator(str)) {\n  \t\t        return true;\n  \t\t      }\n  \t\t    }\n  \t\t    return false;\n  \t\t  }\n  \t\t  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isLicensePlate, isLicensePlate.exports));\n  \treturn isLicensePlate.exports;\n  }\n\n  var isStrongPassword = {exports: {}};\n\n  var hasRequiredIsStrongPassword;\n\n  function requireIsStrongPassword () {\n  \tif (hasRequiredIsStrongPassword) return isStrongPassword.exports;\n  \thasRequiredIsStrongPassword = 1;\n  \t(function (module, exports$1) {\n\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = isStrongPassword;\n  \t\tvar _merge = _interopRequireDefault(requireMerge());\n  \t\tvar _assertString = _interopRequireDefault(requireAssertString());\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar upperCaseRegex = /^[A-Z]$/;\n  \t\tvar lowerCaseRegex = /^[a-z]$/;\n  \t\tvar numberRegex = /^[0-9]$/;\n  \t\tvar symbolRegex = /^[-#!$@£%^&*()_+|~=`{}\\[\\]:\";'<>?,.\\/\\\\ ]$/;\n  \t\tvar defaultOptions = {\n  \t\t  minLength: 8,\n  \t\t  minLowercase: 1,\n  \t\t  minUppercase: 1,\n  \t\t  minNumbers: 1,\n  \t\t  minSymbols: 1,\n  \t\t  returnScore: false,\n  \t\t  pointsPerUnique: 1,\n  \t\t  pointsPerRepeat: 0.5,\n  \t\t  pointsForContainingLower: 10,\n  \t\t  pointsForContainingUpper: 10,\n  \t\t  pointsForContainingNumber: 10,\n  \t\t  pointsForContainingSymbol: 10\n  \t\t};\n\n  \t\t/* Counts number of occurrences of each char in a string\n  \t\t * could be moved to util/ ?\n  \t\t*/\n  \t\tfunction countChars(str) {\n  \t\t  var result = {};\n  \t\t  Array.from(str).forEach(function (char) {\n  \t\t    var curVal = result[char];\n  \t\t    if (curVal) {\n  \t\t      result[char] += 1;\n  \t\t    } else {\n  \t\t      result[char] = 1;\n  \t\t    }\n  \t\t  });\n  \t\t  return result;\n  \t\t}\n\n  \t\t/* Return information about a password */\n  \t\tfunction analyzePassword(password) {\n  \t\t  var charMap = countChars(password);\n  \t\t  var analysis = {\n  \t\t    length: password.length,\n  \t\t    uniqueChars: Object.keys(charMap).length,\n  \t\t    uppercaseCount: 0,\n  \t\t    lowercaseCount: 0,\n  \t\t    numberCount: 0,\n  \t\t    symbolCount: 0\n  \t\t  };\n  \t\t  Object.keys(charMap).forEach(function (char) {\n  \t\t    /* istanbul ignore else */\n  \t\t    if (upperCaseRegex.test(char)) {\n  \t\t      analysis.uppercaseCount += charMap[char];\n  \t\t    } else if (lowerCaseRegex.test(char)) {\n  \t\t      analysis.lowercaseCount += charMap[char];\n  \t\t    } else if (numberRegex.test(char)) {\n  \t\t      analysis.numberCount += charMap[char];\n  \t\t    } else if (symbolRegex.test(char)) {\n  \t\t      analysis.symbolCount += charMap[char];\n  \t\t    }\n  \t\t  });\n  \t\t  return analysis;\n  \t\t}\n  \t\tfunction scorePassword(analysis, scoringOptions) {\n  \t\t  var points = 0;\n  \t\t  points += analysis.uniqueChars * scoringOptions.pointsPerUnique;\n  \t\t  points += (analysis.length - analysis.uniqueChars) * scoringOptions.pointsPerRepeat;\n  \t\t  if (analysis.lowercaseCount > 0) {\n  \t\t    points += scoringOptions.pointsForContainingLower;\n  \t\t  }\n  \t\t  if (analysis.uppercaseCount > 0) {\n  \t\t    points += scoringOptions.pointsForContainingUpper;\n  \t\t  }\n  \t\t  if (analysis.numberCount > 0) {\n  \t\t    points += scoringOptions.pointsForContainingNumber;\n  \t\t  }\n  \t\t  if (analysis.symbolCount > 0) {\n  \t\t    points += scoringOptions.pointsForContainingSymbol;\n  \t\t  }\n  \t\t  return points;\n  \t\t}\n  \t\tfunction isStrongPassword(str) {\n  \t\t  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  \t\t  (0, _assertString.default)(str);\n  \t\t  var analysis = analyzePassword(str);\n  \t\t  options = (0, _merge.default)(options || {}, defaultOptions);\n  \t\t  if (options.returnScore) {\n  \t\t    return scorePassword(analysis, options);\n  \t\t  }\n  \t\t  return analysis.length >= options.minLength && analysis.lowercaseCount >= options.minLowercase && analysis.uppercaseCount >= options.minUppercase && analysis.numberCount >= options.minNumbers && analysis.symbolCount >= options.minSymbols;\n  \t\t}\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (isStrongPassword, isStrongPassword.exports));\n  \treturn isStrongPassword.exports;\n  }\n\n  var isVAT = {};\n\n  var hasRequiredIsVAT;\n\n  function requireIsVAT () {\n  \tif (hasRequiredIsVAT) return isVAT;\n  \thasRequiredIsVAT = 1;\n\n  \tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \tObject.defineProperty(isVAT, \"__esModule\", {\n  \t  value: true\n  \t});\n  \tisVAT.default = isVAT$1;\n  \tisVAT.vatMatchers = void 0;\n  \tvar _assertString = _interopRequireDefault(requireAssertString());\n  \tvar algorithms = _interopRequireWildcard(requireAlgorithms());\n  \tfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\n  \tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \tvar AU = function AU(str) {\n  \t  var match = str.match(/^(AU)?(\\d{11})$/);\n  \t  if (!match) {\n  \t    return false;\n  \t  }\n  \t  // @see {@link https://abr.business.gov.au/Help/AbnFormat}\n  \t  var weights = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];\n  \t  str = str.replace(/^AU/, '');\n  \t  var ABN = (parseInt(str.slice(0, 1), 10) - 1).toString() + str.slice(1);\n  \t  var total = 0;\n  \t  for (var i = 0; i < 11; i++) {\n  \t    total += weights[i] * ABN.charAt(i);\n  \t  }\n  \t  return total !== 0 && total % 89 === 0;\n  \t};\n  \tvar CH = function CH(str) {\n  \t  // @see {@link https://www.ech.ch/de/ech/ech-0097/5.2.0}\n  \t  var hasValidCheckNumber = function hasValidCheckNumber(digits) {\n  \t    var lastDigit = digits.pop(); // used as check number\n  \t    var weights = [5, 4, 3, 2, 7, 6, 5, 4];\n  \t    var calculatedCheckNumber = (11 - digits.reduce(function (acc, el, idx) {\n  \t      return acc + el * weights[idx];\n  \t    }, 0) % 11) % 11;\n  \t    return lastDigit === calculatedCheckNumber;\n  \t  };\n\n  \t  // @see {@link https://www.estv.admin.ch/estv/de/home/mehrwertsteuer/uid/mwst-uid-nummer.html}\n  \t  return /^(CHE[- ]?)?(\\d{9}|(\\d{3}\\.\\d{3}\\.\\d{3})|(\\d{3} \\d{3} \\d{3})) ?(TVA|MWST|IVA)?$/.test(str) && hasValidCheckNumber(str.match(/\\d/g).map(function (el) {\n  \t    return +el;\n  \t  }));\n  \t};\n  \tvar PT = function PT(str) {\n  \t  var match = str.match(/^(PT)?(\\d{9})$/);\n  \t  if (!match) {\n  \t    return false;\n  \t  }\n  \t  var tin = match[2];\n  \t  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {\n  \t    return parseInt(a, 10);\n  \t  }), 9) % 11;\n  \t  if (checksum > 9) {\n  \t    return parseInt(tin[8], 10) === 0;\n  \t  }\n  \t  return checksum === parseInt(tin[8], 10);\n  \t};\n  \tvar vatMatchers = isVAT.vatMatchers = {\n  \t  /**\n  \t   * European Union VAT identification numbers\n  \t   */\n  \t  AT: function AT(str) {\n  \t    return /^(AT)?U\\d{8}$/.test(str);\n  \t  },\n  \t  BE: function BE(str) {\n  \t    return /^(BE)?\\d{10}$/.test(str);\n  \t  },\n  \t  BG: function BG(str) {\n  \t    return /^(BG)?\\d{9,10}$/.test(str);\n  \t  },\n  \t  HR: function HR(str) {\n  \t    return /^(HR)?\\d{11}$/.test(str);\n  \t  },\n  \t  CY: function CY(str) {\n  \t    return /^(CY)?\\w{9}$/.test(str);\n  \t  },\n  \t  CZ: function CZ(str) {\n  \t    return /^(CZ)?\\d{8,10}$/.test(str);\n  \t  },\n  \t  DK: function DK(str) {\n  \t    return /^(DK)?\\d{8}$/.test(str);\n  \t  },\n  \t  EE: function EE(str) {\n  \t    return /^(EE)?\\d{9}$/.test(str);\n  \t  },\n  \t  FI: function FI(str) {\n  \t    return /^(FI)?\\d{8}$/.test(str);\n  \t  },\n  \t  FR: function FR(str) {\n  \t    return /^(FR)([A-Z0-9]{2}\\d{9})$/.test(str);\n  \t  },\n  \t  DE: function DE(str) {\n  \t    return /^(DE)?\\d{9}$/.test(str);\n  \t  },\n  \t  EL: function EL(str) {\n  \t    return /^(EL)?\\d{9}$/.test(str);\n  \t  },\n  \t  HU: function HU(str) {\n  \t    return /^(HU)?\\d{8}$/.test(str);\n  \t  },\n  \t  IE: function IE(str) {\n  \t    return /^(IE)?\\d{7}\\w{1}(W)?$/.test(str);\n  \t  },\n  \t  IT: function IT(str) {\n  \t    return /^(IT)?\\d{11}$/.test(str);\n  \t  },\n  \t  LV: function LV(str) {\n  \t    return /^(LV)?\\d{11}$/.test(str);\n  \t  },\n  \t  LT: function LT(str) {\n  \t    return /^(LT)?\\d{9,12}$/.test(str);\n  \t  },\n  \t  LU: function LU(str) {\n  \t    return /^(LU)?\\d{8}$/.test(str);\n  \t  },\n  \t  MT: function MT(str) {\n  \t    return /^(MT)?\\d{8}$/.test(str);\n  \t  },\n  \t  NL: function NL(str) {\n  \t    return /^(NL)?\\d{9}B\\d{2}$/.test(str);\n  \t  },\n  \t  PL: function PL(str) {\n  \t    return /^(PL)?(\\d{10}|(\\d{3}-\\d{3}-\\d{2}-\\d{2})|(\\d{3}-\\d{2}-\\d{2}-\\d{3}))$/.test(str);\n  \t  },\n  \t  PT: PT,\n  \t  RO: function RO(str) {\n  \t    return /^(RO)?\\d{2,10}$/.test(str);\n  \t  },\n  \t  SK: function SK(str) {\n  \t    return /^(SK)?\\d{10}$/.test(str);\n  \t  },\n  \t  SI: function SI(str) {\n  \t    return /^(SI)?\\d{8}$/.test(str);\n  \t  },\n  \t  ES: function ES(str) {\n  \t    return /^(ES)?\\w\\d{7}[A-Z]$/.test(str);\n  \t  },\n  \t  SE: function SE(str) {\n  \t    return /^(SE)?\\d{12}$/.test(str);\n  \t  },\n  \t  /**\n  \t   * VAT numbers of non-EU countries\n  \t   */\n  \t  AL: function AL(str) {\n  \t    return /^(AL)?\\w{9}[A-Z]$/.test(str);\n  \t  },\n  \t  MK: function MK(str) {\n  \t    return /^(MK)?\\d{13}$/.test(str);\n  \t  },\n  \t  AU: AU,\n  \t  BY: function BY(str) {\n  \t    return /^(УНП )?\\d{9}$/.test(str);\n  \t  },\n  \t  CA: function CA(str) {\n  \t    return /^(CA)?\\d{9}$/.test(str);\n  \t  },\n  \t  IS: function IS(str) {\n  \t    return /^(IS)?\\d{5,6}$/.test(str);\n  \t  },\n  \t  IN: function IN(str) {\n  \t    return /^(IN)?\\d{15}$/.test(str);\n  \t  },\n  \t  ID: function ID(str) {\n  \t    return /^(ID)?(\\d{15}|(\\d{2}.\\d{3}.\\d{3}.\\d{1}-\\d{3}.\\d{3}))$/.test(str);\n  \t  },\n  \t  IL: function IL(str) {\n  \t    return /^(IL)?\\d{9}$/.test(str);\n  \t  },\n  \t  KZ: function KZ(str) {\n  \t    return /^(KZ)?\\d{12}$/.test(str);\n  \t  },\n  \t  NZ: function NZ(str) {\n  \t    return /^(NZ)?\\d{9}$/.test(str);\n  \t  },\n  \t  NG: function NG(str) {\n  \t    return /^(NG)?(\\d{12}|(\\d{8}-\\d{4}))$/.test(str);\n  \t  },\n  \t  NO: function NO(str) {\n  \t    return /^(NO)?\\d{9}MVA$/.test(str);\n  \t  },\n  \t  PH: function PH(str) {\n  \t    return /^(PH)?(\\d{12}|\\d{3} \\d{3} \\d{3} \\d{3})$/.test(str);\n  \t  },\n  \t  RU: function RU(str) {\n  \t    return /^(RU)?(\\d{10}|\\d{12})$/.test(str);\n  \t  },\n  \t  SM: function SM(str) {\n  \t    return /^(SM)?\\d{5}$/.test(str);\n  \t  },\n  \t  SA: function SA(str) {\n  \t    return /^(SA)?\\d{15}$/.test(str);\n  \t  },\n  \t  RS: function RS(str) {\n  \t    return /^(RS)?\\d{9}$/.test(str);\n  \t  },\n  \t  CH: CH,\n  \t  TR: function TR(str) {\n  \t    return /^(TR)?\\d{10}$/.test(str);\n  \t  },\n  \t  UA: function UA(str) {\n  \t    return /^(UA)?\\d{12}$/.test(str);\n  \t  },\n  \t  GB: function GB(str) {\n  \t    return /^GB((\\d{3} \\d{4} ([0-8][0-9]|9[0-6]))|(\\d{9} \\d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(str);\n  \t  },\n  \t  UZ: function UZ(str) {\n  \t    return /^(UZ)?\\d{9}$/.test(str);\n  \t  },\n  \t  /**\n  \t   * VAT numbers of Latin American countries\n  \t   */\n  \t  AR: function AR(str) {\n  \t    return /^(AR)?\\d{11}$/.test(str);\n  \t  },\n  \t  BO: function BO(str) {\n  \t    return /^(BO)?\\d{7}$/.test(str);\n  \t  },\n  \t  BR: function BR(str) {\n  \t    return /^(BR)?((\\d{2}.\\d{3}.\\d{3}\\/\\d{4}-\\d{2})|(\\d{3}.\\d{3}.\\d{3}-\\d{2}))$/.test(str);\n  \t  },\n  \t  CL: function CL(str) {\n  \t    return /^(CL)?\\d{8}-\\d{1}$/.test(str);\n  \t  },\n  \t  CO: function CO(str) {\n  \t    return /^(CO)?\\d{10}$/.test(str);\n  \t  },\n  \t  CR: function CR(str) {\n  \t    return /^(CR)?\\d{9,12}$/.test(str);\n  \t  },\n  \t  EC: function EC(str) {\n  \t    return /^(EC)?\\d{13}$/.test(str);\n  \t  },\n  \t  SV: function SV(str) {\n  \t    return /^(SV)?\\d{4}-\\d{6}-\\d{3}-\\d{1}$/.test(str);\n  \t  },\n  \t  GT: function GT(str) {\n  \t    return /^(GT)?\\d{7}-\\d{1}$/.test(str);\n  \t  },\n  \t  HN: function HN(str) {\n  \t    return /^(HN)?$/.test(str);\n  \t  },\n  \t  MX: function MX(str) {\n  \t    return /^(MX)?\\w{3,4}\\d{6}\\w{3}$/.test(str);\n  \t  },\n  \t  NI: function NI(str) {\n  \t    return /^(NI)?\\d{3}-\\d{6}-\\d{4}\\w{1}$/.test(str);\n  \t  },\n  \t  PA: function PA(str) {\n  \t    return /^(PA)?$/.test(str);\n  \t  },\n  \t  PY: function PY(str) {\n  \t    return /^(PY)?\\d{6,8}-\\d{1}$/.test(str);\n  \t  },\n  \t  PE: function PE(str) {\n  \t    return /^(PE)?\\d{11}$/.test(str);\n  \t  },\n  \t  DO: function DO(str) {\n  \t    return /^(DO)?(\\d{11}|(\\d{3}-\\d{7}-\\d{1})|[1,4,5]{1}\\d{8}|([1,4,5]{1})-\\d{2}-\\d{5}-\\d{1})$/.test(str);\n  \t  },\n  \t  UY: function UY(str) {\n  \t    return /^(UY)?\\d{12}$/.test(str);\n  \t  },\n  \t  VE: function VE(str) {\n  \t    return /^(VE)?[J,G,V,E]{1}-(\\d{9}|(\\d{8}-\\d{1}))$/.test(str);\n  \t  }\n  \t};\n  \tfunction isVAT$1(str, countryCode) {\n  \t  (0, _assertString.default)(str);\n  \t  (0, _assertString.default)(countryCode);\n  \t  if (countryCode in vatMatchers) {\n  \t    return vatMatchers[countryCode](str);\n  \t  }\n  \t  throw new Error(\"Invalid country code: '\".concat(countryCode, \"'\"));\n  \t}\n  \treturn isVAT;\n  }\n\n  var hasRequiredValidator;\n\n  function requireValidator () {\n  \tif (hasRequiredValidator) return validator.exports;\n  \thasRequiredValidator = 1;\n  \t(function (module, exports$1) {\n\n  \t\tfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  \t\tObject.defineProperty(exports$1, \"__esModule\", {\n  \t\t  value: true\n  \t\t});\n  \t\texports$1.default = void 0;\n  \t\tvar _toDate = _interopRequireDefault(requireToDate());\n  \t\tvar _toFloat = _interopRequireDefault(requireToFloat());\n  \t\tvar _toInt = _interopRequireDefault(requireToInt());\n  \t\tvar _toBoolean = _interopRequireDefault(requireToBoolean());\n  \t\tvar _equals = _interopRequireDefault(requireEquals());\n  \t\tvar _contains = _interopRequireDefault(requireContains());\n  \t\tvar _matches = _interopRequireDefault(requireMatches());\n  \t\tvar _isEmail = _interopRequireDefault(requireIsEmail());\n  \t\tvar _isURL = _interopRequireDefault(requireIsURL());\n  \t\tvar _isMACAddress = _interopRequireDefault(requireIsMACAddress());\n  \t\tvar _isIP = _interopRequireDefault(requireIsIP());\n  \t\tvar _isIPRange = _interopRequireDefault(requireIsIPRange());\n  \t\tvar _isFQDN = _interopRequireDefault(requireIsFQDN());\n  \t\tvar _isDate = _interopRequireDefault(requireIsDate());\n  \t\tvar _isTime = _interopRequireDefault(requireIsTime());\n  \t\tvar _isBoolean = _interopRequireDefault(requireIsBoolean());\n  \t\tvar _isLocale = _interopRequireDefault(requireIsLocale());\n  \t\tvar _isAbaRouting = _interopRequireDefault(requireIsAbaRouting());\n  \t\tvar _isAlpha = _interopRequireWildcard(requireIsAlpha());\n  \t\tvar _isAlphanumeric = _interopRequireWildcard(requireIsAlphanumeric());\n  \t\tvar _isNumeric = _interopRequireDefault(requireIsNumeric());\n  \t\tvar _isPassportNumber = _interopRequireWildcard(requireIsPassportNumber());\n  \t\tvar _isPort = _interopRequireDefault(requireIsPort());\n  \t\tvar _isLowercase = _interopRequireDefault(requireIsLowercase());\n  \t\tvar _isUppercase = _interopRequireDefault(requireIsUppercase());\n  \t\tvar _isIMEI = _interopRequireDefault(requireIsIMEI());\n  \t\tvar _isAscii = _interopRequireDefault(requireIsAscii());\n  \t\tvar _isFullWidth = _interopRequireDefault(requireIsFullWidth());\n  \t\tvar _isHalfWidth = _interopRequireDefault(requireIsHalfWidth());\n  \t\tvar _isVariableWidth = _interopRequireDefault(requireIsVariableWidth());\n  \t\tvar _isMultibyte = _interopRequireDefault(requireIsMultibyte());\n  \t\tvar _isSemVer = _interopRequireDefault(requireIsSemVer());\n  \t\tvar _isSurrogatePair = _interopRequireDefault(requireIsSurrogatePair());\n  \t\tvar _isInt = _interopRequireDefault(requireIsInt());\n  \t\tvar _isFloat = _interopRequireWildcard(requireIsFloat());\n  \t\tvar _isDecimal = _interopRequireDefault(requireIsDecimal());\n  \t\tvar _isHexadecimal = _interopRequireDefault(requireIsHexadecimal());\n  \t\tvar _isOctal = _interopRequireDefault(requireIsOctal());\n  \t\tvar _isDivisibleBy = _interopRequireDefault(requireIsDivisibleBy());\n  \t\tvar _isHexColor = _interopRequireDefault(requireIsHexColor());\n  \t\tvar _isRgbColor = _interopRequireDefault(requireIsRgbColor());\n  \t\tvar _isHSL = _interopRequireDefault(requireIsHSL());\n  \t\tvar _isISRC = _interopRequireDefault(requireIsISRC());\n  \t\tvar _isIBAN = _interopRequireWildcard(requireIsIBAN());\n  \t\tvar _isBIC = _interopRequireDefault(requireIsBIC());\n  \t\tvar _isMD = _interopRequireDefault(requireIsMD5());\n  \t\tvar _isHash = _interopRequireDefault(requireIsHash());\n  \t\tvar _isJWT = _interopRequireDefault(requireIsJWT());\n  \t\tvar _isJSON = _interopRequireDefault(requireIsJSON());\n  \t\tvar _isEmpty = _interopRequireDefault(requireIsEmpty());\n  \t\tvar _isLength = _interopRequireDefault(requireIsLength());\n  \t\tvar _isByteLength = _interopRequireDefault(requireIsByteLength());\n  \t\tvar _isULID = _interopRequireDefault(requireIsULID());\n  \t\tvar _isUUID = _interopRequireDefault(requireIsUUID());\n  \t\tvar _isMongoId = _interopRequireDefault(requireIsMongoId());\n  \t\tvar _isAfter = _interopRequireDefault(requireIsAfter());\n  \t\tvar _isBefore = _interopRequireDefault(requireIsBefore());\n  \t\tvar _isIn = _interopRequireDefault(requireIsIn());\n  \t\tvar _isLuhnNumber = _interopRequireDefault(requireIsLuhnNumber());\n  \t\tvar _isCreditCard = _interopRequireDefault(requireIsCreditCard());\n  \t\tvar _isIdentityCard = _interopRequireDefault(requireIsIdentityCard());\n  \t\tvar _isEAN = _interopRequireDefault(requireIsEAN());\n  \t\tvar _isISIN = _interopRequireDefault(requireIsISIN());\n  \t\tvar _isISBN = _interopRequireDefault(requireIsISBN());\n  \t\tvar _isISSN = _interopRequireDefault(requireIsISSN());\n  \t\tvar _isTaxID = _interopRequireDefault(requireIsTaxID());\n  \t\tvar _isMobilePhone = _interopRequireWildcard(requireIsMobilePhone());\n  \t\tvar _isEthereumAddress = _interopRequireDefault(requireIsEthereumAddress());\n  \t\tvar _isCurrency = _interopRequireDefault(requireIsCurrency());\n  \t\tvar _isBtcAddress = _interopRequireDefault(requireIsBtcAddress());\n  \t\tvar _isISO = requireIsISO6346();\n  \t\tvar _isISO2 = _interopRequireDefault(requireIsISO6391());\n  \t\tvar _isISO3 = _interopRequireDefault(requireIsISO8601());\n  \t\tvar _isRFC = _interopRequireDefault(requireIsRFC3339());\n  \t\tvar _isISO4 = _interopRequireDefault(requireIsISO15924());\n  \t\tvar _isISO31661Alpha = _interopRequireDefault(requireIsISO31661Alpha2());\n  \t\tvar _isISO31661Alpha2 = _interopRequireDefault(requireIsISO31661Alpha3());\n  \t\tvar _isISO31661Numeric = _interopRequireDefault(requireIsISO31661Numeric());\n  \t\tvar _isISO5 = _interopRequireDefault(requireIsISO4217());\n  \t\tvar _isBase = _interopRequireDefault(requireIsBase32());\n  \t\tvar _isBase2 = _interopRequireDefault(requireIsBase58());\n  \t\tvar _isBase3 = _interopRequireDefault(requireIsBase64());\n  \t\tvar _isDataURI = _interopRequireDefault(requireIsDataURI());\n  \t\tvar _isMagnetURI = _interopRequireDefault(requireIsMagnetURI());\n  \t\tvar _isMailtoURI = _interopRequireDefault(requireIsMailtoURI());\n  \t\tvar _isMimeType = _interopRequireDefault(requireIsMimeType());\n  \t\tvar _isLatLong = _interopRequireDefault(requireIsLatLong());\n  \t\tvar _isPostalCode = _interopRequireWildcard(requireIsPostalCode());\n  \t\tvar _ltrim = _interopRequireDefault(requireLtrim());\n  \t\tvar _rtrim = _interopRequireDefault(requireRtrim());\n  \t\tvar _trim = _interopRequireDefault(requireTrim());\n  \t\tvar _escape = _interopRequireDefault(require_escape());\n  \t\tvar _unescape = _interopRequireDefault(require_unescape());\n  \t\tvar _stripLow = _interopRequireDefault(requireStripLow());\n  \t\tvar _whitelist = _interopRequireDefault(requireWhitelist());\n  \t\tvar _blacklist = _interopRequireDefault(requireBlacklist());\n  \t\tvar _isWhitelisted = _interopRequireDefault(requireIsWhitelisted());\n  \t\tvar _normalizeEmail = _interopRequireDefault(requireNormalizeEmail());\n  \t\tvar _isSlug = _interopRequireDefault(requireIsSlug());\n  \t\tvar _isLicensePlate = _interopRequireDefault(requireIsLicensePlate());\n  \t\tvar _isStrongPassword = _interopRequireDefault(requireIsStrongPassword());\n  \t\tvar _isVAT = _interopRequireDefault(requireIsVAT());\n  \t\tfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\n  \t\tfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n  \t\tvar version = '13.15.26';\n  \t\tvar validator = {\n  \t\t  version: version,\n  \t\t  toDate: _toDate.default,\n  \t\t  toFloat: _toFloat.default,\n  \t\t  toInt: _toInt.default,\n  \t\t  toBoolean: _toBoolean.default,\n  \t\t  equals: _equals.default,\n  \t\t  contains: _contains.default,\n  \t\t  matches: _matches.default,\n  \t\t  isEmail: _isEmail.default,\n  \t\t  isURL: _isURL.default,\n  \t\t  isMACAddress: _isMACAddress.default,\n  \t\t  isIP: _isIP.default,\n  \t\t  isIPRange: _isIPRange.default,\n  \t\t  isFQDN: _isFQDN.default,\n  \t\t  isBoolean: _isBoolean.default,\n  \t\t  isIBAN: _isIBAN.default,\n  \t\t  isBIC: _isBIC.default,\n  \t\t  isAbaRouting: _isAbaRouting.default,\n  \t\t  isAlpha: _isAlpha.default,\n  \t\t  isAlphaLocales: _isAlpha.locales,\n  \t\t  isAlphanumeric: _isAlphanumeric.default,\n  \t\t  isAlphanumericLocales: _isAlphanumeric.locales,\n  \t\t  isNumeric: _isNumeric.default,\n  \t\t  isPassportNumber: _isPassportNumber.default,\n  \t\t  passportNumberLocales: _isPassportNumber.locales,\n  \t\t  isPort: _isPort.default,\n  \t\t  isLowercase: _isLowercase.default,\n  \t\t  isUppercase: _isUppercase.default,\n  \t\t  isAscii: _isAscii.default,\n  \t\t  isFullWidth: _isFullWidth.default,\n  \t\t  isHalfWidth: _isHalfWidth.default,\n  \t\t  isVariableWidth: _isVariableWidth.default,\n  \t\t  isMultibyte: _isMultibyte.default,\n  \t\t  isSemVer: _isSemVer.default,\n  \t\t  isSurrogatePair: _isSurrogatePair.default,\n  \t\t  isInt: _isInt.default,\n  \t\t  isIMEI: _isIMEI.default,\n  \t\t  isFloat: _isFloat.default,\n  \t\t  isFloatLocales: _isFloat.locales,\n  \t\t  isDecimal: _isDecimal.default,\n  \t\t  isHexadecimal: _isHexadecimal.default,\n  \t\t  isOctal: _isOctal.default,\n  \t\t  isDivisibleBy: _isDivisibleBy.default,\n  \t\t  isHexColor: _isHexColor.default,\n  \t\t  isRgbColor: _isRgbColor.default,\n  \t\t  isHSL: _isHSL.default,\n  \t\t  isISRC: _isISRC.default,\n  \t\t  isMD5: _isMD.default,\n  \t\t  isHash: _isHash.default,\n  \t\t  isJWT: _isJWT.default,\n  \t\t  isJSON: _isJSON.default,\n  \t\t  isEmpty: _isEmpty.default,\n  \t\t  isLength: _isLength.default,\n  \t\t  isLocale: _isLocale.default,\n  \t\t  isByteLength: _isByteLength.default,\n  \t\t  isULID: _isULID.default,\n  \t\t  isUUID: _isUUID.default,\n  \t\t  isMongoId: _isMongoId.default,\n  \t\t  isAfter: _isAfter.default,\n  \t\t  isBefore: _isBefore.default,\n  \t\t  isIn: _isIn.default,\n  \t\t  isLuhnNumber: _isLuhnNumber.default,\n  \t\t  isCreditCard: _isCreditCard.default,\n  \t\t  isIdentityCard: _isIdentityCard.default,\n  \t\t  isEAN: _isEAN.default,\n  \t\t  isISIN: _isISIN.default,\n  \t\t  isISBN: _isISBN.default,\n  \t\t  isISSN: _isISSN.default,\n  \t\t  isMobilePhone: _isMobilePhone.default,\n  \t\t  isMobilePhoneLocales: _isMobilePhone.locales,\n  \t\t  isPostalCode: _isPostalCode.default,\n  \t\t  isPostalCodeLocales: _isPostalCode.locales,\n  \t\t  isEthereumAddress: _isEthereumAddress.default,\n  \t\t  isCurrency: _isCurrency.default,\n  \t\t  isBtcAddress: _isBtcAddress.default,\n  \t\t  isISO6346: _isISO.isISO6346,\n  \t\t  isFreightContainerID: _isISO.isFreightContainerID,\n  \t\t  isISO6391: _isISO2.default,\n  \t\t  isISO8601: _isISO3.default,\n  \t\t  isISO15924: _isISO4.default,\n  \t\t  isRFC3339: _isRFC.default,\n  \t\t  isISO31661Alpha2: _isISO31661Alpha.default,\n  \t\t  isISO31661Alpha3: _isISO31661Alpha2.default,\n  \t\t  isISO31661Numeric: _isISO31661Numeric.default,\n  \t\t  isISO4217: _isISO5.default,\n  \t\t  isBase32: _isBase.default,\n  \t\t  isBase58: _isBase2.default,\n  \t\t  isBase64: _isBase3.default,\n  \t\t  isDataURI: _isDataURI.default,\n  \t\t  isMagnetURI: _isMagnetURI.default,\n  \t\t  isMailtoURI: _isMailtoURI.default,\n  \t\t  isMimeType: _isMimeType.default,\n  \t\t  isLatLong: _isLatLong.default,\n  \t\t  ltrim: _ltrim.default,\n  \t\t  rtrim: _rtrim.default,\n  \t\t  trim: _trim.default,\n  \t\t  escape: _escape.default,\n  \t\t  unescape: _unescape.default,\n  \t\t  stripLow: _stripLow.default,\n  \t\t  whitelist: _whitelist.default,\n  \t\t  blacklist: _blacklist.default,\n  \t\t  isWhitelisted: _isWhitelisted.default,\n  \t\t  normalizeEmail: _normalizeEmail.default,\n  \t\t  toString: toString,\n  \t\t  isSlug: _isSlug.default,\n  \t\t  isStrongPassword: _isStrongPassword.default,\n  \t\t  isTaxID: _isTaxID.default,\n  \t\t  isDate: _isDate.default,\n  \t\t  isTime: _isTime.default,\n  \t\t  isLicensePlate: _isLicensePlate.default,\n  \t\t  isVAT: _isVAT.default,\n  \t\t  ibanLocales: _isIBAN.locales\n  \t\t};\n  \t\texports$1.default = validator;\n  \t\tmodule.exports = exports$1.default;\n  \t\tmodule.exports.default = exports$1.default;\n  \t} (validator, validator.exports));\n  \treturn validator.exports;\n  }\n\n  var validatorExports = requireValidator();\n  var defExp = /*@__PURE__*/_commonjsHelpers.getDefaultExportFromCjs(validatorExports);\n\n  var namedExports = /*#__PURE__*/_mergeNamespaces({\n    __proto__: null,\n    default: defExp\n  }, [validatorExports]);\n\n  const defaultExports = Object.isFrozen(defExp) ? Object.assign({}, defExp?.default || defExp || { __emptyModule: true }) : defExp;\n  Object.keys(namedExports || {}).filter((key) => !defaultExports[key]).forEach((key) => defaultExports[key] = namedExports[key]);\n  Object.defineProperty(defaultExports, \"__\" + \"esModule\", { value: true });\n  var index = Object.isFrozen(defExp) ? Object.freeze(defaultExports) : defaultExports;\n\n  return index;\n\n}));\n",
      "relatedPaths": [
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\util\\assertString.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\toDate.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\util\\nullUndefinedCheck.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\alpha.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isFloat.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\toFloat.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\toInt.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\toBoolean.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\equals.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\util\\toString.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\util\\merge.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\contains.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\matches.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\util\\checkHost.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isByteLength.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isFQDN.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isIP.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isEmail.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\util\\includesString.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isURL.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isMACAddress.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isIPRange.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isDate.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isTime.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\util\\includesArray.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isBoolean.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isLocale.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isAbaRouting.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isAlpha.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isAlphanumeric.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isNumeric.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isPassportNumber.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isInt.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isPort.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isLowercase.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isUppercase.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isIMEI.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isAscii.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isFullWidth.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isHalfWidth.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isVariableWidth.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isMultibyte.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\util\\multilineRegex.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isSemVer.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isSurrogatePair.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isDecimal.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isHexadecimal.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isOctal.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isDivisibleBy.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isHexColor.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isRgbColor.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isHSL.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISRC.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isIBAN.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISO31661Alpha2.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isBIC.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isMD5.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isHash.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isBase64.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isJWT.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isJSON.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isEmpty.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isLength.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isULID.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isUUID.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isMongoId.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isAfter.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isBefore.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isIn.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isLuhnNumber.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isCreditCard.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isIdentityCard.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isEAN.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISIN.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISBN.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISSN.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\util\\algorithms.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isTaxID.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isMobilePhone.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isEthereumAddress.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isCurrency.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isBtcAddress.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISO6346.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISO6391.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISO8601.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isRFC3339.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISO15924.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISO31661Alpha3.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISO31661Numeric.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isISO4217.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isBase32.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isBase58.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isDataURI.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isMagnetURI.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\rtrim.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\ltrim.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\trim.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isMailtoURI.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isMimeType.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isLatLong.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isPostalCode.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\escape.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\unescape.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\blacklist.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\stripLow.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\whitelist.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isWhitelisted.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\normalizeEmail.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isSlug.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isLicensePlate.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isStrongPassword.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\lib\\isVAT.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\index.js"
      ],
      "imports": [
        "_commonjsHelpers.js"
      ],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    },
    {
      "name": "validator/es/lib/isEmail",
      "path": "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\es\\lib\\isEmail.js",
      "lastModified": 1769402985934,
      "type": "module",
      "originalName": "isEmail",
      "code": "sap.ui.define((function () { 'use strict';\n\n  function assertString(input) {\n    if (input === undefined || input === null) throw new TypeError(\"Expected a string but received a \".concat(input));\n    if (input.constructor.name !== 'String') throw new TypeError(\"Expected a string but received a \".concat(input.constructor.name));\n  }\n\n  function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n  }\n  function checkHost(host, matches) {\n    for (var i = 0; i < matches.length; i++) {\n      var match = matches[i];\n      if (host === match || isRegExp(match) && match.test(host)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _typeof$1(o) { \"@babel/helpers - typeof\"; return _typeof$1 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof$1(o); }\n\n  /* eslint-disable prefer-rest-params */\n  function isByteLength(str, options) {\n    assertString(str);\n    var min;\n    var max;\n    if (_typeof$1(options) === 'object') {\n      min = options.min || 0;\n      max = options.max;\n    } else {\n      // backwards compatibility: isByteLength(str, min [, max])\n      min = arguments[1];\n      max = arguments[2];\n    }\n    var len = encodeURI(str).split(/%..|./).length - 1;\n    return len >= min && (typeof max === 'undefined' || len <= max);\n  }\n\n  function merge() {\n    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var defaults = arguments.length > 1 ? arguments[1] : undefined;\n    for (var key in defaults) {\n      if (typeof obj[key] === 'undefined') {\n        obj[key] = defaults[key];\n      }\n    }\n    return obj;\n  }\n\n  var default_fqdn_options = {\n    require_tld: true,\n    allow_underscores: false,\n    allow_trailing_dot: false,\n    allow_numeric_tld: false,\n    allow_wildcard: false,\n    ignore_max_length: false\n  };\n  function isFQDN(str, options) {\n    assertString(str);\n    options = merge(options, default_fqdn_options);\n\n    /* Remove the optional trailing dot before checking validity */\n    if (options.allow_trailing_dot && str[str.length - 1] === '.') {\n      str = str.substring(0, str.length - 1);\n    }\n\n    /* Remove the optional wildcard before checking validity */\n    if (options.allow_wildcard === true && str.indexOf('*.') === 0) {\n      str = str.substring(2);\n    }\n    var parts = str.split('.');\n    var tld = parts[parts.length - 1];\n    if (options.require_tld) {\n      // disallow fqdns without tld\n      if (parts.length < 2) {\n        return false;\n      }\n      if (!options.allow_numeric_tld && !/^([a-z\\u00A1-\\u00A8\\u00AA-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {\n        return false;\n      }\n\n      // disallow spaces\n      if (/\\s/.test(tld)) {\n        return false;\n      }\n    }\n\n    // reject numeric TLDs\n    if (!options.allow_numeric_tld && /^\\d+$/.test(tld)) {\n      return false;\n    }\n    return parts.every(function (part) {\n      if (part.length > 63 && !options.ignore_max_length) {\n        return false;\n      }\n      if (!/^[a-z_\\u00a1-\\uffff0-9-]+$/i.test(part)) {\n        return false;\n      }\n\n      // disallow full-width chars\n      if (/[\\uff01-\\uff5e]/.test(part)) {\n        return false;\n      }\n\n      // disallow parts starting or ending with hyphen\n      if (/^-|-$/.test(part)) {\n        return false;\n      }\n      if (!options.allow_underscores && /_/.test(part)) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n  /**\n  11.3.  Examples\n\n     The following addresses\n\n               fe80::1234 (on the 1st link of the node)\n               ff02::5678 (on the 5th link of the node)\n               ff08::9abc (on the 10th organization of the node)\n\n     would be represented as follows:\n\n               fe80::1234%1\n               ff02::5678%5\n               ff08::9abc%10\n\n     (Here we assume a natural translation from a zone index to the\n     <zone_id> part, where the Nth zone of any scope is translated into\n     \"N\".)\n\n     If we use interface names as <zone_id>, those addresses could also be\n     represented as follows:\n\n              fe80::1234%ne0\n              ff02::5678%pvc1.3\n              ff08::9abc%interface10\n\n     where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\n     to the 5th link, and \"interface10\" belongs to the 10th organization.\n   * * */\n  var IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\n  var IPv4AddressFormat = \"(\".concat(IPv4SegmentFormat, \"[.]){3}\").concat(IPv4SegmentFormat);\n  var IPv4AddressRegExp = new RegExp(\"^\".concat(IPv4AddressFormat, \"$\"));\n  var IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';\n  var IPv6AddressRegExp = new RegExp('^(' + \"(?:\".concat(IPv6SegmentFormat, \":){7}(?:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){6}(?:\").concat(IPv4AddressFormat, \"|:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){5}(?::\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,2}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){4}(?:(:\").concat(IPv6SegmentFormat, \"){0,1}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,3}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){3}(?:(:\").concat(IPv6SegmentFormat, \"){0,2}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,4}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){2}(?:(:\").concat(IPv6SegmentFormat, \"){0,3}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,5}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){1}(?:(:\").concat(IPv6SegmentFormat, \"){0,4}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,6}|:)|\") + \"(?::((?::\".concat(IPv6SegmentFormat, \"){0,5}:\").concat(IPv4AddressFormat, \"|(?::\").concat(IPv6SegmentFormat, \"){1,7}|:))\") + ')(%[0-9a-zA-Z.]{1,})?$');\n  function isIP(ipAddress) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assertString(ipAddress);\n\n    // accessing 'arguments' for backwards compatibility: isIP(ipAddress [, version])\n    // eslint-disable-next-line prefer-rest-params\n    var version = (_typeof(options) === 'object' ? options.version : arguments[1]) || '';\n    if (!version) {\n      return isIP(ipAddress, {\n        version: 4\n      }) || isIP(ipAddress, {\n        version: 6\n      });\n    }\n    if (version.toString() === '4') {\n      return IPv4AddressRegExp.test(ipAddress);\n    }\n    if (version.toString() === '6') {\n      return IPv6AddressRegExp.test(ipAddress);\n    }\n    return false;\n  }\n\n  var default_email_options = {\n    allow_display_name: false,\n    allow_underscores: false,\n    require_display_name: false,\n    allow_utf8_local_part: true,\n    require_tld: true,\n    blacklisted_chars: '',\n    ignore_max_length: false,\n    host_blacklist: [],\n    host_whitelist: []\n  };\n\n  /* eslint-disable max-len */\n  /* eslint-disable no-control-regex */\n  var splitNameAddress = /^([^\\x00-\\x1F\\x7F-\\x9F\\cX]+)</i;\n  var emailUserPart = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]+$/i;\n  var gmailUserPart = /^[a-z\\d]+$/;\n  var quotedEmailUser = /^([\\s\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f\\x21\\x23-\\x5b\\x5d-\\x7e]|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]))*$/i;\n  var emailUserUtf8Part = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\u00A1-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+$/i;\n  var quotedEmailUserUtf8 = /^([\\s\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f\\x21\\x23-\\x5b\\x5d-\\x7e\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))*$/i;\n  var defaultMaxEmailLength = 254;\n  /* eslint-enable max-len */\n  /* eslint-enable no-control-regex */\n\n  /**\n   * Validate display name according to the RFC2822: https://tools.ietf.org/html/rfc2822#appendix-A.1.2\n   * @param {String} display_name\n   */\n  function validateDisplayName(display_name) {\n    var display_name_without_quotes = display_name.replace(/^\"(.+)\"$/, '$1');\n    // display name with only spaces is not valid\n    if (!display_name_without_quotes.trim()) {\n      return false;\n    }\n\n    // check whether display name contains illegal character\n    var contains_illegal = /[\\.\";<>]/.test(display_name_without_quotes);\n    if (contains_illegal) {\n      // if contains illegal characters,\n      // must to be enclosed in double-quotes, otherwise it's not a valid display name\n      if (display_name_without_quotes === display_name) {\n        return false;\n      }\n\n      // the quotes in display name must start with character symbol \\\n      var all_start_with_back_slash = display_name_without_quotes.split('\"').length === display_name_without_quotes.split('\\\\\"').length;\n      if (!all_start_with_back_slash) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isEmail$1(str, options) {\n    assertString(str);\n    options = merge(options, default_email_options);\n    if (options.require_display_name || options.allow_display_name) {\n      var display_email = str.match(splitNameAddress);\n      if (display_email) {\n        var display_name = display_email[1];\n\n        // Remove display name and angle brackets to get email address\n        // Can be done in the regex but will introduce a ReDOS (See  #1597 for more info)\n        str = str.replace(display_name, '').replace(/(^<|>$)/g, '');\n\n        // sometimes need to trim the last space to get the display name\n        // because there may be a space between display name and email address\n        // eg. myname <address@gmail.com>\n        // the display name is `myname` instead of `myname `, so need to trim the last space\n        if (display_name.endsWith(' ')) {\n          display_name = display_name.slice(0, -1);\n        }\n        if (!validateDisplayName(display_name)) {\n          return false;\n        }\n      } else if (options.require_display_name) {\n        return false;\n      }\n    }\n    if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {\n      return false;\n    }\n    var parts = str.split('@');\n    var domain = parts.pop();\n    var lower_domain = domain.toLowerCase();\n    if (options.host_blacklist.length > 0 && checkHost(lower_domain, options.host_blacklist)) {\n      return false;\n    }\n    if (options.host_whitelist.length > 0 && !checkHost(lower_domain, options.host_whitelist)) {\n      return false;\n    }\n    var user = parts.join('@');\n    if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {\n      /*\n      Previously we removed dots for gmail addresses before validating.\n      This was removed because it allows `multiple..dots@gmail.com`\n      to be reported as valid, but it is not.\n      Gmail only normalizes single dots, removing them from here is pointless,\n      should be done in normalizeEmail\n      */\n      user = user.toLowerCase();\n\n      // Removing sub-address from username before gmail validation\n      var username = user.split('+')[0];\n\n      // Dots are not included in gmail length restriction\n      if (!isByteLength(username.replace(/\\./g, ''), {\n        min: 6,\n        max: 30\n      })) {\n        return false;\n      }\n      var _user_parts = username.split('.');\n      for (var i = 0; i < _user_parts.length; i++) {\n        if (!gmailUserPart.test(_user_parts[i])) {\n          return false;\n        }\n      }\n    }\n    if (options.ignore_max_length === false && (!isByteLength(user, {\n      max: 64\n    }) || !isByteLength(domain, {\n      max: 254\n    }))) {\n      return false;\n    }\n    if (!isFQDN(domain, {\n      require_tld: options.require_tld,\n      ignore_max_length: options.ignore_max_length,\n      allow_underscores: options.allow_underscores\n    })) {\n      if (!options.allow_ip_domain) {\n        return false;\n      }\n      if (!isIP(domain)) {\n        if (!domain.startsWith('[') || !domain.endsWith(']')) {\n          return false;\n        }\n        var noBracketdomain = domain.slice(1, -1);\n        if (noBracketdomain.length === 0 || !isIP(noBracketdomain)) {\n          return false;\n        }\n      }\n    }\n    if (options.blacklisted_chars) {\n      if (user.search(new RegExp(\"[\".concat(options.blacklisted_chars, \"]+\"), 'g')) !== -1) return false;\n    }\n    if (user[0] === '\"' && user[user.length - 1] === '\"') {\n      user = user.slice(1, user.length - 1);\n      return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);\n    }\n    var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;\n    var user_parts = user.split('.');\n    for (var _i = 0; _i < user_parts.length; _i++) {\n      if (!pattern.test(user_parts[_i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  var namedExports = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    default: isEmail$1\n  });\n\n  const defaultExports = Object.isFrozen(isEmail$1) ? Object.assign({}, isEmail$1?.default || isEmail$1 || { __emptyModule: true }) : isEmail$1;\n  Object.keys(namedExports || {}).filter((key) => !defaultExports[key]).forEach((key) => defaultExports[key] = namedExports[key]);\n  Object.defineProperty(defaultExports, \"__\" + \"esModule\", { value: true });\n  var isEmail = Object.isFrozen(isEmail$1) ? Object.freeze(defaultExports) : defaultExports;\n\n  return isEmail;\n\n}));\n",
      "relatedPaths": [
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\es\\lib\\util\\assertString.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\es\\lib\\util\\checkHost.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\es\\lib\\isByteLength.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\es\\lib\\util\\merge.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\es\\lib\\isFQDN.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\es\\lib\\isIP.js",
        "D:\\SAP\\fiori-shopping\\shopping1\\node_modules\\validator\\es\\lib\\isEmail.js"
      ],
      "imports": [],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    },
    {
      "name": "_commonjsHelpers",
      "originalName": "_commonjsHelpers",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n\tfunction getDefaultExportFromCjs (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\texports.getDefaultExportFromCjs = getDefaultExportFromCjs;\n\n}));\n",
      "relatedPaths": [],
      "imports": [],
      "dynamicImports": [],
      "generated": true,
      "isWebComponent": false,
      "type": "chunk"
    }
  ]
}